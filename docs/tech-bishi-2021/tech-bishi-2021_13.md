# 第三章 第 6 节 vivo 2020 秋招笔试真题

> 原文：[`www.nowcoder.com/tutorial/10028/1ddfd88eda0047e1baa0beb56b799261`](https://www.nowcoder.com/tutorial/10028/1ddfd88eda0047e1baa0beb56b799261)

# vivo 2020 秋招笔试真题

![](img/1d2822580e7fc6afcc5ccf34cd7bcdbb.png)

### 1、拆礼盒

【题目描述】小 v 所在的公司即将举行年会，年会方案设计过程中必不可少的一项就是抽奖活动。小 v 在本次活动中被委以重任，负责抽奖活动的策划；为了让中奖的礼物更加精美且富有神秘感，打算采用礼品盒来包装奖品，此时小 v 发挥了自己的创意想捉弄一下获奖的同事，便采取了多重包装来包装奖品。

现给出一个字符串，并假定用一对圆括号( )表示一个礼品盒，0 表示奖品，你能据此帮获奖者算出最少要拆多少个礼品盒才能拿到奖品吗？

**输入描述**

一行字符串，仅有'('、')'、'0' 组成，其中一对'(' ')'表示一个礼品盒，‘0’表示奖品；输入的字符串一定是有效的，即'(' ')'一定是成对出现的。

**输出描述**

输出结果为一个数字，表示小 v 要拆的最少礼品盒数量

**示例 1**

**输入** 

```cpp
(()(()((()(0)))))
```

**输出**

```cpp
5
```

**示例 2**

**输入**

```cpp
(((0)))
```

**输出**

```cpp
3
```

**【解题思路】**

记录左括号的数量，遇到右括号进行匹配即可。

**【参考代码】**

```cpp
int solution(string str) {
    int L = 0;
    int sum = 0;
    for (int i = 0; i < str.size(); i++) {
        if (str[i] == '(')
            L++;
        else if (str[i] == ')')
            L--;
        else if (str[i] == '0') {
            sum = L;
            break;
        }
    }
    // TODO Write your code here
    return sum;
}
```

### 2、报数

【题目描述】今年 7 月份 vivo 迎来了新入职的大学生，现在需要为每个新同事分配一个工号。人力资源部同事小 v 设计了一个方法为每个人进行排序并分配最终的工号，具体规则是：

将 N（N<10000）个人排成一排，从第 1 个人开始报数；如果报数是 M 的倍数就出列，报到队尾后则回到队头继续报，直到所有人都出列；

最后按照出列顺序为每个人依次分配工号。请你使用自己擅长的编程语言帮助小 v 实现此方法。

**输入描述**

输入 2 个正整数，空格分隔，第一个代表人数 N，第二个代表 M：

**输出描述**

输出一个 int 数组，每个数据表示原来在队列中的位置用空格隔开，表示出列顺序：

**示例 1**

**输入**

```cpp
6 3
```

**输出**

```cpp
3 6 4 2 5 1
```

**说明**

6 个人排成一排，原始位置编号即为 1-6。最终输出 3 6 4 2 5 1 表示的是原来编号为 3 的第一个出列，编号为 1 的最后一个出列。

**【****解题思路】**

经典约瑟夫问题。

**【参考代码】**

```cpp
void solution(int N, int M) {
    if (N < 1 || M < 1)
        return;
    vector<int> v(N);
    for (int i = 0; i < N; i++)
        v[i] = i + 1;
    int i = 0;
    while (v.size() > 0) {
        i += M - 1;
        if (i >= v.size())
            i = i % v.size();
        cout << v[i] << " ";
        v.erase(i + v.begin());
    }
    cout << endl;
}
```

### 3、跳盒子

【题目描述】小 v 在公司负责游戏运营，今天收到一款申请新上架的游戏“跳一跳”，为了确保提供给广大玩家朋友们的游戏都是高品质的，按照运营流程小 v 必须对新游戏进行全方位了解体验和评估。这款游戏的规则如下：

有 n 个盒子排成了一行，每个盒子上面有一个数字 a[i]，表示在该盒子上的人最多能向右移动 a[i]个盒子（比如当前所在盒子上的数字是 3，则表示可以一次向右前进 1 个盒子，2 个盒子或者 3 个盒子）。

现在小 v 从左边第一个盒子上开始体验游戏，请问**最少**需要移动几次能到最后一个盒子上？

**输入描述**

输入：2 2 3 0 4
表示现在有 5 个盒子，上面的数字分别是 2, 2, 3, 0, 4。

**输出描述**

输出：2
小 v 有两种跳法：
跳法 1：盒子 1 -> 盒子 2 -> 盒子 3 -> 盒子 5，共 3 下
跳法 2：盒子 1 -> 盒子 3 -> 盒子 5，共 2 下
跳法 2 的步骤数最少，所以输出最少步数：2。

**备注**

如果没有盒子或跳不到最后一个盒子上，则返回-1；如果已经在最后盒子上，则直接返回 0。

**示例 1**

**输入**

```cpp
2 2 3 0 4
```

**输出**

```cpp
2
```

【**解题思路】**

i+a[i]即 i 位置最多可跳至 i+a[i]位置，最后一个位置为 N-1，假如我们想跳至位置 j，我们只需在 j 前面中找出不小于 j 的数就代表可跳至 j，取最前面的那一个不小于 j 的就可得到最小步数。

【**参考代码】**

```cpp
int solution(int a[], int N) {
    int left = 0;
    int right = 0;
    int step = 0;
    while (right < N - 1) {
        ++step;
        int next = right;
        for (int i = left; i <= right; ++i) {
            if (i + a[i] > next) {
                next = i + a[i];
                left = i + 1;
            }
        }
        if (next == right)
            return -1;
        right = next;
    }
    return step;
}
```

### 4、服务部署

【题目描述】小 v 是公司的运维工程师，现有一个有关应用程序部署的任务如下：

1、一台服务器的磁盘空间**、**内存是固定的，现在有 N 个应用程序要部署；

2、每个应用程序所需要的磁盘、内存不同，每个应用程序允许访问的用户数也不同，且同一个应用程序不能在一台服务器上部署多个。

对于一台服务器而言，如何组合部署应用程序能够使得单台服务器允许访问的用户数最多**？**

**输入描述**

输入包括三个参数，空格分隔，分别表示服务器的磁盘大小、内存大小，以及应用程序列表；
其中第三个参数即应用程序列表，表述方式为：多个应用程序信息之间用'#' 分隔，每个应用程序的信息包括 ',' 分隔的部署所需磁盘空间、内存、允许访问的用户量三个数字；比如 50,20,2000 表示部署该应用程序需要 50G 磁盘空间，20G 内存，允许访问的用户数是 2000

**输出描述**

单台服务器能承载的最大用户数

**示例 1**

**输入**

```cpp
15 10 5,1,1000#2,3,3000#5,2,15000#10,4,16000
```

**输出**

```cpp
31000
```

**说明**

组合部署服务 5,2,15000、10,4,16000，可以让单台服务器承载最大用户数 31000

**【解题思路】**

三维背包问题，直接 dp 即可。

**【参考代码】**

```cpp
vector<vector<vector<int> > > dp(countOfApp + 1, vector<vector<int>>(disk + 1, vector<int>(mem + 1)));
for (int i = 1; i <= countOfApp; i++) {
    for (int j = disk; j > 0; j--) {
        for (int k = mem; k > 0; k--) {
            if (j >= disks[i - 1] && k >= mems[i - 1]) {
                dp[i][j][k] = max(dp[i - 1][j][k],
                                  dp[i - 1][j - disks[i - 1]][k - mems[i - 1]] +
                                      users[i - 1]);
            } else {
                dp[i][j][k] = dp[i - 1][j][k];
            }
        }
    }
}
return dp[countOfApp][disk][mem];
```

### 5、消消乐

【题目描述】小 v 在 vivo 手机的应用商店中下载了一款名为“一维消消乐”的游戏，介绍如下：

1、给出一些不同颜色的豆子，豆子的颜色用数字（0-9）表示，即不同的数字表示不同的颜色；

2、通过不断地按行消除相同颜色且连续的豆子来积分，直到所有的豆子都消掉为止；

3、假如每一轮可以消除相同颜色的连续 k 个豆子（k >= 1），这样一轮之后小 v 将得到 k*k 个积分；

4、由于仅可按行消除，不可跨行或按列消除，因此谓之“一维消消乐”。

请你帮助小 v 计算出最终能获得的最大积分。

 ![](img/6497eb6d6afc0e868184b5906757c193.png)

**输入描述**

输入一行 n 个正整数，代表这一行中豆子的颜色及排列。
示例：
输入：1 4 2 2 3 3 2 4 1
输出：21
示例说明：
第一轮消除 3，获得 4 分，序列变成 1 4 2 2 2 4 1
第二轮消除 2，获得 9 分，序列变成 1 4 4 1
第三轮消除 4，获得 4 分，序列变成 1 1
第四轮消除 1，获得 4 分，序列为空
总共得分 21 分

小 V 最终能拿到的最大积分。

**示例 1**

输入

```cpp
1 4 2 2 3 3 2 4 1
```

输出

```cpp
21
```

**【解题思路】**

用链表记录数组然后搜索回溯，也可以类似 leetcode 546 的方法 dp 解决。

**【参考代码】**

```cpp
static class Node {
    Node prev;
    Node next;
    int val;
    Node(int val) {
        this.val = val;
    }
}
private static int solution(int[] input) {
    // TODO Write your code here
    Node head = new Node(0);
    Node node = head;
    for (int i = 0; i < input.length; ++i) {
        Node p = new Node(input[i]);
        p.prev = node;
        node.next = p;
        node = p;
    }
    return search(head);
}
static int search(Node head){
    if(head.next == null)return 0;

    int max = 0;
    Node p=head.next;
    while(p!=null){
        Node r=p;
        int c=1;
        while(r.next!=null && r.next.val==r.val){ r=r.next; ++c;}
        // remove
        p.prev.next = r.next;
        if(r.next!=null)r.next.prev=p.prev;
        int val = c*c + search(head);
        // restore
        p.prev.next = p;
        if(r.next!=null)r.next.prev=r;
        max = Math.max(max,val);

        p = r.next;
    }

    return max;
}
```