# 腾讯 2016 研发工程师笔试题（一）

## 1

爸爸去哪儿中的 3 对父子站成一排，各自父子之间不能相邻，比如石头不能和郭涛挨着，以此类推，共有几种站法？

正确答案: C   你的答案: 空 (错误)

```cpp
120
```

```cpp
48
```

```cpp
240
```

```cpp
144
```

本题知识点

数学运算

讨论

[胡哥](https://www.nowcoder.com/profile/360726)

**假设三对父子分别是 Aa、Bb**  查看全部)

编辑于 2016-04-11 11:20:15

* * *

[Double_k](https://www.nowcoder.com/profile/122986)

容斥原理，6 个人全排列-一对父子相邻+两对父子相邻-三队父子相邻 A(6,6)-C(3,1)*A(2,2)*A(5,5) + C(3,2)*A(4,4)*A(2,2)*A(2,2) - A(3,3)*A(2,2)*A(2,2)*A(2,2) = 240

发表于 2015-09-06 14:46:02

* * *

[牛客 632315 号](https://www.nowcoder.com/profile/632315)

给大家另提供一种思路，集合算法：A：表示 Aa 相邻的所有情况 B：表示 Bb 相邻的所有情况 C：表示 Cc 相邻的所有情况 AUB : 表示集合 A 和 B 的并 A^B：表示集合 A 和 B 的交那么题目的解为：X = A(6,6) - A- B - C +AUB + AUC + BUC -A^B^C 在计算 AUB 的时候，我们把 Aa 捆绑，Bb 捆绑看成一个元素所以就有上式子等于 X = 720 -  A(5,5)*2*3 + A(4,4)*4*3 - A(3,3)*2*2*2 = 240

发表于 2015-09-06 17:29:39

* * *

## 2

请找出下面程序中有哪些错误：

```cpp
int main(){
   int i = 10;
   int j = 1;
   const int *p1;//(1)
   int const *p2 = &i; //(2)
   p2 = &j;//(3)
   int *const p3 = &i;//(4)
   *p3 = 20;//(5)
   *p2 = 30;//(6)
   p3 = &j;//(7)
return 0;
}
```

正确答案: C   你的答案: 空 (错误)

```cpp
1,2,3,4,5,6,7
```

```cpp
1,3,5,6
```

```cpp
6,7
```

```cpp
3,5
```

本题知识点

C++ C 语言

讨论

[Monika-蕊](https://www.nowcoder.com/profile/882933)

const 在前，内容不能变；const 在后，指针不能变；const* ，指针指向为常量；*const ，指针本身为常量。

发表于 2015-09-06 11:15:20

* * *

[Where？](https://www.nowcoder.com/profile/717747)

不用死记！  理解记忆遇到 const 修饰的时候，从右向左读 最容易区分如： const int *p1;//则 const 修饰的是 int *p1 说明这个变量是不能变的，就是 p1 所指向的变量是常量变量 int const *p2 = &i; //const 修饰的是  *p2(表示所指向的变量)  说明 p2 所指的变量不能改变，也就是 指向常量变量。int *const p3 = &i;  //const 修饰的是  p3  说明指针变量的值不能改变，也就是不能让 p3 指针再指向其他值

发表于 2015-11-30 19:25:09

* * *

[得之，我幸；失之，我命](https://www.nowcoder.com/profile/850321)

看这个吧，关键是“ 从右向左读的记忆方式”[`www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777416.html`](http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777416.html)

发表于 2015-09-06 15:23:53

* * *

## 3

以下代码输出什么 ____.

```cpp
#include <stdio.h>
int main(){
   int a[5] = {1, 2, 3, 4, 5};
   int *p = (int *)(&a + 1);
   printf("%d", *(p - 1));
}
```

正确答案: C   你的答案: 空 (错误)

```cpp
1
```

```cpp
2
```

```cpp
5
```

```cpp
出现错误
```

本题知识点

C++ C 语言

讨论

[张佃鹏](https://www.nowcoder.com/profile/851149)

选择 c，&a 表示一个指向大小为 5 数组的指针，那么&a+1 就是表示一个指向大小为 5 的下一个数组的指针，也就是数组 a 最后一个元素的下一个位置，那么 int*p=(int*)(&a+1)进行强制类型转换，将指向数组的指针转换为指向第二个数组中首元素的指针，所以 p-1 则是指向第一个数组中最后一个元素的指针，所以输出是 5

编辑于 2015-09-06 11:15:29

* * *

[Radar](https://www.nowcoder.com/profile/312842)

数组名 a 可以作为数组的首地址，而&a 是数组的指针。int *p=(int *)(&a+1);//这条语句中&a 代表整个数组的地址，+1 应加上 sizeof(a)的长度，故指针 p 指向 a[5]处。printf("%d",(*p-1));//(*p-1) == a[4],语句输出 a[4]的值，为 5,**答案 C**

编辑于 2015-09-06 10:27:49

* * *

[caleb00](https://www.nowcoder.com/profile/7085041)

本题选 C。此题考查对 C 语言类型与内存的关系的理解，下面讲解一下通用的解题思路。首先确认一点:a 的类型为 5 个元素的 int 数组，其类型可以看作是 int[5]，虽然不存在这种类型，但是这么理解是没有问题的。C/C++中指针和数字的运算是将指针按照其类型大小进行前后移动相应个数的字节数。如 int 类型大小(sizeof 值)为 4，char 为 1。 比如，int *p; char* q; p+1;就是将 p 的值(内存地址)加 4(int 类型的字节数)，q+1 则是将 q 的值加 1(char 类型的字节数)。所以，题目中 &a+1 的意思就是将 a 的地址加上 5 个 int 的字节数，因为 a 的类型为 int[5]，然后将结果强制类型转换为 int *后赋值给 p。可是，a 的地址又是什么呢？ a 的类型为 int[5]，所以，a 的地址是指向了 5 个 int 类型元素的首地址，它的 sizeof 值是 4*5=20，所以 &a+1 就是数组 a 最后一个元素后面的 20 个字节的首地址。强制类型转换后，变成数组后面一个 int 空间的首地址。 所以，最后 p-1 就是数组最后一个 int 空间的首地址，*(p-1)就是数组最后一个元素了。总之，类型只是标记内存读写的方式，或者说是内存分配的方式。而指针作为一种可以与内存地址等价的存在，其算术运算必须要结合类型的 sizeof 值。

编辑于 2021-04-18 16:22:52

* * *

## 4

设 k1,k2 是矩阵 A 的两个不同的特征值，a 与 b 是 A 的分别属于 k1,k2 的特征向量，则由 a 与 b 是：

正确答案: B   你的答案: 空 (错误)

```cpp
线性相关
```

```cpp
线性无关
```

```cpp
对应分量成比例
```

```cpp
可能有零向量
```

本题知识点

编程基础 *讨论

[Forlove 姗姗](https://www.nowcoder.com/profile/273998)

不同特征值的特征向量线性无关，难道不选 B？？？？？

发表于 2015-09-06 10:22:10

* * *

[双ゾ翅膀飞翔](https://www.nowcoder.com/profile/6282567)

a.b 为不同特征值，所以为线性无关

发表于 2017-08-24 11:38:32

* * *

[取个昵称好难](https://www.nowcoder.com/profile/390148)

此题答案选 B，根据定义 特征向量不能为 0 向量。

发表于 2015-09-06 10:38:52

* * *

## 5

有如下 C++代码：

```cpp
struct A{
  void foo(){printf("foo");}
  virtual void bar(){printf("bar");}
  A(){bar();}
};
struct B:A{
  void foo(){printf("b_foo");}
  void bar(){printf("b_bar");}
};
```

那么

```cpp
A *p = new B;
p->foo();
p->bar();
```

输出为：

正确答案: A   你的答案: 空 (错误)

```cpp
barfoob_bar
```

```cpp
foobarb_bar
```

```cpp
barfoob_foo
```

```cpp
foobarb_fpp
```

本题知识点

C++ C 语言

讨论

[牛客职导官方账号](https://www.nowcoder.com/profile/897353)

【正确答案】A
【解析】A *  查看全部)

编辑于 2021-11-18 08:39:36

* * *

[Ze](https://www.nowcoder.com/profile/937369)

A *p=newB;// A 类指针指向一个实例化对象 B， B 类继承 A 类，先调用父类的无参构造函数，bar()输出 bar，B 类没有自己显示定义的构造函数。p->foo();//执行 B 类里的 foo()函数，因为 foo 不是虚函数，所以直接调用父类的 foo 函数，输出 foop->bar();//执行 B 类的 bar()函数, 该函数为虚函数，调用子类的实现，输出 b_bar

编辑于 2015-09-06 10:48:49

* * *

[张佃鹏](https://www.nowcoder.com/profile/851149)

答案是 A，一般不建议在构造函数或者析构函数中调用虚函数，因为在构造函数和析构函数中调用虚函数不会呈现多态性，也就是说在构造基类构造函数的时候，派生类的部分还没有构造，怎么谈去用虚函数实现动态绑定派生生类对象呢，所以构造 B 基类部分的时候，调用的基类的函数 bar 对于 foo 函数不是虚函数不会有动态绑定，所以调用的基类部分对于第三个 bar 调用，是虚函数，实现动态绑定，所以调用的是派生类部分

发表于 2015-09-06 11:21:52

* * *

## 6

linux 下，指定文件 file1 为所有用户可读，可写，可执行，执行命令：___1__。修改 file1 的拥有者为 test，拥有组为 user,执行命令:___2__。

正确答案: C   你的答案: 空 (错误)

```cpp
chmod 666 file1,chown test file1 , chgrp user file1
```

```cpp
chmod 777 file1,chown user file1 , chgrp test file1
```

```cpp
chmod 777 file1,chown test file1 , chgrp user file1
```

```cpp
chmod 999 file1,chown user:test file1
```

本题知识点

Linux

讨论

[icebreaker](https://www.nowcoder.com/profile/658689)

```cpp
# 改变权限
chmod 777 filepath 
# 改变所有者
chown test filepath 
# 改变所属组
chgrp user filepath
```

编辑于 2015-09-07 18:33:01

* * *

[Anna8023](https://www.nowcoder.com/profile/705028)

按题目要求来说，选项都有问题，应该是:chmod 777 file1, chown test:user file1

发表于 2015-11-17 10:46:19

* * *

[Kevim-Yan](https://www.nowcoder.com/profile/580243)

778 是不能运行的，只能是 8 进制数，应该是 chmod 777 file1 chown test file1 chgrp user file1

发表于 2015-09-06 10:17:58

* * *

## 7

哪些设计模式是降低资源使用率：

正确答案: B C   你的答案: 空 (错误)

```cpp
prototype
```

```cpp
singleton
```

```cpp
flyweight
```

```cpp
abstract factory
```

本题知识点

软件工程

讨论

[Charles_Xiong91](https://www.nowcoder.com/profile/846240)

首先单例模式肯定降低了资源使用率，保证该类的实例永远只有一个！原型模式适用于在初始化信息不发生变换的情况，克隆的方法比较适合，主要的目的是避免重新初始化对象，如果后面需要对新对象进行，还需要区分深拷贝和浅拷贝。无论是深拷贝还是浅拷贝只是复制了资源，并没有降低资源使用率。享元模式(Flyweight): 基于共享技术用于把一些共同的信息（或模块）抽象出来，避免了大量相似类的开销，也降低了资源的使用率。如 Java 和 C++ 初始化一个 string 类的信息,以 C++为例: string s ="hello"; string p = "hello"。(这个在 C++中有问题，容易混淆，特此说明，也有考察 C++中 string 实现的问题。建议用 C 来描述 char *s = "hello"和 char *p = "hello",s 和 p 指向同一个地址)，他们其实是一个相同的实例，字符串对象在内存中的共享答案 BC

编辑于 2015-09-06 17:19:07

* * *

[波儿胖](https://www.nowcoder.com/profile/124777)

BC 吧 单例和享元 降低资源使用率 应该是强调代码的复用 A 是原型模式，每个类都要有一个克隆方法 D 抽象工厂就是换了个地方

发表于 2015-09-06 11:04:03

* * *

[半纸流年](https://www.nowcoder.com/profile/710504)

singleton 单例模式，简单说就是只有自己，为自己设计。降低了重复使用。降低资源使用率
flyweight 设计中的享元模式，避免大量拥有相同内容的小类的开销，因为他让大家共享一个类。

发表于 2015-10-11 22:23:24

* * *

## 8

testArray 是一个包含 8 个元素的 int 类型数组，请问表达式：

```cpp
sizeof(testArray) / sizeof(testArray[0]);
```

的值是 _____.

正确答案: D   你的答案: 空 (错误)

```cpp
1
```

```cpp
2
```

```cpp
4
```

```cpp
8
```

本题知识点

C++ C 语言

讨论

[牛客职导官方账号](https://www.nowcoder.com/profile/897353)

【正确答案】D
【解析】对数  查看全部)

编辑于 2021-11-17 15:55:12

* * *

[huygft](https://www.nowcoder.com/profile/3417764)

数组做 sizeof 的参数不退化，如果 testArray 没有退化为指针（做函数参数）就是 D 了。

发表于 2017-11-15 23:30:08

* * *

[TOAOT](https://www.nowcoder.com/profile/666375)

sizeof(testArray) 是数组大小 8*4  =32;sizeof(testArray[0]) 是 testArray[0]的大小 4；所以 sizeof(testArray)/sizeof(testArray[0]) = 8

发表于 2015-09-06 10:58:28

* * *

## 9

n 个顶点,m 条边的全连通图，至少去掉 ____ 边才能构成一棵树？

正确答案: C   你的答案: 空 (错误)

```cpp
n-1
```

```cpp
m-1
```

```cpp
m-n+1
```

```cpp
m-n-1
```

本题知识点

树

讨论

[Radar](https://www.nowcoder.com/profile/312842)

n 个顶点的  查看全部)

编辑于 2015-12-22 10:32:42

* * *

[一凡](https://www.nowcoder.com/profile/892256)

这种题目可以直接试：n=3,m=3,需要去掉 1 条边就可以了，代入测试。

发表于 2015-09-06 18:25:51

* * *

[xiaoxi0811](https://www.nowcoder.com/profile/826828)

构成一棵树的最多边数为 n-1，有 m 条边，则至少需要去掉 m-（n-1）条边

发表于 2015-09-06 10:02:35

* * *

## 10

在序列 [22, 34, 55, 77, 89, 93, 99, 102, 120, 140] 中，采用二分查找，分别查找 77,34,99，所需的查找次数分别为()

正确答案: D   你的答案: 空 (错误)

```cpp
3,3,3
```

```cpp
3,3,4
```

```cpp
3,4,3
```

```cpp
4,2,4
```

本题知识点

查找 *讨论

[tianyunzqs](https://www.nowcoder.com/profile/953004)

22 34 55 77 89 93 99 102 120 1400   1    2   3  4    5   6     7    8     9 假设低下标用 low 表示，高下标用 high 表示。查找 77：开始 low = 0, high = 9 第一次查找，找到中心的下标为(0+9)/2 = 4，即 89，由于 89 大于 77，所以，调整 low = 0，high = 3（**注意：由于知道下标为 4 的元素比 77 大，所以不会让 high 等于 4**）第二次查找，找到中心的下标为(0+3)/2 = 1，即 34，由于 34 小于 77，所以，调整 low = 2，high = 3 第三次查找，找到中心的下标为(2+3)/2 = 2，即 55，由于 55 小于 77，所以，调整 low = 3，high = 3 第四次查找，找到中心的下标为(3+3)/2 = 3，即 77，找到所要找的元素查找 34 和 99 的过程类似。。。

发表于 2015-09-06 16:32:36

* * *

[timma](https://www.nowcoder.com/profile/749718)

我理解是这样的：首先，可以根据序列建立一颗二叉搜索树，start = 0 , end = n-1，mid = (start+end)/2，mid 为 root，然后比 mid 小的 end = mid-1，比 mid 大的 start = mid+1，建好之后可以查找 77，34，99。只需比较和节点的比较次数就可以。但是我的结果好像是 4，2，4，为 D。

发表于 2015-09-06 10:31:40

* * *

[渺淼](https://www.nowcoder.com/profile/9678560)

| start | end | mid | Value(mid) | find |
| 0 | 9 | (0+9)/2=4 | 89 | **77** |
| 0 | 3 | (0+3)/2=1 | 34 |  |
| 2 | 3 | (2+3)/2=2 | 55 |  |
| 3 | 3 | (3+3)/2=3 | **77** |  |
|  |  |  |  |  |
| 0 | 9 | 4 | 89 | **34** |
| 0 | 3 | 1 | **34** |  |
|  |  |  |  |  |
| 0 | 9 | 4 | 89 | **99** |
| 5 | 9 | 7 | 102 |  |
| 5 | 6 | 5 | 93 |  |
| 6 | 6 | 6 | **99** |  |

发表于 2016-09-30 11:05:15

* * *

## 11

ip 地址 10.1.8.0/24 和 10.1.9.0/24，下列哪个是正确的汇总网段：

正确答案: C   你的答案: 空 (错误)

```cpp
10.0.0.0/8
```

```cpp
10.1.0.0/16
```

```cpp
10.1.8.0/23
```

```cpp
10.1.10.0/24
```

本题知识点

网络基础

讨论

[lxqwh](https://www.nowcoder.com/profile/516013)

从第一位不同的开始往后全为 0；后面位相同的前缀位的位数 10.1.8.0/24 == 10.1\.  0000 100 *0* .0/2410.1.9.0/24 == 10.1\.  0000 100 *1* .0/24 从不同的位开始，替换为 0，得                        10.1.  0000 100 *0*  .0 = 10.1.8.0 子网掩码为       8+8           +7          =23 位所以汇总网段为 10.1.8.0/23

发表于 2015-09-06 16:21:05

* * *

[NKTest](https://www.nowcoder.com/profile/164061)

10.1.8.0/24=====>10.1.00001000.0/2410.1.9.0/24=====>10.1.00001001.0/24 从数字开始不同的那个位置开始即 10.1.0000100|0.0/23 也就是 10.1.8.0/23 是网关地址

发表于 2015-09-06 11:08:51

* * *

[超越梦想](https://www.nowcoder.com/profile/463367)

10.1.8.0/24   前 24 位不变，表示的范围是 10.1.8.0~10.1.8.255     10.1.9.0/24 的范围表示 10.1.9.0~10.1.9.255，那么汇总应该是 10.1.8.0/23，即前 23 位不变，因为 8 是 1000，9 是 1001，所以减掉一位，也就是 8+8+7=23

发表于 2015-09-06 11:09:05

* * *

## 12

以下代码是否完全正确，执行可能得到的结果是 ____。

```cpp
class A{
   int i;
};
class B{
   A *p;
public:
   B(){p=new A;}
   ~B(){delete p;}
};
void sayHello(B b){
}
int main(){
   B b;
   sayHello(b);
}
```

正确答案: C   你的答案: 空 (错误)

```cpp
程序正常运行
```

```cpp
程序编译错误
```

```cpp
程序崩溃
```

```cpp
程序死循环
```

本题知识点

C++

讨论

[二货磁铁](https://www.nowcoder.com/profile/800454)

为了清晰可见，我们从新把题目  查看全部)

编辑于 2015-12-12 12:11:21

* * *

[Acjx](https://www.nowcoder.com/profile/509523)

默认的拷贝构造函数是浅拷贝，直接把指针的值复制了一份。调用 sayHello，离开作用域，调用析构函数 delete 了一次。main 函数中，又 delete 了一次。因此程序崩溃。

发表于 2015-09-06 10:27:39

* * *

[枫丹白露](https://www.nowcoder.com/profile/671906)

再 VS 中运行了一遍，没有出错，没有任何输出。。。

发表于 2015-09-06 10:31:48

* * *

## 13

在 C++面向对象编程语言中，以下阐述不正确的是：

正确答案: A D   你的答案: 空 (错误)

```cpp
接口中可以用虚方法
```

```cpp
一个类可以实现多个接口
```

```cpp
接口不能被实例化
```

```cpp
接口中可以包含已经实现的方法
```

本题知识点

C++

讨论

[红魔新 7 号](https://www.nowcoder.com/profile/325269)

这道题正确答案 AD，首先所谓的接口是指只包含纯虚函数的抽象类，和普通的抽象类含不一样。所以 A 不对，必须是纯虚函数。然后 B 是正确的没有问题。然后是 C，刚才说接口是特殊的抽象类，抽象类的唯一左右就是创建派生类，不能定义抽象类的对象，所以 C 是正确的。对于 D，接口即只包含纯虚函数的抽象类，所以 D 是不对的。

编辑于 2015-09-06 17:19:47

* * *

[周星星 _](https://www.nowcoder.com/profile/537870)

这题有点问题。c++没有接口的概念，用抽象类来表示接口，抽象类可以包含实现的虚方法接口：  接口是一个概念。它在 C++中用抽象类来实现**抽象类和接口的区别：**6、抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的。【虚方法当然可以是实现了的】所以这题不是很严谨编程角度，接口只是包含纯虚函数的抽象类，并不是说只能包含纯虚函数。AD 是没问题的。但是如果约定好只包含纯虚函数，那 D 就错了，A 还有待商榷参考： http://blog.csdn.net/hackbuteer1/article/details/7558946

发表于 2016-06-27 15:27:25

* * *

[大理工 Lemon](https://www.nowcoder.com/profile/443362)

这题应该只有 D 是错误的选项，接口类中只能包含纯虚函数不能存在实现方法，而且一个类继承接口类时必须覆盖所有纯虚函数

发表于 2015-09-06 10:44:27

* * *

## 14

下面关于 HTTP 协议的说法正确的是：

正确答案: A C   你的答案: 空 (错误)

```cpp
HTTP 是基于 TCP 协议之上的应用层协议
```

```cpp
HTTP 是一个普通用在浏览器和 web 服务器之间进行数据交换的流式二进制协议
```

```cpp
HTTP 协议的 ETAG 响应头主要用于信息的过期验证
```

```cpp
HTTP1.0 中的 cache-control 响应头主要用于控制信息在浏览器的缓存
```

本题知识点

网络基础

讨论

[yufangsnow](https://www.nowcoder.com/profile/567857)

  查看全部)

编辑于 2015-09-06 12:48:29

* * *

[Radar](https://www.nowcoder.com/profile/312842)

[`blog.csdn.net/haussuden/article/details/5967996`](http://blog.csdn.net/haussuden/article/details/5967996) [`www.blogjava.net/zjusuyong/articles/304788.html`](http://www.blogjava.net/zjusuyong/articles/304788.html)

编辑于 2015-09-06 10:40:50

* * *

[゛ζ、冰眸ゝ](https://www.nowcoder.com/profile/939321)

请求头里的 Cache-Control 是 no-***，是浏览器通知服务器：本地没有缓存数据
若响应头中的 Cache-Control:max-age=259200 则 是通知浏览器：259200 秒之内别来烦我，自己从缓冲区中刷新

发表于 2016-04-18 16:14:06

* * *

## 15

关于多线程和多进程编程，下面描述正确的是（）：

正确答案: A C D   你的答案: 空 (错误)

```cpp
多进程里，子进程可获得父进程的所有堆和栈的数据；而线程会与同进程的其他线程共享数据，拥有自己的栈空间
```

```cpp
线程因为有自己的独立栈空间且共享数据，所有执行的开销相对较大，同时不利于资源管理和保护
```

```cpp
线程的通信速度更快，切换更快，因为他们在同一地址空间内
```

```cpp
线程使用公共变量/内存时需要使用同步机制，因为他们在同一地址空间内
```

```cpp
因多线程里，每个子进程有自己的地址空间，因此相互之间通信时，线程不如进程灵活和方便
```

本题知识点

操作系统

讨论

[Radar](https://www.nowcoder.com/profile/312842)

**线程和进程的区别联系：**  查看全部)

编辑于 2015-11-24 10:18:35

* * *

[zhisheng_blog](https://www.nowcoder.com/profile/616717)

楼上他们讲的不错的

发表于 2016-01-09 10:03:20

* * *

[鹏秋](https://www.nowcoder.com/profile/876726649)

不同进程的线程并不共享数据吧，而且地址也不一样。C 不完全正确啊

发表于 2019-12-20 10:37:35

* * ***