# 网易 2017 春招笔试真题编程题集合

## 1

一种双核 CPU 的两个核能够同时的处理任务，现在有 n 个已知数据量的任务需要交给 CPU 处理，假设已知 CPU 的每个核 1 秒可以处理 1kb，每个核同时只能处理一项任务。n 个任务可以按照任意顺序放入 CPU 进行处理，现在需要设计一个方案让 CPU 处理完这批任务所需的时间最少，求这个最小的时间。

本题知识点

动态规划

讨论

[一个小菜鸡](https://www.nowcoder.com/profile/1903847)

思想理解：完成所有 n 个任务需要 sum 时间，放入两个 cpu 中执行，假设第一个 cpu 处理时间为 n1，第二个 cpu 时间为 sum-n1，并假设 n1 <= sum/2，sum-n1 >= sum/2，要使处理时间最小，则 n1 越来越靠近 sum/2，最终目标是求 max（n1，sum-n1）的最大值。转换为 01 背包问题：已知最大容纳时间为 sum/2，有 n 个任务，每个任务有其的完成时间，求最大完成时间。

```cpp
public class Main {
    public static int getMax(int[] packTime, int n, int maxTime){
        //bestTime[i][j]表示最大时间下的完成第 i 个任务所需的时间 int[][] bestTime = new int[n+1][maxTime+1];for(int j = 0; j <= maxTime; j++ ){
            //能容纳最大时间为 j
            for(int i = 0; i <= n; i++){
                //当完成 0 个任务或者最大时间为 0 时，时间为 0
                if(i == 0 || j == 0) {
                    bestTime[i][j] = 0;
                }
                //当容纳最大时间小于单独完成第 i 件任务时间，则为前 n-1 完成任务时间总和
                else if(j < packTime[i-1]){
                    bestTime[i][j] = bestTime[i-1][j];
                }
                //完成第 i 件任务时，两种情况：取最大值
                //1.超过容纳最大时间，则为 bestTime[i-1][j];
                //2.没超过，则为 bestTime[i-1][j-packTime[i-1]]+packTime[i-1])
                //上述表示为在完成第 i 件任务时所需时间为 bestTime[i-1][j-packTime[i-1]]，然后在加上第 i 个任务时间为 packTime[i-1]
                else{bestTime[i][j] = Math.max(bestTime[i-1][j], bestTime[i-1][j-packTime[i-1]]+packTime[i-1]);}
            }
        }
        return bestTime[n][maxTime];
    }

    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] packTime = new int[n];
        int sum = 0;
        for(int i = 0; i < n; i++){
            packTime[i] = sc.nextInt()/1024;
            sum += packTime[i];
        }
        int half = sum/2;
        int res = getMax(packTime, n, half);
        System.out.println(Math.max(res, sum-res)*1024);
    }
}
```

发表于 2017-03-30 09:58:00

* * *

[詆調壹點](https://www.nowcoder.com/profile/7417896)

```cpp
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			int n = sc.nextInt();
			int[] arr = new int[n];
			int sum = 0;
			for (int i = 0; i < arr.length; i ++) {
				arr[i] = sc.nextInt() >> 10;
				sum += arr[i];
			}
			// dp[j]表示在容量为 j 的情况下可存放的重量
			// 如果不放 arr[i]重量为 dp[j],如果放 arr[i]重量为 dp[j-arr[i]]+arr[i];
			int[] dp = new int[sum / 2 + 1];
			for (int i = 0; i < n; i ++) {
				for (int j = sum / 2; j >= arr[i]; j --) {
					dp[j] = Math.max(dp[j], dp[j - arr[i]] + arr[i]);
				}
			}
			System.out.println(Math.max(dp[sum / 2], sum - dp[sum / 2]) << 10);
		}
	}
}

```

编辑于 2017-04-10 14:08:37

* * *

[Glenn_Gould](https://www.nowcoder.com/profile/8008945)

```cpp
# include <iostream>
# include <vector>
using namespace std;
const int mul=1024;
int main()
{
    int n=0,total_len=0;
    cin>>n;
    vector<int> vi(n,0);
    for(int i=0;i<n;i++) {
       cin>>vi[i];
       vi[i]/=mul;
       total_len+=vi[i];
    }
    int dp_len=total_len/2;
    vector<int> dp(dp_len+1,0);
    for(int i=0;i<n;i++) {
        for(int j=dp_len;j>=vi[i];j--) {
            dp[j]=max(dp[j],dp[j-vi[i]]+vi[i]);
        }
    }
    int ret=(total_len-dp[dp_len])*mul;
    cout<<ret;
    return 0;
}
```

发表于 2017-08-02 14:57:20

* * *

## 2

终于到周末啦！小易走在市区的街道上准备找朋友聚会，突然服务器发来警报,小易需要立即回公司修复这个紧急 bug。假设市区是一个无限大的区域，每条街道假设坐标是(X，Y)，小易当前在(0，0)街道，办公室在(gx,gy)街道上。小易周围有多个出租车打车点，小易赶去办公室有两种选择，一种就是走路去公司，另外一种就是走到一个出租车打车点，然后从打车点的位置坐出租车去公司。每次移动到相邻的街道(横向或者纵向)走路将会花费 walkTime 时间，打车将花费 taxiTime 时间。小易需要尽快赶到公司去，现在小易想知道他最快需要花费多少时间去公司。

本题知识点

贪心 数学 图

讨论

[JacobGo！](https://www.nowcoder.com/profile/6196880)

第一眼看到题目以为是图的题。。。原来这么简单

```cpp
package go.jacob.day913;

import java.util.Scanner;

public class Demo1 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] X = new int[n];
		int[] Y = new int[n];
		for (int i = 0; i < n; i++) {
			X[i] = sc.nextInt();
		}
		for (int i = 0; i < n; i++) {
			Y[i] = sc.nextInt();
		}
		int gx = sc.nextInt(), gy = sc.nextInt();
		int walkTime = sc.nextInt(), taxiTime = sc.nextInt();

		int min = walkTime * (Math.abs(gx) + Math.abs(gy));
		for (int i = 0; i < n; i++) {
			int tmp = walkTime * (Math.abs(X[i]) + Math.abs(Y[i]))
					+ taxiTime * (Math.abs(gx - X[i]) + Math.abs(gy - Y[i]));
			if (tmp < min)
				min = tmp;
		}
		System.out.println(min);
		sc.close();
	}
}  
```

发表于 2017-09-13 09:58:44

* * *

[无名 huster](https://www.nowcoder.com/profile/7450384)

```cpp
import java.util.*;
//该题目比较简单，针对两种不同的方式计算即可
//1\. 完全走步
//2\. 先走到停车点，之后坐车到达
public class Main{

    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
    	//获得出租车打车点
    	int Tcount = scanner.nextInt();
    	int [] txArray = new int[Tcount];
    	int [] tyArray = new int[Tcount];
    	//初始化出租车打车点的 x 坐标
    	for(int i = 0;i < Tcount;i++){
        	txArray[i] = scanner.nextInt();
    	}
    	//初始化出租车打车点的 Y 坐标
    	for(int j  = 0;j < Tcount;j++){
        tyArray[j] = scanner.nextInt();
    	}
    	//得到目的地地址
    	int gx = scanner.nextInt();
    	int gy = scanner.nextInt();
    	//得到走路时间和打车时间
    	int walkTime  = scanner.nextInt();
    	int taxiTime  = scanner.nextInt();

    	//完全走路所需要的时间
    	int totalByWalk = (Math.abs(gx)+ Math.abs(gy)) * walkTime;
    	//保存打车所费时间的最小值
    	int totalByTaxi = Integer.MAX_VALUE;
    	//对于打车
    	for(int k = 0;k < Tcount;k++){
        	//走到停车点的时间
        	int firstTime = (Math.abs(txArray[k])+Math.abs(tyArray[k])) * walkTime;
        	//坐车到目的地时间
        	int secondTime = (Math.abs(txArray[k]- gx) + Math.abs(tyArray[k]- gy)) * taxiTime;

        	totalByTaxi = Math.min(totalByTaxi,firstTime + secondTime);
    	}
    	System.out.println(Math.min(totalByWalk,totalByTaxi));
    }
}
```

发表于 2017-08-10 10:31:52

* * *

[渣渣~~](https://www.nowcoder.com/profile/639456)

```cpp
import java.util.*;
public class Main {
	public static void main(String args[]) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int tx[] = new int[n];
		int ty[] = new int[n];
		for (int i = 0; i < n; i++) {
			tx[i] = sc.nextInt();//打车点 x 坐标
		}
		for (int i = 0; i < n; i++) {
			ty[i] = sc.nextInt();//打车点 y 坐标
		}
		int gx = sc.nextInt();//公司 x 坐标
		int gy = sc.nextInt();//公司 y 坐标

		int wt = sc.nextInt();// 走路速度
		int dt = sc.nextInt();// 打车速度

		int walkTime = (Math.abs(gx) + Math.abs(gy)) * wt;// 如果全部走路
		int driveTime = Integer.MAX_VALUE;
		for (int i = 0; i < n; i++) {// 如果打车
			driveTime = Math.min(driveTime,
					(Math.abs(ty[i]) + Math.abs(tx[i])) * wt + (Math.abs(ty[i]-gy)+Math.abs(tx[i]-gx)) * dt);
		}
		System.out.println(Math.min(driveTime, walkTime));
	}
}
```

发表于 2017-04-04 23:00:06

* * *

## 3

在幼儿园有 n 个小朋友排列为一个队伍，从左到右一个挨着一个编号为(0~n-1)。其中有一些是男生，有一些是女生，男生用'B'表示，女生用'G'表示。小朋友们都很顽皮，当一个男生挨着的是女生的时候就会发生矛盾。作为幼儿园的老师，你需要让男生挨着女生或者女生挨着男生的情况最少。你只能在原队形上进行调整，每次调整只能让相邻的两个小朋友交换位置，现在需要尽快完成队伍调整，你需要计算出最少需要调整多少次可以让上述情况最少。例如：
GGBBG -> GGBGB -> GGGBB
这样就使之前的两处男女相邻变为一处相邻，需要调整队形 2 次

本题知识点

贪心

讨论

[于晨晨](https://www.nowcoder.com/profile/430692)

最终目标是将男孩移到最左边，或者将女孩移到最左边。

如果有 B 个男孩，则移到最左边的 index 分别为：0,1,2...B-1,所以所有 index 的和为（B-1）*B/2

一次遍历，计算目前男孩所在的 index 的和为 sumB，则 sumB 减去上面的和就是所求的结果。

因此只要一次遍历，计算男孩所在的男孩的个数和男孩所在的 index 的和，求之差就行了。女孩同理。最后求最小值。

```cpp
#include <string>
#include <iostream>
using namespace std;
int main(){
    string S;
    cin>>S;
    int B=0;
    int G=0;
    int sumB=0;
    int sumG=0;
    for(int i=0;i<S.size();i++){
        if(S[i]=='G'){
            G++;
            sumG+=i;
        }
        else{
            B++;
            sumB+=i;
        }
    }
    int ret1=sumB-B*(B-1)/2;
    int ret2=sumG-G*(G-1)/2;
    int ret=ret1<ret2?ret1:ret2;
    cout<<ret;
    return 0;
} 
```

发表于 2017-03-26 20:48:35

* * *

[南邮陈丹伟](https://www.nowcoder.com/profile/543248)

```cpp

	import java.util.Scanner;

	public  class shs {

	  public static void main(String[] args) {

	  // TODO Auto-generated method stub

	  Scanner scan = new Scanner(System.in);

	  String s = scan.nextLine();

	  int b=0;

	  int g=0;

	  int bsum = 0;

	  int gsum = 0;

	  for(int i=0;i<s.length();i++){

	  if(s.charAt(i) == 'G'){

	  gsum+=(i-g);

	  g++;

	  }else if(s.charAt(i) == 'B'){

	  bsum+=(i-b);

	  b++;

	  }

	  }

	  System.out.println(Math.min(bsum, gsum));

	  }

	}

```

发表于 2017-03-27 15:29:52

* * *

[SamChen](https://www.nowcoder.com/profile/9551378)

```cpp
#include<iostream>
#include<cmath>
#include<set>
#include<map>
#include<vector>
#include<list>
#include<queue>
#include<algorithm>

using namespace std;

int main()
{
    vector<char> line;
    int minMoveLeft = 0, leftG = 0;
    int minMoveRight = 0, rightG = 0;
    int minMove = 0;
    char temp = ' ', rightTemp = ' ';
    temp = getchar();
    while (temp == 'G' || temp == 'B')
    {
        line.push_back(temp);
        temp = getchar();
    }
    for (size_t i = 0; i < line.size(); i++)
    {
        temp = line[i];
        rightTemp = line[line.size()-1-i];
        if (temp == 'G')
            leftG++;
        else if(temp == 'B')
            minMoveLeft += leftG;
        if (rightTemp == 'G')
            rightG++;
        else if (rightTemp == 'B')
            minMoveRight += rightG;
    }
    minMove = min(minMoveLeft, minMoveRight);
    cout << minMove << endl;
    return 0;
}
O(n)时间复杂度的方法。调整的目标是将所有女孩放到队列前方或者队列后方，男孩和女孩之间只有一处挨着的地方，
男孩和男孩之间，女孩和女孩之间不用排序。思路是计算把女孩都放在队列前部和都放在队列后部分别所需要交换次数
两者的最小值即为所求的答案。

观察一个随机的队列中，考虑把 G 放在队列前方所需要的移动次数：如 BGB 当一个 G 前有一个 B，可以把 G 前面的 B 移动一次，成 GBB。
BGGB 需要移动两次，而 BBGGB，需要移动 4 次，虽然不是最优解（G 前有两个 B，一共有 2G），记下这种方法所需要的最少移动次数。

再来考虑把 G 放在队列后方所需要的移动次数：还是 BBGGB，只需要 2 次移动（G 后面有一个 B，一共两个 G），
记下这种方法所需要的最少移动次数。

将两者的结果取最小值。

```

发表于 2017-04-01 10:27:40

* * *

## 4

小易有一个长度为 n 序列，小易想移除掉里面的重复元素，但是小易想是对于每种元素保留最后出现的那个。小易遇到了困难,希望你来帮助他。

本题知识点

模拟 字符串 *讨论

[dragonhaw](https://www.nowcoder.com/profile/5989999)

```cpp
import java.util.*;
/**
 * 此题巧妙地用到了 List 去重的方法。
 * 比如说有一组数，为 1 5 5 1 6 1
 * 从[0,n-1]使用 List 去重之后，保存地其实就是每种元素最开始出现的那个元素。
 * 但是我们换个角度去想，如果我们从后向前遍历，保存地就是每种元素最后出现的那个元素，只不过相对从前到后来说，数倒过来了。
 * 我们最终将数反转过来即可。
 * 时间复杂度为 O(n)
 * @author 何嘉龙
 *
 */
public class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		while(in.hasNext()) {
			int n = in.nextInt();
			int[] arr = new int[n];
			List<Integer> lists = new ArrayList<>();
			for(int i = 0; i < n; i++) {
				arr[i] = in.nextInt();
			}
			for(int i = n - 1; i >= 0; --i) {
				if(!lists.contains(arr[i])) {
					lists.add(arr[i]);
				}
			}
			for(int i = lists.size() - 1; i >= 0; --i) {
				System.out.print(lists.get(i));
				if(i != 0) {
					System.out.print(" ");
				}
			}
		}
		in.close();
	}
}
```

发表于 2017-04-15 20:27:55

* * *

[hannah_aimee](https://www.nowcoder.com/profile/8721757)

```cpp
#include<iostream>
using namespace std;

int main ()
{
	int n;
	cin>>n;
	int seq[50];
	for(int i=0;i<n;i++)
	{
		cin>>seq[i];
	}

	for(int i=n-1;i>=0;i--)
	{
		int b=seq[i];
		for(int j=i-1;j>=0;j--)
		{
			if(b-seq[j]==0)
			{
				seq[j]=0;
			}

		}
	}
	for(int i=0;i<n;i++)
	{   if(seq[i]!=0)
		{
		cout<<seq[i];
        	if(i<(n-1))
                cout<<' ';
		}

	}
}
```

发表于 2017-03-27 16:14:35

* * *

[JacobGo！](https://www.nowcoder.com/profile/6196880)

用 ArrayList 做的，contains 方法需要用掉 O（n）的时间建议用 HashSet 判重把，用空间换时间

```cpp
package go.jacob.day913;

import java.util.ArrayList;
import java.util.Scanner;

public class Demo3 {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		int[] arr=new int[n];
		for(int i=0;i<n;i++){
			arr[i]=sc.nextInt();
		}
		ArrayList<Integer> res=new ArrayList<Integer>();
		for(int i=arr.length-1;i>=0;i--){
			if(!res.contains(arr[i]))
				res.add(arr[i]);
		}
		System.out.print(res.get(res.size()-1));
		for(int i=res.size()-2;i>=0;i--){
			System.out.print(" "+res.get(i));
		}
		sc.close();
	}
}  
```

发表于 2017-09-13 10:25:39

* * *

## 5

小易拥有一个拥有魔力的手环上面有 n 个数字(构成一个环),当这个魔力手环每次使用魔力的时候就会发生一种奇特的变化：每个数字会变成自己跟后面一个数字的和(最后一个数字的后面一个数字是第一个),一旦某个位置的数字大于等于 100 就马上对 100 取模(比如某个位置变为 103,就会自动变为 3).现在给出这个魔力手环的构成，请你计算出使用 k 次魔力之后魔力手环的状态。

本题知识点

动态规划

讨论

[minnnng](https://www.nowcoder.com/profile/9833592)

如输入 A = [[1, 2, 3]], k = 2。我们可以构造一个这样的矩阵 B（代码中的 mul 矩阵）[[1, 0, 1], [1, 1, 0], [0, 1, 1]]，使得 A*B^k 相当于 A 转换 k 次后的样子。于是原问题就变成求矩阵快速幂。快速幂取余中，a ^k ^(% c =  (a % c)^k % c。)类似问题：O(log(n))复杂度的 Fibonacci 数列， http://blog.csdn.net/dadoneo/article/details/6776272

```cpp
#include <bits/stdc++.h>
using namespace std;

class Matrix {
public:
    int n, m;
    vector<vector<int>> mat;
    Matrix(vector<int>& vec) {
        n = 1;
        m = vec.size();
        mat.emplace_back(vec);
    }

    Matrix(int n, int m) : n(n), m(m) {
        mat.resize(n, vector<int>(m, 0));
    }

    Matrix(int n = 0) : n(n), m(n) {
        //构造矩阵 B
        mat.resize(n, vector<int>(m, 0));
        for (int i = 0; i < n; ++i) {
            mat[i][i] = 1;
            if (i + 1 < n)
                mat[i+1][i] = 1;
            else
                mat[0][i] = 1;
        }
    }

    Matrix& operator * (Matrix& b) {
        Matrix temp(this->n, b.m);
        if (this->m == b.n) {
            for (int i = 0; i < temp.n; ++i) {
                for (int j = 0; j < temp.m; ++j) {
                    for (int k = 0; k < m; ++k) {
                        temp.mat[i][j] += this->mat[i][k] * b.mat[k][j];
                    }
                }
            }
        }
        *this = temp;
        return *this;
    }

    Matrix& operator % (int k) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                this->mat[i][j] %= k;
            }
        }
        return *this;
    }

    void display() {
        for (int i = 0; i < n - 1; ++i) {
            for (int j = 0; j < m - 1; ++j) {
                cout << mat[i][j] << " ";
            }
            cout << mat[i][m-1] << endl;
        }
        for (int i = 0; i < m - 1; ++i) {
            cout << mat[n-1][i] << " ";
        }
        cout << mat[n-1][m-1] << endl;
    }
};

int main() {
    int n, k;
    while (cin >> n >> k) {
        vector<int> vecs(n);
        for (int i = 0; i < n; ++i) {
            cin >> vecs[i];
        }
        Matrix ans(vecs);
        Matrix mul(n);
        while (k != 0) {
            //快速幂求余算法
            if (k & 1) {
                ans = ans * mul % 100;
            }
            mul = mul * mul % 100;
            k >>= 1;
        }
        ans.display();
    }
    return 0;
}
/*intput
7 192347
3 15 7 1 16 1 72
 output
88 72 62 55 11 11 21
 */
```

编辑于 2017-03-27 02:33:16

* * *

[YiBuLZ](https://www.nowcoder.com/profile/7947314)

```cpp
import java.util.Scanner;
//请见 http://blog.csdn.net/zheng548/article/details/71075163

public class Main {
    /**
     * 利用矩阵快速幂
     参考：http://www.cnblogs.com/vongang/archive/2012/04/01/2429015.html
     http://www.lai18.com/content/1108003.html?from=cancel
     */
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        //用一个二维数组存储
        int[][] arr= new int[1][n];
        for (int i = 0; i < n; i ++) {
            arr[0][i] = sc.nextInt();
        }
        //初始化单元矩阵
        int[][] mul = new int[n][n];
        for (int i = 0; i < n; i ++) {
                if (i < n - 1) {
                    mul[i][i] = 1;
                    mul[i + 1][i] = 1;
                } else {
                    mul[i][i] = 1;
                    mul[0][i] = 1;
                }
        }

        for (; k > 0; k >>= 1) {
           if ((k & 1) == 1) {
               arr = Core(arr, mul);
           }
           mul = Core(mul, mul);
        }
        int i;
        for (i = 0; i < n - 1; i ++) {
            System.out.print(arr[0][i] + " ");
        }
        System.out.println(arr[0][i]);
    }

    private static int[][] Core(int[][] a, int[][] b) {
        int rowRes = a.length;
        int columnRes = b[0].length; //TODO:
        int columnA = a[0].length; // == b.length;

        int[][] c = new int[rowRes][columnRes];
        for (int i =0; i < rowRes; i ++) {
            for (int j = 0; j < columnRes; j ++) {

                for (int k = 0; k < columnA; k ++) {
                    if (a[i][k] == 0 || b[k][j] == 0) {
                        continue;          //剪枝
                    }

                    c[i][j] += a[i][k] * b[k][j];
                }
                //100 取余运算
                if (c[i][j] >= 100) {
                    c[i][j] %= 100;
                }
            }
        }
        return c;
    }

}

```

编辑于 2017-05-01 20:52:32

* * *

[旭>_](https://www.nowcoder.com/profile/2709654)

贴一个 java 的

```cpp
import java.util.Arrays;
import java.util.Scanner;

public class Main {
	// 矩阵乘法加对 100 取余
	private static int[][] mutAndMod(int[][] a,int[][] b){
		int n1 = a.length;
		int n2 = a[0].length;
		int[][] ret = new int[n1][n2];
		for(int i=0;i<n1;i++){
			for(int j=0;j<n2;j++){
				int temp = 0;
				for(int k=0;k<n2;k++){
					temp += a[i][k] * b[k][j];
				}
				ret[i][j] = temp%100;
			}
		}
		return ret;

	}

	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()){
			int n = sc.nextInt();
			int k = sc.nextInt();
			int[][] band = new int[1][n];
			for(int i=0;i<n;i++){
				band[0][i] = sc.nextInt();
			}
			int[][] src = new int[n][n];
			for(int i=0;i<n;i++){
				if(i+1<n){
					src[i][i] = 1;
					src[i+1][i] = 1;
				}else{
					src[i][i] = 1;
					src[0][i] = 1;
				}
			}
            // 结果
			int[][] ans = new int[1][n];
			for(int i=0;i<n;i++){
				ans[0][i] = band[0][i];
			}
            /*
			for(int i=0;i<n;i++){
				System.out.println(Arrays.toString(src[i]));
			}
			*/
			while(k>0){
				if(k%2==1){
					ans = mutAndMod(ans,src);
				}
				//System.out.println(Arrays.toString(ans[0]));
				src =  mutAndMod(src,src);
				k >>=1;

			}	
            System.out.print(ans[0][0]);
            for(int i=1;i<n;i++){
                System.out.print(" " + ans[0][i]);
            }
            System.out.println();

		}
		sc.close();
	}

} 
```

发表于 2017-03-28 17:41:48

* * *

## 6

现在有 n 位工程师和 6 项工作(编号为 0 至 5)，现在给出每个人能够胜任的工作序号表(用一个字符串表示，比如：045，表示某位工程师能够胜任 0 号，4 号，5 号工作)。现在需要进行工作安排，每位工程师只能被安排到自己能够胜任的工作当中去，两位工程师不能安排到同一项工作当中去。如果两种工作安排中有一个人被安排在的工作序号不一样就被视为不同的工作安排，现在需要计算出有多少种不同工作安排计划。

本题知识点

模拟 递归

讨论

[Ken_1993](https://www.nowcoder.com/profile/5125983)

```cpp

	//利用回溯法求解.

	//题意有两个地方没说清楚：1、一个人只能做一项工程，而不能分饰两角；

	//                      2、有几个工程师，每个工程师有一个工作即满足题意，不用 6 项工作全部都要有人做。

	//前一个人选了哪项工作，直接影响后一个人的选择余地。

	//所以需要用一个 set 记录在当前这个人选择之前，前面那些人已经选了的工作，进而他只能选除 set 中已有剩下的工作。

	//当考察完最后一个人，情况数+1（递归出口），证明是满足题意的方案。下面是代码

	import java.util.HashSet;
import java.util.Scanner;

//网易：工程师与项目的匹配

public class Wangyi_WorkAndWorker {

	private static int cases = 0; 

	public static void main(String[] args)
	{
		//读取输入
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		String[] ables = new String[n];
		for(int i = 0; i < n; i++) 
			ables[i] = in.next();

		//计算
		backtracing(ables, 0, new HashSet<Integer>());

		System.out.println(cases);

		in.close();
	}

	public static void backtracing(String[] ables, int index, HashSet<Integer> set){

		if(index >= ables.length){
			cases++;
			return;
		}

		String able = ables[index];
		for(int i = 0; i < able.length(); i++){

			int work = able.charAt(i) - '0';
			if(!set.contains(work)) {
				set.add(work);
				backtracing(ables, index + 1, set);
				set.remove(work);
			}
		}
	}
}

```

发表于 2017-04-05 10:01:52

* * *

[若即若即 ing](https://www.nowcoder.com/profile/5474512)

package com.niuke.success;import java.util.ArrayList;import java.util.List;import java.util.Scanner;/** * 现在有 n 位工程师和 6 项工作(编号为 0 至 5)， * 现在给出每个人能够胜任的工作序号表(用一个字符串表示，比如：045，表示某位工程师能够胜任 0 号，4 号，5 号工作)。 * 现在需要进行工作安排，每位工程师只能被安排到自己能够胜任的工作当中去，两位工程师不能安排到同一项工作当中去。 * 如果两种工作安排中有一个人被安排在的工作序号不一样就被视为不同的工作安排， * 现在需要计算出有多少种不同工作安排计划。 * 经典的回溯法解题，具体方法和套路请见博客：http://blog.csdn.net/versencoder/article/details/52071930 * @author Dell * */public class Arrange {public static void backtracking(String[] s,int n,int start,List<List<Integer>> result,List<Integer> list){if(n<0)return;else if(n==0)result.add(new ArrayList<>(list));else{for(int i=start;i<s.length;i++){for(int j=0;j<s[i].length();j++){if(list.contains(s[i].charAt(j)-'0'))  continue; list.add(s[i].charAt(j)-'0'); backtracking(s,n-1,i+1,result,list); list.remove(list.size()-1);}}}}public static void main(String[] args) {Scanner sc=new Scanner(System.in);while(sc.hasNext()){         int n=sc.nextInt();         String[] s=new String[n];         for(int i=0;i<s.length;i++)        s[i]=sc.next();         List<List<Integer>> result=new ArrayList<>();         List<Integer> list=new ArrayList<>();         backtracking(s,n,0,result,list);         //System.out.println(result.size());         System.out.println(result);}}}

发表于 2017-04-01 14:27:27

* * *

[JacobGo！](https://www.nowcoder.com/profile/6196880)

```cpp
package go.jacob.day914;

import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/**
 * [编程题]工作安排
 * 
 * @author Jacob 
 * 利用回溯法求解
 * 
 * 需要说明的是：
 * 不必每一项工作都有人做，只要每个人都分配到工作即可
 * 
 */
public class Demo1 {
	public static int count = 0;
	public static Set<Integer> set;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		String[] strs = new String[n];
		set = new HashSet<Integer>();
		for (int i = 0; i < n; i++) {
			strs[i] = sc.next();
		}
		for (int i = 0; i < 6; i++) {
			set.add(i);
		}
		solve(strs, 0);
		System.out.println(count);
		sc.close();
	}

	private static void solve(String[] strs, int k) {
		if (k == strs.length) {
			count++;
			return;
		}

		for (char c : strs[k].toCharArray()) {
			if (set.contains(c - '0')) {
				set.remove(c - '0');
				solve(strs, k + 1);
				set.add(c - '0');
			}
		}
	}
}

```

编辑于 2017-09-14 10:19:20

* * *

## 7

小易最近在数学课上学习到了集合的概念,集合有三个特征：1.确定性 2.互异性 3.无序性.
小易的老师给了小易这样一个集合：
S = { p/q | w ≤ p ≤ x, y ≤ q ≤ z }
需要根据给定的 w，x，y，z,求出集合中一共有多少个元素。小易才学习了集合还解决不了这个复杂的问题,需要你来帮助他。

本题知识点

模拟

讨论

[JacobGo！](https://www.nowcoder.com/profile/6196880)

```cpp
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/**
 * [编程题] 集合
 * @author Administrator
 * 用 HashSet 求解
 */
public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		double w=sc.nextInt(),x=sc.nextInt(),y=sc.nextInt(),z=sc.nextInt();
		Set<Double> set=new HashSet<Double>();
		for(double i=w;i<=x;i++){
			for(double j=y;j<=z;j++){
				if(!set.contains(i/j))
					set.add(i/j);
			}
		}
		System.out.println(set.size());
		sc.close();
	}
}

```

发表于 2017-09-14 10:30:08

* * *

[改个名字解解毒...](https://www.nowcoder.com/profile/866538)

```cpp
#!/usr/bin/env python
#-*- coding:utf8 -*-
def getNum(w, x, y, z):
    l = []
    if y == z:
        return x-w+1
    for i in range(w, x+1):
        for j in range(y, z+1):
            n = float(i)/j
            l.append(n)
    return len(list(set(l)))

if __name__ == '__main__':
    w, x, y, z = map(int , raw_input().split())
    print getNum(w, x, y, z)

```

发表于 2017-05-08 20:17:15

* * *

[wanlanwalan](https://www.nowcoder.com/profile/7952866)

思路分析

题意就是给分数判重，显然我们不能直接算，因为浮点数是不精确的，乘以 1.0000 就可以了，然后丢进 set 里就好了。

```cpp
#include<iostream>
#include<set>
using namespace std;
int getSetNum(int w, int x, int y, int z)
{
    int count = 0;
    set<double> s;
    for (int i = w; i <= x; i++)
        for (int j = y; j <= z; j++)
        {
            s.insert(i*1.0000 / j);
        }
    count = s.size();
    return count;
}
int main()
{
    int w, x, y, z;
    cin >> w >> x >> y >> z;
    int ans;
    ans = getSetNum(w, x, y, z);
    cout << ans << endl;
    return 0;
}
```

发表于 2017-04-11 09:05:59

* * *

## 8

常规的表达式求值，我们都会根据计算的优先级来计算。比如*/的优先级就高于+-。但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法，意味着表达式中没有/，只有(+, - 和 *)。现在给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少

本题知识点

模拟 字符串 *数学* *讨论

[lensh](https://www.nowcoder.com/profile/4183914)

纯 C 写，感觉自己棒棒哒~~~~

```cpp
#include <stdio.h>
#include <string.h> 
#define N 50
int main(){
	char str[N];
	gets(str);
	int result=str[0]-'0'; //得到第 0 个字符，并减去字符'0'使其转换成数字 
	int i,temp;
	for(i=1;i<strlen(str)-1;i+=2){  //从第二个字符开始算 
		temp=str[i+1]-'0'; //要操作的数 
		if(str[i]=='+'){
			result+=temp;  //结果 
		}else if(str[i]=='-'){
			result-=temp;
		}else if(str[i]=='*'){
			result*=temp;
		}
	}
	printf("%d\n",result);
	return 0;
}

```

编辑于 2017-03-29 23:49:09

* * *

[JacobGo！](https://www.nowcoder.com/profile/6196880)

(⊙o⊙)…感觉跟流水账一样

```cpp
package go.jacob.day914;

import java.util.Scanner;

public class Demo3 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String s = sc.nextLine();
		int sum = s.toCharArray()[0] - '0';
		for (int i = 1; i < s.length() - 1; i += 2) {
			int tmp = s.toCharArray()[i + 1] - '0';
			switch (s.toCharArray()[i]) {
			case '+':
				sum += tmp;
				break;
			case '-':
				sum -= tmp;
				break;
			case '*':
				sum *= tmp;
				break;
			}
		}
		System.out.println(sum);
		sc.close();
	}
}  
```

发表于 2017-09-14 10:39:40

* * *

[zhoulintong](https://www.nowcoder.com/profile/113913621)

纯手打，自己感觉棒棒哒

```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans,n;
char a,b;
int main()
{
    cin>>a;
    ans=a-'0';
    while(1)
    {
        a=getchar();
        if(a=='\n'||a==' ') break;
        b=getchar();
        if(a=='+') ans+=(b-'0');
        if(a=='-') ans-=(b-'0');
        if(a=='*') ans*=(b-'0');
    }
    cout<<ans;
    return 0;
}
```

发表于 2020-10-07 11:30:50

* * *

## 9

小易有一块 n*n 的棋盘，棋盘的每一个格子都为黑色或者白色，小易现在要用他喜欢的红色去涂画棋盘。小易会找出棋盘中某一列中拥有相同颜色的最大的区域去涂画，帮助小易算算他会涂画多少个棋格。

本题知识点

模拟

讨论

[JacobGo！](https://www.nowcoder.com/profile/6196880)

```cpp
package go.jacob.day914;

import java.util.Scanner;

/**
 * [编程题]涂棋盘
 * @author Administrator
 * 循环的时候要注意，是求每一列连续相同颜***域
 */
public class Demo4 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		String[] strs = new String[n];
		for (int i = 0; i < n; i++) {
			strs[i] = sc.next();
		}
		int max = 0;
		for (int i = 0; i < n; i++) {
			int count = 1;
			for (int j = 1; j < n; j++) {
				if (strs[j].charAt(i) == strs[j-1].charAt(i)) {
					count++;
				} else {
					if (count > max)
						max = count;
					count = 1;
				}
			}
			if (count > max)
				max = count;
		}
		System.out.println(max);
		sc.close();

	}
}

```

发表于 2017-09-14 11:10:49

* * *

[allensimon](https://www.nowcoder.com/profile/608790)

```cpp
import java.util.Scanner;

/*
 * 这题就是求各数组相同字符子串的最大长度
 * */
public class Main {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		while (scan.hasNext()) {
			int n = scan.nextInt();
			String[] str = new String[n];
			for (int i = 0; i < n; i++) {
				str[i] = scan.next();
			}

			int count = 0;
			for (int j = 0; j < n; j++) {
				int c = 1;
				for (int i = 0; i < n - 1; i++) {
					if (str[i].charAt(j) == str[i + 1].charAt(j)) {
						c++;
						count = Math.max(c, count);
					} else {
						c = 1;
					}
				}

			}
			System.out.println(count);
		}
		scan.close();
	}
}

```

发表于 2017-04-30 13:21:54

* * *

[dragonhaw](https://www.nowcoder.com/profile/5989999)

```cpp
package drawing;
import java.util.*;
/**
 * 这个题求的是某一列中拥有相同颜色最多的区域，其实把这道题目分解开，算法模型就是求一个数组中相同元素最多的子数组长度。
 * 比如说，数组为[1, 1, 1, 2, 2, 2, 2, 3],那么最大长度就是 4。
 * 怎么求呢？
 * 建立一个辅助数组 dp，里面存放的是到这个数为止，相同元素最多的子数组的长度。
 * 那么 dp 的值为[1, 2, 3, 1, 2, 3, 4, 1]。
 * 我们只需要保存这个数组的最大值返回即可。
 * 那么这道题就是每一列为一个数组，求每一列的相同元素最多的子数组长度，然后找出最大值返回即可。
 * @author 何嘉龙
 *
 */
public class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		while (in.hasNext()) {
			int n = in.nextInt();
			char[][] area = new char[n][n];
			for (int i = 0; i < n; i++) {
				char[] chas = in.next().toCharArray();
				for (int j = 0; j < n; j++) {
					area[i][j] = chas[j];
				}
			}
			System.out.println(getMaxArea(area, n));
		}
		in.close();
	}
	public static int getMaxArea(char[][] arr, int n) {
		int maxArea = 0;
		for (int i = 0; i < n; i++) {
			int count = 1;
			int maxCount = 1;
			int[] dp = new int[n];
			dp[0] = 1;
			for (int j = 1; j < n; j++) {
				if (arr[j][i] == arr[j - 1][i]) {
					count++;
					dp[j] = count;
				} else {
					count = 1;
					dp[j] = count;
				}
				if (dp[j] > maxCount) {
					maxCount = dp[j];
				}
			}
			if (maxCount > maxArea) {
				maxArea = maxCount;
			}
		}
		return maxArea;
	}
}
```

发表于 2017-04-15 20:34:29

* * *

## 10

小易参与了一个记单词的小游戏。游戏开始系统提供了 m 个不同的单词，小易记忆一段时间之后需要在纸上写出他记住的单词。小易一共写出了 n 个他能记住的单词，如果小易写出的单词是在系统提供的，将获得这个单词长度的平方的分数。注意小易写出的单词可能重复，但是对于每个正确的单词只能计分一次。

本题知识点

模拟 字符串 *哈希* **讨论

[JacobGo！](https://www.nowcoder.com/profile/6196880)

```cpp
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		int m=sc.nextInt();
		Set<String> set=new HashSet<String>();
		for(int i=0;i<n;i++){
			set.add(sc.next());
		}
		int score=0;
		for(int i=0;i<m;i++){
			String tmp=sc.next();
			if(set.contains(tmp)){
				score+=(int)Math.pow(tmp.length(), 2);
			}
		}
		System.out.println(score);
	}
}

```

发表于 2017-09-15 09:35:18

* * *

[Follow_Heart](https://www.nowcoder.com/profile/9654125)

```cpp
/*
先将两行输入分别读入 line1,line2;
把 line2 即系统提供的单词解析出来，存入 set<string> s2;
把 line1 即用户默写的单词解析出来，看是否在 s2 中存在，若存在，则存入 set<string> s1;
由于 set 具有多个同一元素只存一个的特性，因此遍历 s1，取出元素的长度求平方再相加即可；
*/
#include<iostream>
#include<string>
#include <set>

using namespace std;
/*t10*/
int main(void)
{
	int n, m;
	set<string> s1, s2;
	cin >> n >> m;
	cin.get();
	string line1,line2;
	getline(cin,line1);
	getline(cin, line2);
	int pos1 = 0,pos2;
	for (int i = 0; i < m; ++i)
	{
		pos2=line2.find(' ', pos1);
		s2.insert(line2.substr(pos1, pos2-pos1));
		pos1 = pos2+1;
	}
	pos1 = 0;
	for (int i = 0; i < n; ++i)
	{
		pos2 = line1.find(' ', pos1);
		string temp = line1.substr(pos1, pos2 - pos1);
		if (s2.find(temp) != s2.end())
			s1.insert(temp);
		pos1 = pos2+1;
	}
	int sum = 0;
	for (set<string>::iterator it = s1.begin(); it != s1.end(); ++it)
	{
		int len = (*it).size();
		sum += len*len;
	}
	cout << sum << endl;
}
```

发表于 2017-08-11 10:32:55

* * *

[dragonhaw](https://www.nowcoder.com/profile/5989999)

```cpp
package english;

import java.util.*;
public class Main{
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		while(in.hasNext()) {
			int n = in.nextInt();
			int m = in.nextInt();
			List<String> systemWords = new ArrayList<>();
			Set<String> writeWordsSet = new HashSet<>();
			List<String> writeWordsList = new ArrayList<String>();
			for(int i = 0; i < n; i++) {
				systemWords.add(in.next());
			}
			for(int i = 0; i < m; i++) {
				String str = in.next();
				if(systemWords.contains(str)) {
					writeWordsSet.add(str);
				}
			}
			writeWordsList.addAll(writeWordsSet);
			int sum = 0;
			for(int i = 0; i < writeWordsList.size(); i++) {
				int len = writeWordsList.get(i).length();
				sum += Math.pow(len, 2);
			}
			System.out.println(sum);
		}
		in.close();
	}
}
```

发表于 2017-04-15 20:36:27

* * *

## 11

小易有 n 块砖块，每一块砖块有一个高度。小易希望利用这些砖块堆砌两座相同高度的塔。为了让问题简单，砖块堆砌就是简单的高度相加，某一块砖只能使用在一座塔中一次。小易现在让能够堆砌出来的两座塔的高度尽量高，小易能否完成呢。

本题知识点

动态规划 贪心

讨论

[☠](https://www.nowcoder.com/profile/250257)

### 分析不知道怎么搞，看到题目保证答案不大于 500000，想想这不是在提示我们“暴力搞没问题，我数据不大”么。于是我就就暴力搜索，枚举两堆塔的高度，但是需要一些剪枝：1\. 当其中一堆高度大于 500000,可以剪掉;2\. 当较低的堆+剩下的砖块<较高的堆时，可以剪掉;3\. 当当前可能达到的最大高度小于已经发现最大高度时，可以剪掉;### 我的答案```cppcpp

```
#include<iostream>
#include<algorithm>
using namespace std;
#define MAX 500000
int height[52];
int sum[52];
int n;
int ans=0;
void dfs(int n,int sum1,int sum2){
    if(sum1==sum2)
        ans=max(ans,sum1);
    if(n==0)
        return;
    if(sum1>MAX)
        return;
    if(sum1+sum[n]<sum2)
        return;
    if((sum1+sum2+sum[n])<=ans*2)
        return;
    dfs(n-1,min(sum1+height[n],sum2),max(sum1+height[n],sum2));
    dfs(n-1,min(sum2+height[n],sum1),max(sum2+height[n],sum1));
    dfs(n-1,sum1,sum2);
}
int main(){
    ios::sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>height[i];
    sort(height+1,height+n+1);
    for(int i=1;i<=n;i++)
        sum[i]=sum[i-1]+height[i];
    dfs(n,0,0);
    cout<<(ans?ans:-1)<<endl;
}
```cpp

```[`blog.mythsman.com/2017/03/31/1/#堆砖块`](https://blog.mythsman.com/2017/03/31/1/#堆砖块)

发表于 2017-03-31 13:16:37

* * *

[拼多多幸运内推](https://www.nowcoder.com/profile/2059945)

@[JacobGo！](https://www.nowcoder.com/profile/6196880)@[minnnng](https://www.nowcoder.com/profile/9833592)@[chorus](https://www.nowcoder.com/profile/5421113) 这三位的状态转移表述都是错的，虽然本题中不影响结果，但是不利于理解。

以下是正确表述

dp[j]表示 B-A+sum 为 j 时，B 堆的最大高度

所以把砖块放在 B 堆时:dp1[j]=dp0[j-h]+h

A 堆:dp1[j]=dp0[j+h]

不放：dp1[j]=dp0[j]

这才是正确状态转移，三位互相借鉴的时候就不能仔细看一遍？？

自己的代码分明是将 A-B+sum 作为 j，为何注释里要说成 B-A+sum，误人子弟。

以下是我的代码

```cpp
import java.util.Arrays; 
import java.util.Scanner; 
public class Main{ public static void main(String[] args) {
    Scanner scan=new Scanner(System.in); 
    int n=scan.nextInt(); 
    int[] heights=new int[n]; 
    int count=0; 
    for(int i=0;i;i++){
        heights[i]=scan.nextInt(); 
        count+=heights[i]; 
    } 
    int[] dp1=new int[2*count+1]; 
    int[] dp0=new int[2*count+1]; 
    for(int i=0;i2*count+1;i++){
        dp0[i]=-1; 
    }
    dp0[count]=0; 
    for(int i=1;i1;i++){ 
         int height=heights[i-1]; 
         for(int j=0;j2*count+1;j++){
             dp1[j]=dp0[j]; 
             if(j-height>=0&&dp0[j-height]!=-1){
                 dp1[j]=Math.max(dp1[j],dp0[j-height]+height); 
             }             
             if(j+height2*count&&dp0[j+height]!=-1){
                 dp1[j]=Math.max(dp1[j],dp0[j+height]); 
             }
         } 
         for(int j=0;j2*count+1;j++){
             dp0[j]=dp1[j]; 
         }
     } 
     int max=-1; 
     for(int i=1;i1;i++){
        max=Math.max(max,dp0[count]); 
     }
     System.out.println(max==0?-1:max); 
     }
} 
```

编辑于 2018-04-06 21:14:24

* * *

[minnnng](https://www.nowcoder.com/profile/9833592)

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n = 0;
    cin >> n;
    vector<int> ts(n);
    int sum = 0;
    for (int i = 0; i < n; ++i) {
        cin >> ts[i];
        sum += ts[i];
    }
    vector<vector<int>> dp(2, vector<int>(2*sum+1, -1));
    dp[0][sum] = 0;
    vector<int>* dp0 = &(dp[0]);
    vector<int>* dp1 = &(dp[1]);
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= 2*sum; ++j) {
            int h = ts[i-1];
            (*dp1)[j] = (*dp0)[j];
            if (j - h >= 0 && (*dp0)[j-h] != -1) {
                (*dp1)[j] = max((*dp1)[j], (*dp0)[j-h]);
            }
            if (j + h <= 2*sum && (*dp0)[j+h] != -1) {
                (*dp1)[j] = max((*dp1)[j], (*dp0)[j+h] + h);
            }
        }
        auto tmp = dp0;
        dp0 = dp1;
        dp1 = tmp;
    }
    if ((*dp0)[sum] == 0)
        cout << -1 << endl;
    else
        cout << (*dp0)[sum] << endl;
    return 0;
}
/*假设砖块分为 A，B 两堆，dp[i][j]中的 j 表示 B-A 的长度。
因为 B-A 有可能是负的，所以 j 整体偏移 sum 个长度，即 2*sum+1。
而 dp[i][j]的值则表示当 A-B 的值为 j 时，B 的最大长度是多少。
dp[i][j] = dp[i-1][j]表示我不用第 i 块砖
dp[i][j] = max(dp[i-1][j-h], dp[i-1][j])表示我把砖放在 A 堆。
dp[i][j] = max(dp[i-1][j+h]+h, dp[i-1][j])表示我把砖放在 B 堆。
然后会爆内存，所以用了滚动数组。*/
```

发表于 2017-03-30 22:23:48

* * *

## 12

易老师购买了一盒饼干，盒子中一共有 k 块饼干，但是数字 k 有些数位变得模糊了，看不清楚数字具体是多少了。易老师需要你帮忙把这 k 块饼干平分给 n 个小朋友，易老师保证这盒饼干能平分给 n 个小朋友。现在你需要计算出 k 有多少种可能的数值

本题知识点

动态规划

讨论

[☠](https://www.nowcoder.com/profile/250257)

### 分析显然数字太大我们不能直接计算模(超过 long long)，而且也不能枚举 X(否则空间可能有$10^{18}$)。不过我们考虑到模 n 应该不大（喂喂，怎么题目没有给 n 的范围啊～），因此可以考虑用动态规划的思想从这里入手。用$mod[k]$表示当前所有情况下模 n 余 k 的数量。如果我们把前 i 位当成一个整体$s[0:i]$，而且知道了$mod[0:n]$的值，那么对于前 i+1 位而言，$mod[k]$的值会贡献到$mod[(k*10+s[i+1])mod\\%n]$上。如果$s[i+1]$的值是 X，那么我们只要将$s[i+1]$遍历 10 次。总体上说，就是从前往后遍历，依次更新 mod 数组，最后的结果当然就是$mod[0]$了。注意 long long 。### 我的答案```cppcpp

```
#include<iostream>
#include<cstring>
using namespace std;
#define MAXN 100000
void transform1(long long mod[],int n){
    long long tmpMod[MAXN]={0};
    for(int i=0;i<n;i++){
        for(int j=0;j<10;j++){
            tmpMod[(i*10+j)%n]+=mod[i];
        }
    }
    memcpy(mod,tmpMod,sizeof tmpMod);
}
void transform2(long long mod[],int k,int n){
    long long tmpMod[MAXN]={0};
    for(int i=0;i<n;i++){
        tmpMod[(i*10+k)%n]+=mod[i];
    }
    memcpy(mod,tmpMod,sizeof tmpMod);
}
int main(){
    long long mod[MAXN]={0};
    string s;
    int n;
    cin>>s>>n;
    mod[0]=1;
    for(int i=0;i<s.length();i++){
        if(s[i]=='X'){
            transform1(mod,n);
        }else{
            transform2(mod,s[i]-'0',n);
        }
    }
    cout<<mod[0]<<endl;
}
```cpp

```[`blog.mythsman.com/2017/03/31/1/#分饼干`](https://blog.mythsman.com/2017/03/31/1/#分饼干)

编辑于 2017-03-31 13:18:07

* * *

[HelloHello233](https://www.nowcoder.com/profile/5754127)

dp：状态转移方程 dp[i][newJ] += dp[i-1][J].其中 i 代表数字串的长度，J 代表余数，结果值代表 i 长度的数字串中求余 n 余 J 的所有可能结果总数根据以上的说明，显而易见 newJ==(J*10+k)%n ，k 代表当前数字串中个位的值（也就是数字串的第 i 位）以下两段代码均经过测试可 AC，如果去除 if 条件判断，则程序运行的结果为：输入长度为 n 的字符串，则求出长度为 n 的数字串中，求余 n 余数为 0 的所有结果总数，但题意不是这么要求的，所以枚举的时候，需要进行判断，如果判断到 X 则可以枚举 0~10（也就是 k 的值可以取值为 0~10），如果不是 X，则 k 只能取值为数字串中的对应值，举个栗子：如果输入的数字串长度为 3，不加 if 判断的话，则枚举到的所有结果为：0~999 如果加了判断，如 X33X，则枚举到的结果值为 330~339,1330~1339 ... 1339~9339 符合题意在以上枚举到的结果中，进行求余判断并且记录结果，篇幅有限，不说太多细节，关键是要理解好状态转移方程

```cpp
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
    	Scanner sc = new Scanner(System.in);
    	String str = sc.next();
    	int n = sc.nextInt();
    	long[][] dp = new long[str.length()+1][]; //不用 long 的话通过率只能为 90%
    	for(int i = 0;i<=str.length();i++){
    		dp[i] = new long[n];
    	}
    	dp[0][0] = 1;
    	for(int i = 1;i<=str.length();i++){
    		char c = str.charAt(i-1);
    		for(int j = 0;j<n;j++){
    			for(int k = 0;k<10;k++){
    				if(c=='X'||c=='0'+k){
    					dp[i][(j*10+k)%n]+=dp[i-1][j];
    				}
    			}
    		}
    	}
    	System.out.println(dp[str.length()][0]); 
    }
}
//以上发现第 i 行的值只会访问到第 i-1 行的值，所以实际只需要两个数组即可，优化空间之后的代码：
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
    	Scanner sc = new Scanner(System.in);
    	String str = sc.next();
    	int n = sc.nextInt();
    	long[] dp = new long[n];     	
    	dp[0] = 1;
    	for(int i = 1;i<=str.length();i++){
    		char c = str.charAt(i-1);
    		long[] tmp = new long[n]; 
    		for(int j = 0;j<n;j++){
    			for(int k = 0;k<10;k++){
    				if(c=='X'||c=='0'+k){
    					tmp[(j*10+k)%n]+=dp[j];
    				}
    			}
    		}
    		dp = tmp;
    	}
    	System.out.println(dp[0]);
    }
}
```

发表于 2017-04-03 11:53:41

* * *

[张瑞泽](https://www.nowcoder.com/profile/9276849)

简单介绍原理：1234%7=1000%7+200%7+30%7+4%7\.1X3X%20=1000%20 + X*100%20 + 30%20 + x%20(x=0-9)代码如下：import java.util.*;

public class Main {

    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);

        while (in.hasNext()) {

            String s = in.nextLine();

            String s2 = in.nextLine();

            int n = Integer.parseInt(s2);

            long d[] = new long[n];//n children

            boolean dLoaded = false;

            long base = 1;

            long sum = 0;

            //假入给了 99X9，base 就是 10000。(暂时多了一位），用于之后对每一位数字进行求余。

            for (int j = 0; j < s.length(); j++) {

                base *= 10;

            }

        //遍历每一位数字。

            for (int i = 0; i < s.length(); i++) {

        //对 base 除以 10，为下一位求余做准备。

                base /= 10;

                if (s.charAt(i) == 'X') {

                    if (!dLoaded) {

                    //如果记录余数的数组 d 还没初始化过，就先把这次的计算作为初始化的值。

                        long[] temp = new long[n];

                        //统计余数的数组。长度为 n，下标是 0~n-1，表示 对应可以得到对应余数的个数。

                        for (int j = 0; j <= 9; j++) {

                            temp[(int) ((j * base) % n)]++;

                        }

                           //temp 数组复制到 d 数组上。这里 idea 优化成如下方法，效率更高。d 数组便初始化过了。跳过后面部分

                        System.arraycopy(temp, 0, d, 0, n);

                        dLoaded = true;

                        continue;

                    }

                    //如果初始化了 d 数组，则在新发现 X 时，需要把新的余数统计结果和原来的统计结果 d 进行汇总

                    int[] mod = new int[10];

                        //因为 x 有 10 种可能，所以最多产生 10 个余数，而如果采用 new int[n]来统计的话，n 可能远大于 10，所以效率会差很多。mod 记录了每个可能的数字所产生的余数。

                    for (int j = 0; j <= 9; j++) {

                        mod[j] = (int) ((j * base) % n);

                    }

                    //将新的统计结果 mod 和原来的统计结果 d 进行融合。原理如下：newd 的下标对应产生的余数，比如 newd[2]代表余数为 2 的所有可能性总数。于是对于 newd[m]，其可能性总数便来自于 sum{d[m-mod[k]]}（仔细想一下，mod[k]是这次产生的新余数，m 是要统计的目标余数），+n 和%n 是为了防止负数情况。

                    long[] newd = new long[n];

                    for (int m = 0; m < n; m++) {

                        for (int k = 0; k <= 9; k++) {

                            newd[m] += d[(n + m - mod[k]) % n];

                        }

                    }

                    System.arraycopy(newd, 0, d, 0, n);

                } else {

                //如果不是 x，就按最开始处讲的原理直接求余并累加进去即可。

                    long a = (s.charAt(i) - '0') * base;

                    sum = (sum + a) % n;

                }

            }

            //常数位累加后的余数是 sum，而我们要能整除的所有可能性，也就是余数为 0 的所有可能性，所以取 d 数组中的 n-sum 对应的可能性即可。为何%n?比如 n=7，sum=0，n-sum=7，d[7]显然越界。实际上此时应该去访问 d[7%7]=d[0]

            System.out.println(d[(int) ((n - sum) % n)]);

        }

    }

}

编辑于 2017-04-11 09:51:38

* * *****