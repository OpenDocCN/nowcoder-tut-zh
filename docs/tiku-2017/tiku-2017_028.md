# 三百六十、公司 2016 研发工程师笔试题（二）

## 1

绘画展览门票每张 5 元，如果有 2n 个人排队购票，每人一张，并且其中一半人恰有 5 元钱，另一半人恰有 10 元钱，而票房无零钱 可找，那么如何将这 2n 个人排成一列，顺次购票，使得不至于因票房无零钱可找而耽误时间，应该采用什么算法解决呢？（）

正确答案: B   你的答案: 空 (错误)

```cpp
贪心算法
```

```cpp
分支限界法
```

```cpp
回溯法
```

```cpp
动态规划法
```

本题知识点

搜索 贪心 动态规划

讨论

[Pandora](https://www.nowcoder.com/profile/266279)

关于五大常用算法，来自[随遇而安随缘一世](http://my.csdn.net/lcj_cjfykx)的 http://blog.csdn.net/lcj_cjfykx/article/details/41691787，值得大概了解。**贪心算法：**在对问题求解时，总是做出在当前看来是最好的选择，有可能陷入局部最优。**分治：**将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。**动态规划：**将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。**与分治的区别：**经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。**回溯：**在包含问题的所有解的解空间树中，按照**深度优先**搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。**分支限界：**采用**广度优先**的策略，在问题的解空间树 T 上搜索问题解。**与回溯区别：**回溯法的求解目标是找出 T 中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。//////////////////////////////////////////////////////////////////////至于题目，题意为排队购票，大的调整肯定不行，否则我直接喊所有 5 块的站前边，10 块的站后边，排队的人肯定不乐意。所以，必须依着本来的排队顺序，一步一步走，即从根结点出发，一步一步判断。就是分支限界的 FIFO 搜索：**将活节点表组织成一个** **队列**，并将队列的先进先出原则，选取下一个节点为当前扩展节点。（其实都不知道自己在说什么）

编辑于 2015-09-21 09:13:39

* * *

[leobuzhi](https://www.nowcoder.com/profile/932073)

这个是卡特兰数的经典应用。但是这个问题不是一两句话能说得清的，介绍卡特兰数的文章都用大量的篇幅讲他的原理。这里给你一个类似问题的描述，看看能不能看懂。问题描述: 12 个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问排列方式有多少种？ 这个笔试题，很 YD，因为把某个递推关系隐藏得很深。 问题分析: 我们先把这 12 个人从低到高排列,然后,选择 6 个人排在第一排,那么剩下的 6 个肯定是在第二排. 用 0 表示对应的人在第一排,用 1 表示对应的人在第二排,那么含有 6 个 0,6 个 1 的序列,就对应一种方案. 比如 000000111111 就对应着 第一排：0 1 2 3 4 5 第二排：6 7 8 9 10 11 010101010101 就对应着 第一排：0 2 4 6 8 10 第二排：1 3 5 7 9 11 问题转换为，这样的满足条件的 01 序列有多少个。 观察 1 的出现，我们考虑这一个出现能不能放在第二排，显然，在这个 1 之前出现的那些 0,1 对应的人 要么是在这个 1 左边，要么是在这个 1 前面。而肯定要有一个 0 的，在这个 1 前面，统计在这个 1 之前的 0 和 1 的个数。 也就是要求，0 的个数大于 1 的个数。 OK，问题已经解决。 如果把 0 看成入栈操作，1 看成出栈操作，就是说给定 6 个元素，合法的入栈出栈序列有多少个。 这就是 catalan 数,这里只是用于栈，等价地描述还有，二叉树的枚举、多边形分成三角形的个数、圆括弧插入公式中的方法数，其通项是 c(2n, n)/(n+1)。 在<<计算机程序设计艺术>>，第三版，Donald E.Knuth 著，苏运霖译，第一卷，508 页，给出了证明: 问题大意是用 S 表示入栈，X 表示出栈，那么合法的序列有多少个(S 的个数为 n) 显然有 c(2n, n)个含 S，X 各 n 个的序列，剩下的是计算不允许的序列数(它包含正确个数的 S 和 X，但是违背其它条件)。 在任何不允许的序列中，定出使得 X 的个数超过 S 的个数的第一个 X 的位置。然后在导致并包括这个 X 的部分序列中，以 S 代替所有的 X 并以 X 代表所有的 S。结果是一个有(n+1)个 S 和(n-1)个 X 的序列。反过来，对一垢一种类型的每个序列，我们都能逆转这个过程，而且找出导致它的前一种类型的不允许序列。例如 XXSXSSSXXSSS 必然来自 SSXSXXXXXSSS。这个对应说明，不允许的序列的个数是 c(2n, n-1)，因此 an = c(2n, n) - c(2n, n-1)。 分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。然后回到本问题，排队买票的每个人都是不同的，n 个人有 5 元，n 个人有 10 美分，最后结果在乘以 A（n,n）*A(n,n),即为“[c(2n, n) - c(2n, n-1)]*A（n,n）*A(n,n)”如果是填空题填多少种方法就是   (2n)!/[n!(n+1)!]

发表于 2016-02-07 16:38:20

* * *

[小杨 vita](https://www.nowcoder.com/profile/576504)

题目的意思是只要求得一个可行解就行了，那不就是贪心么，5 元钱的全排前面

发表于 2015-09-19 21:31:05

* * *

## 2

下列哪个用法哪个是错误的()

正确答案: C   你的答案: 空 (错误)

```cpp
int *a;
```

```cpp
extern const int array[256];
```

```cpp
const int &ra;
```

```cpp
typedef void (*FUN)();
```

本题知识点

C++

讨论

[IreanLau](https://www.nowcoder.com/profile/681025)

考察引用的性质 。指针  查看全部)

编辑于 2016-05-11 22:16:19

* * *

[ZKKZKK](https://www.nowcoder.com/profile/583989)

加上 const 修饰符，这个值就不可改了，所以必须在初始化的时候给值，和加不加引用无关。选 C

发表于 2015-09-20 09:34:06

* * *

[夏日星 2016](https://www.nowcoder.com/profile/830477)

引用本身就应该初始化，加上 const 时，更应该初始化了

发表于 2015-09-20 10:54:04

* * *

## 3

文法 G：S->xSx|y 所识别的语言是()

正确答案: D   你的答案: 空 (错误)

```cpp
(xyx)*
```

```cpp
xyx
```

```cpp
x*yx*
```

```cpp
xnyxn(n>=0)
```

本题知识点

编译和体系结构

讨论

[大龙龙](https://www.nowcoder.com/profile/643353)

因为 S->xSx|y，也就是有两种情况，S 可以推出 xSx,也可是推出 y。而 xSx 中又有 S，所以可以循环下去，一直推到 y 为止。就得出了 x 的 n 次方乘 y 乘 x 的 n 次方（n>=0）。

发表于 2015-09-29 12:29:55

* * *

[For-Happy](https://www.nowcoder.com/profile/205070)

答案为 D, 字符 y 两侧的 x 有相同的个数, 即 x^n yx^n (n>=0).

发表于 2015-09-19 18:27:09

* * *

[风雨中的人们](https://www.nowcoder.com/profile/859214)

右边的 S 也能按 S->xSx 推出，这样递归推导如下：
S->xSx->xxSxx->xxxSxxx->xxxxSxxxx->xx…xxSxx…xx
最后那个 S 推出终结符 y，才能结束，所以就变成 S->xx…xxyxx…xx

发表于 2017-03-18 11:17:30

* * *

## 4

分支限界法与回溯法的相同点是()

正确答案: A   你的答案: 空 (错误)

```cpp
都是一种在问题的解空间树 T 中搜索问题解的算法
```

```cpp
存储空间的要求相同
```

```cpp
搜索方式相同
```

```cpp
对扩展结点的扩展方式相同
```

本题知识点

dfs

讨论

[炫](https://www.nowcoder.com/profile/376795)

```cpp
相同点：二者都是一种在问题的解空间树 T 上搜索问题解的算法。
不同点：1.在一般情况下，分支限界法与回溯法的求解目标不同。
回溯法的求解目标是找出 T 中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。
2.回溯法与分支-限界法对解空间的搜索方式不同，回溯法通常采用尝试优先搜索，而分支限界法则通常采用广度优先搜索。
3.对节点存储的常用数据结构以及节点存储特性也各不相同，除由搜索方式决定的不同的存储结构外，分支限界法通常需要存储一些额外的信息以利于进一步地展开搜索。
```

发表于 2016-04-10 18:21:08

* * *

[zyweng](https://www.nowcoder.com/profile/986932)

  分支限界法 类似于回溯法，也是一种在问题的解空间树 T 上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。 **回溯法 的求解目标是找出 T 中满足约束条件的 所有解** ，而 **分支限界法** 的求解目标则是找出 **满足约束条件的一个解** ，或是在满足约束条件的解中找出使某一目标函数值达到 **极大或极小的解** ，即在某种意义下的 **最优解** 。http://blog.csdn.net/zhongjiekangping/article/details/5645091

发表于 2015-09-20 09:51:32

* * *

[葉知秋](https://www.nowcoder.com/profile/6658968)

A

发表于 2019-07-19 14:30:17

* * *

## 5

定义:int *const ptr;下面哪种说法是正确的()

正确答案: A   你的答案: 空 (错误)

```cpp
ptr 不可修改，*ptr 可修改
```

```cpp
ptr 不可修改，*ptr 不可修改
```

```cpp
ptr 可修改，*ptr 不可修改
```

```cpp
ptr 可修改，*ptr 可修改
```

本题知识点

C++ C 语言

讨论

[IreanLau](https://www.nowcoder.com/profile/681025)

考察 const 的作用，不需要死记硬背，没那么复杂。const 的作用就是封锁它后面的东西，即后面的不可改变。对于   i nt *const ptr;  没有 const 关键字时，为 int* ptr 此时 ptr 是指向 int 的指针。加上 const 后，const 修饰并封锁 ptr   。即 ptr 的指向不可改变。同理 int const* ptr(等同 const int *ptr)  。const 修饰 *  解引用  ，即 指针指向的内容不可改变。

发表于 2015-09-20 09:06:03

* * *

[yoghourt](https://www.nowcoder.com/profile/507803)

教给大家一个口诀* （指针）和 const（常量） 谁在前先读谁 ；*象征着地址，const 象征着内容；谁在前面谁就不允许改变。常量指针：指向的地址可以变，但内容不可以重新赋值，内容的改变只能通过修改地址指向后变换。指针常量：指向的地址不可以重新赋值，但内容可以改变，必须初始化，地址跟随一生。

发表于 2015-09-23 10:29:16

* * *

[orzOrzorzOrz](https://www.nowcoder.com/profile/374725)

一个诀窍是，只看 const 右边，以 const int * const p；为例，左起第一个 const 往右看到头遇到* 和 p，因此*p 不可改，第二个 const 往右看到头，遇到 p，因此，p 不可改所以就算是 const const int const  const* p1；也没有关系，依然是*p 不可改，p 可改（亲测，vs2010）

编辑于 2015-09-20 21:58:29

* * *

## 6

某 SRAM 芯片，存储容量为 64K*16 位，该芯片的地址线和数据线数目为()

正确答案: A   你的答案: 空 (错误)

```cpp
16,16
```

```cpp
64,8
```

```cpp
16,64
```

```cpp
64,16
```

本题知识点

编译和体系结构

讨论

[刘文静](https://www.nowcoder.com/profile/385877)

答案： A

由题知：存储容量为 64K*16 位；
存储容量为   2^地址线 * 数据线  位；
  2¹⁶ ≈ 64k；
地址线 = 16；
数据线 = 16；

编辑于 2015-09-19 18:47:06

* * *

[细雨湿身](https://www.nowcoder.com/profile/736416)

存储容量为   2^地址线 * 数据线  位；
  2¹⁶ ≈ 64k；
地址线 = 16；
数据线 = 16；

发表于 2016-10-06 10:46:19

* * *

[牛客 636161 号](https://www.nowcoder.com/profile/636161)

内存=2^地址线*数据线 位 2¹⁶=65536 65536/1024=64K 所以地址线为 16 数据线为 16

发表于 2016-09-11 23:45:16

* * *

## 7

有关线程的哪些叙述是对的()

正确答案: B C   你的答案: 空 (错误)

```cpp
当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面
```

```cpp
一个线程可能因为不同的原因停止(cease)并进入就绪状态
```

```cpp
使用 start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行
```

```cpp
一旦一个线程被创建，它就立即开始运行
```

本题知识点

操作系统

讨论

[殷帅](https://www.nowcoder.com/profile/5428142)

对于选项Ａ，当一个线程因为抢先机制而停止运行，它被放在可运行队列的后面对于选项Ｂ一个线程可能由于之前资源不可用导致进行阻塞状态，然后当资源可用的时候，就会进入到就绪态度．另外一种就是线程的时间片用完了之后也会从运行态转为就绪态．当然还有一种就是优先级更高的线程会抢占当前线程，使当前线程进入就绪态．对于选项Ｃ，Ｄ使用 start 方法只能将进行放到就绪的队列中，并不能立即执行．

发表于 2017-08-26 11:31:36

* * *

[夏倩倩](https://www.nowcoder.com/profile/168980)

线程因某一问题停止 不应该是转为阻塞状态吗 运行状态转为就绪状态的原因是：时间片用完

发表于 2016-02-24 10:19:07

* * *

[darren_wang](https://www.nowcoder.com/profile/831888)

这题目说的不清楚，这里的所谓“停止”是指线程没有获得 CPU 的使用权的时候。不是进入“停止”状态

发表于 2015-09-28 11:37:04

* * *

## 8

在 C++，下列哪一个可以做为对象继承之间的转换()

正确答案: C   你的答案: 空 (错误)

```cpp
static_cast
```

```cpp
reinterpret_cast
```

```cpp
dynamic_cast
```

```cpp
const_cast
```

本题知识点

C++

讨论

[wenyanliu](https://www.nowcoder.com/profile/425767)

reinterpret_cast：一个指针转化为其他类型的指针时，不做类型检测，操作结果是一个指针指向另一个指针的值的二进制拷贝；static_cast：允许执行隐式转换和相反的转换操作，父类转换为子类是强制转换 Son *son=static_cast(father)，而子类转换为父类就是隐式转换；dynamic_cast：用于对象的指针和引用，当用于多态类型转换时，允许隐式转换及相反的过程中，与 static_cast 的不同之处在于，在相反的转换过程中，dynamic_cast 会检测操作的有效性，如果返回的不是被 请求的 有效完整对象，则返回 null，反之返回这个有效的对象，如果是引用返回无效时则会抛出 bad_cast 异常；const_cast：这个转换操作会操纵传递对象的 const 属性，或者设置或者移除该属性。

发表于 2015-09-29 10:59:58

* * *

[IreanLau](https://www.nowcoder.com/profile/681025)

将一个基类对象指针（或引用）cast 到继承类指针，dynamic_cast 会根据基类指针是否真正指向继承类指针来做相应处理， 
       即会作一定的判断。 
       对指针进行 dynamic_cast，失败返回 null，成功返回正常 cast 后的对象指针； 
       对引用进行 dynamic_cast，失败抛出一个异常，成功返回正常 cast 后的对象引用。

发表于 2015-09-20 09:09:34

* * *

[暮雨潇潇 92](https://www.nowcoder.com/profile/9970619)

有个疑问，dynamic_cast 与 static_cast 这道题有什么区别呢？[`www.cnblogs.com/alexqdh/archive/2011/06/09/2075713.html`](http://www.cnblogs.com/alexqdh/archive/2011/06/09/2075713.html)看这个，好像感觉都可以用？！求大神解答

发表于 2016-08-30 11:19:55

* * *

## 9

关于"深拷贝"，下列说法正确的是()

正确答案: A   你的答案: 空 (错误)

```cpp
会拷贝成员数据的值和会拷贝静态分配的成员对象
```

```cpp
只会拷贝成员数据的值
```

```cpp
只会拷贝静态分配的成员对象
```

```cpp
只会拷贝动态分配的成员对象
```

本题知识点

C++

讨论

[leobuzhi](https://www.nowcoder.com/profile/932073)

我认为浅拷贝是一个不喜欢思考的懒汉，而深拷贝则是一个思维严谨，喜欢思考的人。对于懒汉来说，虽然给了他任务，但是他总是想尽量的少做一些事情，所以很多时候做出来的东西就是只看到了表面，不会去思考对不对。

```cpp
struct X { int x; int y; }; 
```

对于懒汉来说，他很直白的看到了 x，看到了 y，然后就拷贝 x 和 y，然后就不管了，反正我完成我的拷贝了，至于对不对，我不管。

而一旦有了引用或者指针，事情就不一样了

```cpp
struct X { int x; int y; int* p; }; 
```

懒汉依然只是直接表面级别的拷贝，于是拷贝 x, y , p，但是他没有思考接下来的事情对不对。对于指针或者引用来说，若是只是拷贝表面，那么拷贝后的物体的指针也和原来的指针指向的是同一个对象，所以虽然目的想完成一个完美的克隆体，但是却发现克隆体和原来的物体中间还有一根线连着，没有完美的分离。

```cpp
int *p = new int(47); int *q = p; 
```

如 q 与 p 都是指向一个物体一样。

那么如果原来的物体销毁了，但是现在拷贝的物体还在，那么这时候你拷贝后的物体的成员指针就是一个悬挂指针，指向了不再存在的物体，那么你访问的话，那就不知道会发生什么了。

而对于深拷贝，这一个勤奋的人，他不会只做表面，他会把每一个细节都照顾好。于是，当他遇到指针的时候，他会知道 new 出来一块新的内存，然后把原来指针指向的值拿过来，这样才是真正的完成了克隆体和原来的物体的完美分离，如果物体比作人的话，那么原来的人的每一根毛细血管都被完美的拷贝了过来，而绝非只是表面。所以，这样的代价会比浅拷贝耗费的精力更大，付出的努力更多，但是是值得的。当原来的物体销毁后，克隆体也可以活的很好。

然而事实上是这个世界上大多都是懒汉，包括编程的人，编译器等，所以默认的行为都是浅拷贝，于是有时候你需要做一个勤奋的人，让事情做正确，自己去完成深拷贝所需要的事情。出处：知乎 蓝色 [`www.zhihu.com/question/36370072`](https://www.zhihu.com/question/36370072)   （已经过授权）

编辑于 2016-02-18 22:46:39

* * *

[未来即来、](https://www.nowcoder.com/profile/216571)

堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配两种方式。静态分配由编译器完成，动态分配由 malloc 或 new 完成，所以静态分配的对象不等于 static 定义的静态变量，注意区分！

发表于 2016-02-24 12:47:43

* * *

[IreanLau](https://www.nowcoder.com/profile/681025)

在对与对象不产生修改的操作时，使用浅拷贝。即多个指针指向同一对象的内存。否则  深拷贝（或写实拷贝 ），形如 开辟对象等大的内存，并用指向。

发表于 2015-09-20 09:14:05

* * *

## 10

哪个是将一个十六进制赋值给一个 long 型变量()

正确答案: D   你的答案: 空 (错误)

```cpp
long number=0345L
```

```cpp
long number=345L
```

```cpp
long number=0345
```

```cpp
long number=0x345L
```

本题知识点

C++ C 语言

讨论

[IreanLau](https://www.nowcoder.com/profile/681025)

L :表明这个数是 long int 类型的，不写的话默认认为是 int

发表于 2015-09-20 09:27:51

* * *

[vipwhr](https://www.nowcoder.com/profile/744259)

0 开头表示八进制，0x 开头表示十六进制

发表于 2015-10-08 13:21:08

* * *

[laokhahha](https://www.nowcoder.com/profile/194579)

C 应该也是对的啊，0x345 没超过范围啊

发表于 2015-09-28 20:41:33

* * *

## 11

在 xdm 的配置目录中，哪个文件用来设置在用户通过 xdm 登录后自动起动的应用程序？

正确答案: B   你的答案: 空 (错误)

```cpp
The Xsession file
```

```cpp
The Xsetup_0 file
```

```cpp
The Xstart_up file
```

```cpp
The GiveConsole file
```

本题知识点

Linux

讨论

[Green 奇](https://www.nowcoder.com/profile/5533111)

xdm （X Display Manager）是一种图形化的登录界面。配置文件都放在/etc/X11/xdm 目录下 Xsession 文件决定了用户会话的风格，包含用户会话使用的命令 Xsetup_0 文件中的程序会和图形登录界面一起运行 GiveConsole 文件决定了在 Xwindows 移交给用户之前要执行的一些程序。 百度的，总结了一下，不知道对不对

发表于 2017-08-09 17:21:14

* * *

[粥凌](https://www.nowcoder.com/profile/705881)

xdm 是什么鬼

发表于 2017-05-05 15:34:00

* * *

[进击的软件攻城狮](https://www.nowcoder.com/profile/447205)

xsetup 文件里说明了，#!/bin/sh## Xsetup: **Setup an xlogin's display**

发表于 2015-09-20 15:45:12

* * *