# 欢聚时代 2018 校招笔试题-IOS A 卷【成都场】

## 1

进程间的通信方式，下列描述哪些是对的？

正确答案: A B D   你的答案: 空 (错误)

```cpp
共享存储
```

```cpp
消息传递
```

```cpp
系统中断
```

```cpp
管道文件
```

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 2018

## 2

iOS 开发中，下列哪些关键字是 ARC 下用于 @property 声明中的？

正确答案: A B C D   你的答案: 空 (错误)

```cpp
retain
```

```cpp
atomic
```

```cpp
unsafe_unretained
```

```cpp
assign
```

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 2018

## 3

Objective-C 是一门具有多项动态特性语言，表现在以下的哪些方面？

正确答案: A B C   你的答案: 空 (错误)

```cpp
动态类型
```

```cpp
动态绑定
```

```cpp
动态加载
```

```cpp
动态编译
```

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 2018

## 4

下列对 Category 的描述中，哪些是正确的？

正确答案: B C D   你的答案: 空 (错误)

```cpp
通过 Category 即可以向类中添加实例变量
```

```cpp
不用通过增加子类而增加现有类的方法
```

```cpp
Category 中的方法与原始类以及父类方法相比具有更高优先级
```

```cpp
通过 Category 可以将庞大一个类的方法进行划分,从而便于代码的日后的维护、更新以及提高代码的阅读性
```

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 2018

## 5

Objective-C 是通过 retainCount 来决定是否回收内存，每个 NSObject 都有一个计数器 retainCount。请问下列哪些操作时，内存的引用计数会加一？

正确答案: A B C   你的答案: 空 (错误)

```cpp
autorelease
```

```cpp
alloc
```

```cpp
copy
```

```cpp
release
```

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 2018

## 6

Objective-C 中，有很多的语法糖用于简化日常的开发，请问下面哪些不是 iOS 开发中的语法糖？

正确答案: A B D   你的答案: 空 (错误)

```cpp
#&quot;xxx&quot;
```

```cpp
$&quot;yyy&quot;
```

```cpp
@&quot;zzz&quot;
```

```cpp
:ttt
```

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 2018

## 7

下列哪些选项，是 HTTP 协议的请求关键字？

正确答案: A C D   你的答案: 空 (错误)

```cpp
POST
```

```cpp
SET
```

```cpp
PUT
```

```cpp
HEAD
```

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 2018

## 8

下列关于代理的描述，哪些是正确的？

正确答案: A B   你的答案: 空 (错误)

```cpp
代理又叫委托，是一种设计模式，代理是对象与对象之间的通信交互，代理解除了对象之间的耦合性。
```

```cpp
改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。
```

```cpp
代理的属性常是 copy 的原因：防止循环引用,以至对象无法得到正确的释放。
```

```cpp
代理是一种回调机制，且是一对多的关系。
```

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 2018

## 9

下列关于设计模式的原则描述，哪些是错误的？

正确答案: A C   你的答案: 空 (错误)

```cpp
依赖倒置原则，高层模块应该依赖底层模块，二者都不依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；
```

```cpp
接口隔离原则，建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。
```

```cpp
开放封闭原则，尽量通过修改已有代码来完成变化，而不是通过扩展软件实体来解决需求变化。
```

```cpp
里氏替换原则，在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。
```

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 2018

## 10

数据库操作中，事务的特性包括以下几种？

正确答案: A B C   你的答案: 空 (错误)

```cpp
原子性
```

```cpp
一致性
```

```cpp
隔离性
```

```cpp
临时性
```

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 2018

## 11

当两个对象互相持有对方的强引用，并且这两个对象的引用计数都不是 0 的时候，便造成了 1。

你的答案 (错误)

1 参考答案 (1) 引用循环 或 循环引用

本题知识点

欢聚集团 Java 工程师 前端工程师 算法工程师 PHP 工程师 iOS 工程师 2018

## 12

iOS 中多线程编程工具主要有三种，分别是 NSThread、1、2。

你的答案 (错误)

12 参考答案 (1) NSOperation
(2) GCD

本题知识点

欢聚集团 Java 工程师 前端工程师 算法工程师 PHP 工程师 iOS 工程师 2018

## 13

Objective-C 中加号用于定义 1 方法，减号用于定义 2 方法。

你的答案 (错误)

12 参考答案 (1) 类
(2) 实例

本题知识点

欢聚集团 Java 工程师 前端工程师 算法工程师 PHP 工程师 iOS 工程师 2018

## 14

当一个对象 sender 调用代码[receiver message];的时候，实际上是调用了 runtime 的 1 函数。

你的答案 (错误)

1 参考答案 (1) objc_msgSend

本题知识点

欢聚集团 Java 工程师 前端工程师 算法工程师 PHP 工程师 iOS 工程师 2018

## 15

1 方法是当类或分类被添加到 Objective-C runtime 时被调用的，实现这个方法可以让我们在类加载的时候执行一些类相关的行为。

你的答案 (错误)

1 参考答案 (1) load

本题知识点

欢聚集团 Java 工程师 前端工程师 算法工程师 PHP 工程师 iOS 工程师 2018

## 16

如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为 1。

你的答案 (错误)

1 参考答案 (1) 最大堆

本题知识点

欢聚集团 Java 工程师 前端工程师 算法工程师 PHP 工程师 iOS 工程师 2018

## 17

计算机密码学中，有一类算法，公钥用于加密，它是向所有人公开的；私钥用于解密，只有密文的接收者持有。这种算法一般称为 1。

你的答案 (错误)

1 参考答案 (1) 非对称加密算法

本题知识点

欢聚集团 Java 工程师 前端工程师 算法工程师 PHP 工程师 iOS 工程师 2018

## 18

E-R 模型的组成包括 1、2、属性 三种元素。

你的答案 (错误)

12 参考答案 (1) 实体
(2) 关系

本题知识点

欢聚集团 Java 工程师 前端工程师 算法工程师 PHP 工程师 iOS 工程师 2018

## 19

数据库系统中采用封锁技术的目的是为了保证数据的 1。

你的答案 (错误)

1 参考答案 (1) 一致性

本题知识点

欢聚集团 Java 工程师 前端工程师 算法工程师 PHP 工程师 iOS 工程师 2018

## 20

UDP 是一个简单的 1 协议。

你的答案 (错误)

1 参考答案 (1) 传输层

本题知识点

欢聚集团 Java 工程师 前端工程师 算法工程师 PHP 工程师 iOS 工程师 2018

## 21

请比较一下堆和栈的区别？

你的答案

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 2018

## 22

编译器是一种将字符串输入，通过各种算法，逐步翻译优化为目标机器语言的工具。其中的步骤繁多，每一步都会有自己的中间产物，请描述这个过程，写下你所了解的每一个步骤以及对应的中间产物。

你的答案

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 2018

## 23

对于输入的字符串，从左到右扫描字符串，如果存在由三个以上（包括三个）连续相同字符组成的子串，就将这个子串从原串中去掉，并将原有字符串剩下的部分拼接到一起。重复上述过程，直到无法去掉任何子串

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 字符串 *模拟 2018* *讨论

[锦衣狼](https://www.nowcoder.com/profile/9879861)

答案有问题，题目明明写了“三个以上（包括三个）”，“就将这个子串从原串中去掉”，但是答案是每次只删掉 3 个得来的

发表于 2018-08-03 11:02:28

* * *

[qjfoidnh](https://www.nowcoder.com/profile/687214058)

注意，该题系统认定答案与真实答案不符，锦衣狼已经说过了。将代码中注释的部分去掉为真实解答，但无法通过；加上注释可以通过。

```cpp
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String in = sc.nextLine();
        StringBuilder str;
        if(in.length()==0) System.out.print("");
        int countflag = 1;
        char pre = 0;
        while(true) {
            str = new StringBuilder();
            countflag = 1;
            pre = 0;
            for(int i=0; i<in.length(); i++) {
                char c = in.charAt(i);
                if(countflag==4) {
//                    if(c==pre) continue;
//                    else {
                        countflag = 1;
                        pre = 0;
//                    }
                }
                str.append(c);
                if(c==pre) countflag++;
                else {
                    pre = c;
                    countflag = 1;
                }
                if(countflag==3) {
                    for(int k=0; k<3; k++) str.deleteCharAt(str.length()-1);
                    countflag++;
                    continue;
                }

            }
            if(str.length()==in.length()) break;
            else in = str.toString();
        }
        System.out.print(str.toString());
    }
}
```

发表于 2020-03-12 23:48:09

* * *

[流光 201903042136772](https://www.nowcoder.com/profile/642940859)

```cpp
#include <iostream>
#include <string>
#include <stack>
using namespace std;

string dfs(string &s, const int cnt) {
    string res = "";
    int pos = 0, len = s.length(), count; //记录剩余重复元素长度（每有 cnt 个元素重复就会消除)
    for (int i = 1; i <= len; i++) {
        if (s[i] != s[i - 1]) {
            count = (i - pos) % cnt;
            res += s.substr(i - count, count);
            pos = i;
        } 
    }
    int len_res = res.length();
    if (len_res == len)
        return res;
    else
        return dfs(res, cnt);
}

int main() {
    string s;
    int cnt = 3;
    while(cin >> s) {
        cout << dfs(s, 3) << endl;
    }
    return 0;
}
```

发表于 2019-09-04 17:43:25

* * *

## 24

给定一个序列 An = a1 ,a2 ,  ... , an ，找出最长的子序列使得对所有 i < j ，ai < aj 。求出这个子序列的长度

本题知识点

欢聚集团 Java 工程师 C++工程师 iOS 工程师 安卓工程师 运维工程师 前端工程师 算法工程师 PHP 工程师 动态规划 查找 *数组 2018* *讨论

[LIFEFOR](https://www.nowcoder.com/profile/765731373)

#include <iostream>#include<vector>
#include<algorithm>
using namespace std;
int main()
{
    vector<int> nums;
    int res=0;
    int n;
    while(cin>>n) nums.push_back(n);
    int len=nums.size();
    vector<int> dp(len,1);
    for(int i=1;i<len;i++){
        for(int j=i-1;j>=0;j--){
            if(nums[i]>nums[j]){
                dp[i]=max(dp[j]+1, dp[i]);
            }
        }
    }
    for(int i=0;i<len;i++){
        res=max(dp[i],res);
    }
    cout<<res;
    return 0;
}

发表于 2020-06-22 14:34:55

* * *

[Heerh](https://www.nowcoder.com/profile/444845122)

```cpp
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        String[] str = scanner.nextLine().split(" ");
        //int len = str.length;
        int[] arr = new int[str.length];
        for(int i=0;i<str.length;i++){
            arr[i]=Integer.parseInt(str[i]);
        }
        int max = lengthOfLIS(arr);
        System.out.println(max);
    }
    static int lengthOfLIS(int[] arr){
        //数组定义：dp[i]为从 0 到 i 的最长递增子序列值，base case ：自身并入计算结果中
        int[] dp = new int[arr.length];
        Arrays.fill(dp,1);
        int max = arr[0];
        for(int i = 0;i < arr.length; i++){
            for(int j = 0; j <= i; j++){
                if(arr[i] > arr[j]){
                    dp[i] = Math.max(dp[j] + 1, dp[i]); 
                }
            }
            max = Math.max(dp[i], max);
        }
        return max;
    }
}
```

发表于 2021-03-08 21:40:45

* * *

[牛客 341441072 号](https://www.nowcoder.com/profile/341441072)

```cpp
nums = list(map(int,input().split()))
l,r = 0,0
res = 1
for i in range(len(nums)-1):
    if nums[i+1]>nums[i]:
        r +=1
        res = max(res,r-l+1)
    else:
        r+=1
        l+=1
print(res)
```

发表于 2020-05-02 15:00:00

* * *</iostream>**