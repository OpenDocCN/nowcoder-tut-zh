# 三百六十、公司-2019 校招笔试-C 开发工程师客观题合集

## 1

下面程序的执行结果为（）

```cpp
#include <stdio.h>

int func(int n) {
    if (n < 2)
        return n;
    return func(n - 1) + func(n - 2);
}

int main () {
    printf("%d\n",func(7));
    return 0;
}
```

正确答案: B   你的答案: 空 (错误)

```cpp
11
```

```cpp
13
```

```cpp
17
```

```cpp
21
```

本题知识点

360 公司 C++工程师 2019 C 语言

讨论

[十点睡觉💤](https://www.nowcoder.com/profile/270125029)

f(0)=0;   f(1)=1;
f(2)=f(1)+f(0)=1
f(3)=f(2)+f(1)=2
f(4)=f(3)+f(2)=3
f(5)=f(4)+f(3)=5
f(6)=f(5)+f(4)=8
f(7)=f(6)+f(5)=13 感谢大神思路，学到了，好方法，硬想递归，脑袋要爆炸

发表于 2019-01-07 13:06:38

* * *

[yeyoenjoy](https://www.nowcoder.com/profile/572955639)

f(0)=0;f(1)=1;f(2)=f(1)+f(0)=1;f(3)=f(2)+f(1)=2;...f(7)=f(6)=f(5)=5+8=13

发表于 2019-01-01 15:30:44

* * *

[midou0629](https://www.nowcoder.com/profile/864256344)

这 TM 是 Java 面试题吗？

发表于 2018-12-19 21:50:29

* * *

## 2

下列程序执行 func(15,20)的结果为（）

```cpp
int func(int i, int j){
    if (i <= 0 || j <= 0)
        return 1;
    return 2 * func(i - 3, j / 2);
}
```

正确答案: D   你的答案: 空 (错误)

```cpp
8
```

```cpp
16
```

```cpp
24
```

```cpp
32
```

本题知识点

360 公司 C++工程师 2019 C 语言

讨论

[十点睡觉💤](https://www.nowcoder.com/profile/270125029)

f(0,0)=1
f(3,1)=2*f(0,0)=2
f(6,2)=2*f(3,1)=4
f(9,5)=2*f(6,2)=8
f(12,10)=2*f(9,5)=16
f(15,20)=2*f(12,10)=32 解析来了

发表于 2019-01-07 13:12:43

* * *

[玄学求 offer~](https://www.nowcoder.com/profile/259973278)

 i        j15    2012    10    2*9       5     2²⁶       2     2³³       1     2⁴⁰       0     2⁵         -------->32

发表于 2019-01-03 16:08:30

* * *

[杉杉来啦](https://www.nowcoder.com/profile/243827773)

i 15 12 9 6 3 0
j 20 10 5 2 1 0
    2**2**2**2**2*1＝ 32

编辑于 2020-03-06 12:58:24

* * *

## 3

如图所示，为学生选课表 SC、课程课号表 C、学生学号表 T，其中表 T 由如下运算得到
T=![](img/f853180cea4fd2b457760d75cde4c556.svg)学号，课号 (SC )  / C ，则表 T 表示（  ）。![](img/9080c9b14fc488a63227f60d060d7851.png)

正确答案: A   你的答案: 空 (错误)

```cpp
选修了表 C 中全部课程的学生学号
```

```cpp
全部学生的学号
```

```cpp
选修了课程 C1 或 C2 的学生学号
```

```cpp
所选课程成绩及格的学生学号
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 测试工程师 数据库 2019 测试开发工程师

讨论

[已注销](https://www.nowcoder.com/profile/7558628)

这是关系代数运算中 专门的关系运算中的除运算，语义是：

> 设关系 R 除以关系 S 的结果为关系 T，则 T 包含所有在 R 但不在 S 中的属性及其值，且 T 的元组与关系 S 的元组的所有组合都在 R 中。

对于这个题来说，关系 T 包含所有在 SC 但不在 C 中的属性及其值，且 T 的元组与关系 C 的元组的所有组合都在 SC 中。

组合起来之后就是

| T | C |
| --- | --- |
| 101 | C1 |
| 101 | C2 |
| 102 | C1 |
| 102 | C2 |
| .. | .. |

这个结果就是选修了表 C 中全部课程的学生学号

发表于 2018-12-26 16:13:00

* * *

[fkyyds](https://www.nowcoder.com/profile/819417377)

T=π[id][，sno]（SC）/C,有两次操作，首先得到 SC 在学号和课号上的投影 R：

| id | sno |
| 101 | C1 |
| 101 | C2 |
| 102 | C1 |
| 102 | C2 |
| 103 | C1 |

然后才是除运算：R/C 通过象集可以判断。假设 R(X,Y),C(Y,Z)，除运算得到的新关系就是 P(X)：R 元组在 X 上分量值 x 的象集 Yx 包含 C 在 Y 上投影的集合，Yx 就是当 X=x 时，对应的 Y 的取值集合。本题中 R（id，sno），C（sno），进行 R/C 运算，显而易见最后的关系 T 肯定是学号 R：101 的象集：｛C1,C2｝102 的象集：｛C1,C2｝103 的象集：｛C1｝C 在 sno 上的投影：
C1C2 只有 101、102 的象集包含了 C 的投影，也就是学号 101、102 的学生选择了全部课程，R/C=｛101，102｝

发表于 2021-09-26 11:33:12

* * *

[闲鱼总算翻了身](https://www.nowcoder.com/profile/909589300)

设关系 R 除以关系 S 的结果为关系 T，则 T 包含所有在 R 但不在 S 中的属性及其值，且 T 的元组与关系 S 的元组的所有组合都在 R 中。
对于这个题来说，关系 T 包含所有在 SC 但不在 C 中的属性及其值，且 T 的元组与关系 C 的元组的所有组合都在 SC 中。

发表于 2021-07-22 15:52:33

* * *

## 4

ROUND(11.56,0)的值为（      ）

正确答案: D   你的答案: 空 (错误)

```cpp
11.56
```

```cpp
11.6
```

```cpp
11
```

```cpp
12
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 测试工程师 编程基础 *2019 测试开发工程师* *讨论

[青简](https://www.nowcoder.com/profile/708069809)

Round 函数返回一个数值，该数值是按照指定的小数位数进行四舍五入运算的结果

发表于 2019-09-26 16:23:45

* * *

[prosmaug](https://www.nowcoder.com/profile/818760448)

四舍五入不会不知道吧，哈哈

发表于 2018-12-19 21:06:38

* * *

[不吃白切鸡](https://www.nowcoder.com/profile/5648508)

Round 函数返回一个数值，该数值是按照指定的小数位数进行四舍五入运算的结果

发表于 2019-04-08 11:20:13

* * *

## 5

存在 R=(A,B,C,D,E)，F={A→B,B→C,CE→D},则 R 的候选码为（      ）

正确答案: B   你的答案: 空 (错误)

```cpp
AD→E
```

```cpp
BC→E
```

```cpp
DC→AB
```

```cpp
DB→A
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 测试工程师 编译和体系结构 C++工程师 360 公司 2019 iOS 工程师 360 公司 2019 Java 工程师 360 公司 2019 测试开发工程师 360 公司 2019

讨论

[未来世界](https://www.nowcoder.com/profile/125739422)

答案应该是 AE 吧

发表于 2019-02-13 22:08:45

* * *

[满江红](https://www.nowcoder.com/profile/40387256)

这题是数据库的题目么？要是的话，那应该是 AE 呀，这题答案选项看不懂呀！

发表于 2019-09-03 16:10:16

* * *

[Isoon](https://www.nowcoder.com/profile/628327468)

我想说的是，候选码不是字段的集合吗？这题的选项不都是表示一种关系吗？有病吧

发表于 2020-03-23 23:38:28

* * *

## 6

以下的数据库设计就符合第一设计范式的
是：（   ）。

正确答案: B C D   你的答案: 空 (错误)

```cpp
CREATE TABLE member(
编号       INT PRIMARY KEY ,
姓名       VARCHAR(20) ,
联系方式 VARCHAR(200)
) ;
```

```cpp
CREATE TABLE member(
编号         INT PRIMARY KEY ,
姓名         VARCHAR(20) ,
地址         VARCHAR(200) ,
邮政编码   VARCHAR(6) ,
电话         VARCHAR(20) ,
qq            VARCHAR(20)
) ;
```

```cpp
CREATE TABLE orders(
编号         INT  PRIMARY KEY ,
商品名称   VARCHAR(20) ,
单价           INT ,
数量           INT ,
总价           INT
) ;
```

```cpp
CREATE TABLE student(
学生编号 INT  PRIARY KEY ,
学生姓名   VARCHAR(20)) ;
CREATE TABLE course(
课程编号  INT PRIMARY KEY ,
课程名称   VARCHAR(50) ,
课程学分   INT) ;
CREATE TABLE studentcourse(
学生编号   INT REFERENCES student(学生编号) ON DELETE CASCADE ,
课程编号  INT  REFERENCES course(课程编号) ON DELETE CASCADE ,
成绩      INT) ;
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 测试工程师 数据库 2019 测试开发工程师

讨论

[lixiaoling](https://www.nowcoder.com/profile/844191568)

这题目是不是有点歧义？我还以为它说的“就符合第一范式”指的是不能是第二范式和第三范式什么的，谁知道它是想考不可再分

发表于 2019-10-18 12:17:37

* * *

[用杰亿 666](https://www.nowcoder.com/profile/8411665)

第一设计范式:  所有属性不可以再划分，用于保证列的原子性，上面第一个的联系方式不满足，联系方式有很多(手机、电话、邮编、地址等)，因此 A 不符合第一设计范式 A 有争议么  谁设计数据库会这样搞  联系方式不说清楚  用户该填 QQ 还是填电话还是填 email？

编辑于 2020-05-08 16:42:40

* * *

[JingweiHe](https://www.nowcoder.com/profile/339218660)

地址还可以分省市区县。

发表于 2019-09-08 17:06:40

* * *

## 7

shell 中要输出 a+b 的结果（假设 a 和 b 已经被赋值），如何得到

正确答案: D   你的答案: 空 (错误)

```cpp
echo ${a+b}
```

```cpp
echo $(a+b)
```

```cpp
echo ${{a+b}}
```

```cpp
echo $((a+b))
```

本题知识点

C++工程师 360 公司 算法工程师 shell 2019

讨论

[踏上不归路](https://www.nowcoder.com/profile/220948689)

这个意思是双括号中的运算代表 c 语言运算，然后输出

发表于 2019-08-06 10:16:54

* * *

[阿达新](https://www.nowcoder.com/profile/995567233)

双括号要有空格吧

发表于 2020-10-26 21:58:36

* * *

## 8

假设在 shell 中执行的脚本为：./prog.sh  "p1" "p2" "p3 p4"，而我们要在脚本 prog.sh 中获取参数，应该使用

正确答案: A   你的答案: 空 (错误)

```cpp
$@
```

```cpp
$*
```

```cpp
$#
```

```cpp
$?
```

本题知识点

C++工程师 360 公司 算法工程师 shell 2019

讨论

[是真想不出昵称啊](https://www.nowcoder.com/profile/94336747)

$$
Shell 本身的 PID（ProcessID）
$!
Shell 最后运行的后台 Process 的 PID
$?
最后运行的命令的结束代码（返回值）
$-
使用 Set 命令设定的 Flag 一览
$*
所有参数列表。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。
$@
所有参数列表。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
$#
添加到 Shell 的参数个数
$0
Shell 本身的文件名
$1～$n
添加到 Shell 的各参数值。$1 是第 1 参数、$2 是第 2 参数…

发表于 2019-07-13 15:02:52

* * *

[SoWhataaaa](https://www.nowcoder.com/profile/869375575)

$*   和$@都是列出参数列表。区别：$* 列出的参数列表是一个整体。$@列出的参数列表中每一个参数都是独立的

发表于 2020-05-24 11:56:24

* * *

## 9

代码：HANDLE hMutexSuicide=::OpenMutex (SYNCHRONIZE,FALSE,g_szMutexName);其中 FALSE 的作用是（）

正确答案: B   你的答案: 空 (错误)

```cpp
不需要同步
```

```cpp
不需要向下传递
```

```cpp
设置缺省的安全性
```

```cpp
不继承句柄
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 操作系统 2019 系统工程师

讨论

[一顿大餐](https://www.nowcoder.com/profile/987955162)

HANDLE hMutexSuicide = OpenMutex( SYNCHRONIZE, // 打开用于同步 FALSE,// 不需要向下传递 g_szMutexName) ; // 名称

发表于 2019-04-15 09:22:31

* * *

[牛客 761931914 号](https://www.nowcoder.com/profile/761931914)

https://www.cnblogs.com/staring-hxs/p/3664765.html

发表于 2020-08-29 18:29:59

* * *

## 10

中日兵乓球联赛男子双打比赛，中方 C1，C2 两位选手和日方 J1，J2 两位选手对阵。首轮由中方发球，直至接球失误后由队方换发球。试用 PV 操作原语分析这一过程，以下合理的说法是（     ）

正确答案: C   你的答案: 空 (错误)

```cpp
应设置至少 4 个信号量，分别代表 4 类消息的传递。4 个信号量的初始值均为 0。
```

```cpp
应设置至少 2 个信号量，分别代表 2 组队员对资源的使用权。2 个信号量的初始值均为 0。
```

```cpp
应设置至少 4 个信号量，分别代表 4 类消息的传递。4 个信号量的初始值只有一个为 1，其余均设置为 0。
```

```cpp
应设置至少 4 个信号量，分别代表 4 类消息的传递。4 个信号量的初始值只有一个为 0，其余均设置为 1。
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 操作系统 2019 系统工程师

讨论

[ss201911191415561](https://www.nowcoder.com/profile/727050741)

首先分析互斥还是同步(有相互联系的，即你发生我才发生)，发现乒乓球是一个互斥量，所以初值为 1，然后发现当中方或者日方有任意一方接球失误后，都换为对方发球，属于同步关系，其中有三个量，中方失误，日方失误，轮换发球(即同步关系)由于刚开始失误次数肯定都是 0，又因为轮换发球属于同步关系初值为 0，所以除了一个互斥量为 1 外，其余各部分初值为 0

编辑于 2019-12-04 15:27:12

* * *

[{球球 offer}](https://www.nowcoder.com/profile/971225653)

参考答案和其它解析写的。。不确定理解是否正确。

```cpp
//我理解的四种消息：c 打球成功，c 打球失败；j 打球成功，j 打球失败
sem_t t1,t2,t3,t4;
sem_init(&t1,0);
sem_init(&t2,0);
sem_init(&tc,1);//初始化时 c 打球
sem_init(&tj,0);
int score_c=0;
int score_j=0;
control(){//c 打球失败时，j 计分
	sem_wait(&t1);
	score_j++;
	sem_post(&tj);
}
control2(){
	sem_wait(&t2);
	score_c++;
	sem_post(&tc);
}
fc(){
	sem_wait(&tc);
	if(发球失败){
		sem_post(&t1);
	}
	else{
		sem_post(&tj);
	}
}
fj(){
	sem_wait(&tj);
	if(发球失败){
		sem_post(&t2);
	}
	else{
		sem_post(&tc);
	}
}
```

发表于 2020-04-22 12:36:46

* * *

## 11

单处理系统中，进程 P1,P2,P3 处于就绪队列，进程 P4，P6 处于等待队列，P5 正占用处理器运行，以下关于进程调度时机分析正确的是（     ）

正确答案: A B D   你的答案: 空 (错误)

```cpp
P5 执行结束，释放 CPU 使用权时一定会引起进程调度
```

```cpp
P5 由运行状态转换为等待状态时一定会引起进程调度。
```

```cpp
P6 由运行等待转换为就绪状态时一定会引起进程调度。
```

```cpp
P5 由运行状态转换为就绪状态时一定会引起进程调度。
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 操作系统 2019 系统工程师

讨论

[呦呵呵](https://www.nowcoder.com/profile/9522175)

进程调度时机：当前运行进程主动放弃处理机和当前运行进程被动放弃处理机。主动放弃处理机：（1）进程正常终止  运行态->终止态 (2)运行过程中发生异常而终止 运行态->终止态（3）进程主动请求阻塞 如等待 I/O 运行态->阻塞态被动放弃处理机：（1）分给进程的时间片用完 运行态->就绪态  (2)有更紧急的事需要处理 如 I/O 中断 运行态->就绪态  (3)有更高优先级的进程进入就绪队列 运行态->就绪态 故认为应该选 ABD

发表于 2019-08-14 16:47:33

* * *

[58 同城 2022 校园招聘](https://www.nowcoder.com/profile/1484845)

等待队列是阻塞队列吗？？？选 ABD 吧

发表于 2019-03-06 21:39:14

* * *

[Serendipity-zsh](https://www.nowcoder.com/profile/905290950)

P6 优先级大于 P5，B 选项才是对的吧

发表于 2019-11-21 21:59:13

* * *

## 12

系统采用分级调度算法。进程 a1~a6 处于 I 级队列，进程 b1~b6 处于 II 级队列，进程 c1~c6 处于 III 级队列,则以下描述正确的是（     ）

正确答案: A C D   你的答案: 空 (错误)

```cpp
I 级队列的进程获得的时间片最少。
```

```cpp
I 级队列的进程获得的时间片最多。
```

```cpp
分级调度是结合了时间片轮转法和优先级算法的优势。
```

```cpp
一个新创建的进程 P，会先加入 I 级队列。
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 操作系统 2019 系统工程师

讨论

[已注销](https://www.nowcoder.com/profile/7558628)

分级调度算法是结合时间片轮转调度算法一起使用的( **C 对** )，这种算法的本质是链入多个队列，当进程消耗完时间片但是它的工作尚未结束时，它就会被链入下一级队列，第一级队列的优先级最高( **D 对** )，但是第一级队列的进程分配的时间片都很小( **A 对** )，于是很快就轮转完了，队列等级越往下，时间片分配的就越多。

发表于 2018-12-26 20:07:28

* * *

[延大 _ 王星星](https://www.nowcoder.com/profile/395313099)

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。
多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如
1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。
每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。
可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

发表于 2020-04-21 19:12:03

* * *

[tgs201804180012504](https://www.nowcoder.com/profile/7741333)

一级是最低级的，不是最高级😭

发表于 2020-11-28 12:39:36

* * *

## 13

下图的 UML 类结构图表示的是哪种设计模式？![](img/20de34a53fb9fabd0b0977c4b2fd6500.png)

正确答案: B   你的答案: 空 (错误)

```cpp
原型模式
```

```cpp
策略模式
```

```cpp
代理模式
```

```cpp
观察者模式
```

本题知识点

C++工程师 360 公司 C++工程师 360 公司 C++工程师 360 公司 C++工程师 360 公司 UML C++工程师 360 公司 2019

## 14

存在 R=(A,B,C,D,E)，F={A→B,B→C,CE→D},则 R 的候选码为（      ）

正确答案: D   你的答案: 空 (错误)

```cpp
CE
```

```cpp
A
```

```cpp
B
```

```cpp
AE
```

本题知识点

C++工程师 360 公司 数据库 2019

讨论

[里外不是人](https://www.nowcoder.com/profile/779629562)

候选码的定义：若关系中的某一属性组的值能唯一地标识一个元组（表中的一行数据），则称该属性组为候选码。A->B 表示 B 依赖于 A, A 可能是候选码，找出没有依赖关系的属性，就是候选码，所以是 AE.可以参照这个：[`blog.csdn.net/weiyongle1996/article/details/73481163`](https://blog.csdn.net/weiyongle1996/article/details/73481163) 

发表于 2019-09-18 18:04:41

* * *

[不要把我当工具人](https://www.nowcoder.com/profile/531522761)

A→B 可以理解为 B 依赖于 A，也可以理解为 A 决定 B，则 A→B,B→C,表示 A 决定 B，B 决定 C，则 A 就能唯一标识 B 和 C，则 CE→D 可以理解为 C 和 E 能决定 D，而 C 又被 A 决定，所以 AE 可以唯一标识这个五元组，相当于 AE 是联合主键

发表于 2021-11-22 16:13:51

* * *

[Changing201906261820260](https://www.nowcoder.com/profile/32834164)

R 中的组合，根据 F 能推出 R 中每一个元素

发表于 2019-11-12 17:39:13

* * *

## 15

w_user 表结构如下：
+--------+---------+------+-----+---------+----------------+
| Field  | Type    | Null | Key | Default | Extra          |
+--------+---------+------+-----+---------+----------------+
| u_id   | int(4)  | NO   | PRI | NULL    | auto_increment |
| u_name | char(8) | YES  |     | NULL    |                |
| u_pass | char(8) | YES  |     | NULL    |                |
| u_img  | blob    | YES  |     | NULL    |                |
| u_info | text    | YES  |     | NULL    |                |
+--------+---------+------+-----+---------+----------------+
以下创建索引的语句正确的是（     ）

正确答案: B C   你的答案: 空 (错误)

```cpp
CREATE INDEX in1 ON w_user(u_name(10));
```

```cpp
CREATE INDEX in2 ON w_user(u_pass(3));
```

```cpp
CREATE INDEX in3 ON w_user(u_img(10));
```

```cpp
CREATE INDEX in4 ON w_user(u_info);
```

本题知识点

C++工程师 360 公司 数据库 2019

讨论

[bighand](https://www.nowcoder.com/profile/121111411)

创建索引的语句是 create index indexname on tablename (username (length))其中若是 char 和 varchar 类型，length 可以小于字段实际长度，若是 blob 或 text 类型，必须指定 length！

发表于 2019-06-11 12:49:20

* * *

[我是小黄啊](https://www.nowcoder.com/profile/275977704)

![](img/f825988de7916dfb73f40ca0817f4e1a.png)

发表于 2021-06-23 10:40:06

* * *

[捕夢](https://www.nowcoder.com/profile/364378123)

创造索引

发表于 2020-04-12 18:15:38

* * *

## 16

有下列程序

```cpp
using namespace std;
class SC {
public:
    SC(int r){R =_____________;}
    int Get(){return *R;};
private:
    int *R;
};
int main() { 
    SC C(10);
    cout <<C.Get()<< endl;
    return 0;
}
```

请将构造函数补充完整，使得程序的运行结果是 10。

正确答案: B   你的答案: 空 (错误)

```cpp
new int R
```

```cpp
R = new int(r);
```

```cpp
&r
```

```cpp
*r
```

本题知识点

C++工程师 360 公司 C++ 2019 C 语言

讨论

[_Arvin](https://www.nowcoder.com/profile/858165899)

本题正确答案应为 R = new int(r);C 选项 &r;   R 指的是 r 的位置，但是 r 是临时变量，生命周期结束之后 r 被释放，其内存地址不安全，会被其他变量重新定义。其值也是不确定的

编辑于 2021-02-17 20:38:21

* * *

[LEOPARD2A5](https://www.nowcoder.com/profile/359459635)

注意赋值形参的地址没有意义

发表于 2021-04-05 21:51:22

* * *

[THE_LIN](https://www.nowcoder.com/profile/680957182)

选 A

发表于 2020-07-24 19:51:22

* * *

## 17

有以下类定义

```cpp
using namespace std;
class B1{
    int b1;
public:
    B1(int i){
        b1=i; cout<<b1; }
    ~B1( ){ cout<<"#1"; }
};
class B2 {
    int b2;
public:
    B2( ){b2=0; cout<<"*2"; }
    ~B2( ){ cout<<"#2"; }
};
class C: virtual public B1,public B2 {
    int j;
public:
    C(int a,int b,int c):B1(a),_______ ,j(c){cout<<"*3";}
    ~C( ){ cout<<"#3"; }
private:
    B1 c1;
    B2 c2;
};
```

请为横线处选择合适的程序将派生类 C 的构造函数补充完整。

正确答案: B   你的答案: 空 (错误)

```cpp
B1(b)
```

```cpp
c1(b)
```

```cpp
c2(b)
```

```cpp
B2(b)
```

本题知识点

C++工程师 360 公司 C++ 2019

讨论

[我的天鸭](https://www.nowcoder.com/profile/243498)

答案是 B，简单解释一下为什么不选另外三个：A 选项中的 B1(b)：基类 B1 已经在 B1(a)中显式初始化过了，不能再次初始化 C 选项中的 c2(b)：成员变量 c2 是类 B2 的对象，而类 B2 并没有参数列表相匹配的构造函数 D 选项中的 B2(b)：基类 B2 没有参数列表相匹配的构造函数

发表于 2019-08-17 16:50:26

* * *

[晨跑有信心](https://www.nowcoder.com/profile/68264500)

B2 不需要实参，而 B1 的对象从 c1 需要初始化

发表于 2019-10-24 16:38:29

* * *

[牛客 562480116 号](https://www.nowcoder.com/profile/562480116)

封闭类用实例名(c1)初始化；派生类对基类用类型名（B1）初始化

发表于 2021-03-20 21:34:47

* * *

## 18

以下程序的输出结果为（）

```cpp
using namespace std;
void print(char **str) {
    ++str;    
    cout<<*str<<endl;
}
int main() {
    static char *arr[]={"hello", "world", "c++"};
    char **ptr;
    ptr=arr;
    print(ptr);
    return 0;
}
```

正确答案: B   你的答案: 空 (错误)

```cpp
hello
```

```cpp
world
```

```cpp
字符 w 的起始地址
```

```cpp
字符 e
```

本题知识点

C++工程师 360 公司 C++ 2019 C 语言

讨论

[malofleur](https://www.nowcoder.com/profile/232267)

可以把 *ptr 当作一个整体，指向一个 char* 的字符串，然后注意下面这些情况：

```cpp
*ptr = arr[0] = "hello"
(*ptr)[1] = arr[0][1] = 'e'
(*ptr + 1) = arr[0][1:] = "ello"
*(ptr + 1) = arr[1] = "world"
```

发表于 2019-08-21 20:52:23

* * *

[fingerling-俞](https://www.nowcoder.com/profile/679591153)

![](img/f9d437d0c1d7999b64d61f401f9b3b4f.png)

发表于 2020-05-29 11:11:00

* * *

[Copyright](https://www.nowcoder.com/profile/6805252)

个人理解 ptr 是一个指向 char *变量的指针，而 char*我理解为一个字符数组，也就是字符串。

发表于 2020-02-18 00:29:23

* * *

## 19

下面程序的输出为（）

```cpp
int main() {
    char *ptr;    
    char arr[] = "12345678";
    ptr = arr;
    ptr += 5;
    printf("%s", ptr);
    return 0;
}
```

正确答案: B   你的答案: 空 (错误)

```cpp
5678
```

```cpp
678
```

```cpp
编译错误
```

```cpp
其它选项都不对
```

本题知识点

C++工程师 360 公司 C++ 2019 C 语言

讨论

[HYC007](https://www.nowcoder.com/profile/880206970)

这题答案错了，应该是 printf("%s",ptr); 没有*否则运行 sigv 了。

发表于 2021-06-16 10:17:06

* * *

[牛客 478523368 号](https://www.nowcoder.com/profile/478523368)

```cpp
#include<stdio.h>

int main()
{
char *ptr;
char arr[] = "12345678";
ptr = arr;
ptr += 5;
printf("%s\n",&*ptr);
return 0;
}

正解指针 ptr 取地址才是 678
```

发表于 2021-06-07 15:06:04

* * *

[觉灵](https://www.nowcoder.com/profile/716278566)

char 型指针从 0 开始移动 5 位，所以+5 以后指针指在 6 的位置，输出为 678

发表于 2019-12-16 16:38:32

* * *

## 20

下面代码的输出（）

```cpp
int main() {
    int a[5]  = {1, 2, 3, 4, 5};
    int *ptr = (int*)(&a + 1);
    printf("%d, %d", *(a + 1), *(ptr - 1));
    return 0;
}
```

正确答案: D   你的答案: 空 (错误)

```cpp
1, 1
```

```cpp
1, 3
```

```cpp
3, 3
```

```cpp
2, 5
```

本题知识点

C++工程师 360 公司 C++ 2019 C 语言

讨论

[加油，offer！](https://www.nowcoder.com/profile/59083990)

int a[5];(&a + 1) 与 （a + 1）的区别：&a 是代表数组的地址， 数组的内存是 5*size(int) 。 因此&a + 1 是对数组整块内存加 1，  即 &a + 5*size(int)。a 代表数组首元素的地址，  数组首元素的大小为 size(int)，    因此 a+1 是对整个数组的内存加 1， 即 a + size(int)。总结， &a,a 分别是数组的地址、数组首元素的地址， +1 是即  数组首元素的内存加 1 。一张图解释：![](img/1d7591028a7221db4f4fec84a604a17e.png)

发表于 2019-11-21 15:17:17

* * *

[闲 C 工作室](https://www.nowcoder.com/profile/423376092)

 &a + 1: 取数组 a 的首地址，该地址的值加上 sizeof(a) 的值，即&a + 5*sizeof(int)，也
就是下一个数组的首地址，显然当前指针已经越过了数组的界限。
(int *)(&a+1): 则是把上一步计算出来的地址，强制转换为 int * 类型，赋值给 ptr。
*(a+1): a,&a 的值是一样的，但意思不一样，a 是数组首元素的首地址，也就是 a[0]的
首地址，&a 是数组的首地址，a+1 是数组下一元素的首地址，即 a[1]的首地址,&a+1 是下一
个数组的首地址。所以输出 2
*(ptr-1): 因为 ptr 是指向 a[5]，并且 ptr 是 int * 类型，所以*(ptr-1) 是指向 a[4] ，
输出 5。

发表于 2019-08-20 16:42:52

* * *

[一个啥也不会的研究生](https://www.nowcoder.com/profile/60177298)

*a 指的是数组首元素的首地址即 a[0]的首地址； 而 &a 指的是数组的首地址*

则例子中的（&a + 1）就是取数组 a 的首地址，该地址的值再加上 sizzeof(a) 的值， 即就是 &a + sizeof(int) * 5,也就是下一个数组的首地址，显然这里已经超过了数组的界限。

（a + 1）是指数组的首元素 a[0] 的 下一个元素的首地址即 a[1]的首地址。因此 *(a + 1) 的输出结果是 2\.

因为 ptr 指向的是 a[5], 并且 ptr 是 int * 类型的，所以 （ptr - 1）指向的就是 a[4], 因此*(ptr - 1) 的输出就为 5\.

发表于 2021-01-06 22:39:48

* * *

## 21

下面程序输出为（）

```cpp
#include <stdio.h>
int fun(int a) {
    int b = 0;
    static int c = 3;
    b++;
    c++;
    return (a+b+c);
}

int main( ) {
    int i=0;
    for(; i < 3; i++)
        printf("%d",fun(2));
    return 0;
}
```

正确答案: B   你的答案: 空 (错误)

```cpp
777
```

```cpp
789
```

```cpp
7911
```

```cpp
71320
```

本题知识点

C++工程师 360 公司 C++ 2019 C 语言

讨论

[你的名字真好记](https://www.nowcoder.com/profile/983403328)

注意题目中的 static 关键字，声明静态局部变量时该局部变量会暂时保存到内存的静态区（所以即使这个函数运行结 束，这个静态变量的值还是不会被销毁，函数下次使用时仍然能用到这个值）；理解了这个知识点，就不难得出 789 的结果了。欢迎讨论

发表于 2019-10-18 15:37:55

* * *

[黄昏 BY7](https://www.nowcoder.com/profile/643252961)

static 是静态变量声明，这个关键字会让 c 保存上一次调用的值，而 b 不会保存，每一次调用都是 1，所以如下: 第一次调用 c 等于 4，a+b+c=2+1+4=7 第二次调用 c 等于 5，a+b+c=2+1+5=8 第二次调用 c 等于 6，a+b+c=2+1+6=9 答案为 789

编辑于 2021-10-02 13:24:47

* * *

[抬棺不专业](https://www.nowcoder.com/profile/512896410)

这道题四个选项都是错的，答案应该是 2 和 5，2 应该没有人有疑问。

5 是怎么得来的？很简单，&a+1 对数组名取址是一下子对整个数组进行加 1，即是 a［4］的下一个元素地址，这个时候再减 1 取值就是 a［4］的值即 5 了

发表于 2019-08-24 20:39:08

* * *

## 22

有以下类定义

```cpp
#include<iostream> 
using namespace std; 
class Clock 
{public: 
Clock(int NewH=0, int NewM=0, int NewS=0)
{Hour=NewH; Minute=NewM;Second=NewS;}
void ShowTime()
{cout<<Hour<<":"<<Minute<<":"<<Second;}
Clock  operator ++(); 
private: 
int Hour, Minute, Second;};
Clock Clock::operator ++() 
{ Second++;
if(Second>=60)
{   Second=Second-60;
Minute++;
if(Minute>=60)
{
Minute=Minute-60;
Hour++;
Hour=Hour%24;}}
return ________;}
int main()
{   Clock c1;
(++c1).ShowTime();
return 0;}
```

请为横线处选择合适的程序使得程序的运行结果是 0:0:1 （      ）

正确答案: B   你的答案: 空 (错误)

```cpp
c1
```

```cpp
*this
```

```cpp
Clock
```

```cpp
this
```

本题知识点

C++工程师 360 公司 C++ C++工程师 360 公司 2019

讨论

[未阳ヾ](https://www.nowcoder.com/profile/555564119)

不懂求大神

发表于 2019-08-28 00:19:06

* * *

[KobayakawaSena](https://www.nowcoder.com/profile/629978717)

运算符重载，非静态成员函数调用的时候会保存调用对象的指针 this,因为是 clock c1，是个对象而不是指针，所以返回 this 对象即可

发表于 2019-10-30 20:54:52

* * *

[s1lence](https://www.nowcoder.com/profile/515042794)

1.Clock c1;  //声明对象，调用默认构造函数，Hour, Minute, Second 被初始化为 0；2.Clock  operator ++();    //对++进行运算符重载，功能是对 Second 加 1，并更新 Hour, Minute, Second3.运算符重载实现中，只要返回当前对象就可以了

发表于 2019-09-20 22:15:43

* * *

## 23

有下列类定义

```cpp
#include<iostream>
using namespace std;
class Point {
public:
    Point(int a=3,int b=5){ X=a;Y=b;}
    int GetX(){return X;}
    int GetY(){return Y;}
private:
    int  X,Y;
};
```

现有语句 Point *p=new Point[2];则与(*p).GetX()等效的表达式是（      ）？

正确答案: B C   你的答案: 空 (错误)

```cpp
Point[0]. GetX()
```

```cpp
p[0].GetX()
```

```cpp
p->GetX()
```

```cpp
GetX()
```

本题知识点

C++工程师 360 公司 C++ 2019

讨论

[我的天鸭](https://www.nowcoder.com/profile/243498)

注意 Point 不是数组名，别错选了 A

发表于 2019-08-19 19:42:47

* * *

[Room_Aimoer](https://www.nowcoder.com/profile/130225889)

p->GetX()p[0].GetX()(*p).GetX()

发表于 2020-01-28 12:00:24

* * *

[Lilies](https://www.nowcoder.com/profile/751760549)

->主要用于类类型的指针访问类的成员

.主要用于类类型的对象访问类的成员

发表于 2020-03-20 16:50:23

* * *

## 24

print 函数声明为 void print(int a,char b='b',int c=1); 下面函数调用正确的是（）

正确答案: A B C D   你的答案: 空 (错误)

```cpp
print('a');
```

```cpp
print(5,8);
```

```cpp
print(5,'#');
```

```cpp
print(5,'#',2);
```

本题知识点

C++工程师 360 公司 C++ 2019 C 语言

讨论

[paul_zyh](https://www.nowcoder.com/profile/378431629)

C++在调用函数时，当实参和形参的数据类型不一致时，会发生数据类型转换！将低精度转换为高精度时，由编译器隐式完成；将高精度转换为低精度时，必须用强制类型转换运算符：static_cast<>()来转换才不会造成数据丢失。精度由低到高: char->int->double->long double。因此 B 选项在将整数类型 8 复制给 char 时，会发生截断赋值。

发表于 2019-08-26 17:15:54

* * *

[菜鸡准备转岗](https://www.nowcoder.com/profile/836159636)

 ```cpp
CD 毫无疑问是对的，A 的话字符转为整数即为 97，B 整数赋值为 char，为截断赋值  把整数的前 3*8 位去掉  直接后 8 位赋值给 char 
``` 😂

发表于 2019-08-16 15:53:47

* * *

[一位不知名人士](https://www.nowcoder.com/profile/56386160)

B 发生了截断赋值， 把整数的前 3*8 位去掉  直接后 8 位赋值给 char，最后 c 为默认值。

发表于 2020-06-29 10:56:48

* * *

## 25

有以下语句定义

```cpp
int x =5;
const int * const p = &x;
const int &q=x; 
int const *next=&x;
const int *j=&x;
```

则有语法错误的是（）

正确答案: A B D   你的答案: 空 (错误)

```cpp
* p =1;
```

```cpp
q++;
```

```cpp
next++;
```

```cpp
(*j)++;
```

本题知识点

C++工程师 360 公司 C++ 2019 C 语言

讨论

[BroWuG](https://www.nowcoder.com/profile/297231019)

答案:ABD
A. `const int * const p = &x;`中指针 p 及 p 指向的 int 类型数据都被 const 修饰，即`*p`与`p`都为 const 属性无法修改

*   编译器报错`error: assignment of read-only location ‘*(const int*)p’ *p = 1;`
*   故`* p =1;`语法错误

B. `const int &q=x;`是指向常量的引用，使用时必须初始化，而且初始化后，引用值不可以改变,引用的常量也不能改变

*   注意 只是修饰引用`q`,`x`不受影响
*   编译器报错`error: increment of read-only reference ‘q’ q++;`
*   故`q++;`语法错误

C. `int const *next=&x;`中`const`修饰整型数 int 即`*next`

*   注意 同样只是修饰`*next`,`x`仍然是变量
*   指针变量`next`没有被 const 修饰因此可以被`next++`改变,语法正确

D. `const int *j=&x;`中`const int *`同`int const *`const 修饰`*j`

*   编译器报错`error: increment of read-only location ‘* j’ (*j)++;`
*   `(*j)`为 const 属性无法修改,故语法错误

发表于 2019-08-19 20:46:21

* * *

[第一站](https://www.nowcoder.com/profile/460108513)

一句话搞定 const 修饰指针变量：        const 在*的左边，则指针指向的变量的值，不可直接通过指针改变（可以通过其他途径改变）；        在*的右边，则指针的指向不可变。        简记为“左定值，右定向”。

编辑于 2021-03-11 10:16:51

* * *

[201906261056657](https://www.nowcoder.com/profile/179332006)

不成熟的解析：
const int * const p = &x;对于 const p，说明 p 的值不能改变，*const p 说明 p 一个指针，int *const p,说明 p 是以指向 int 类型的指针，这时这个 int 型的指针，指向的变量(*p)是可以修改的，const int* const p,这里限制了指针指向的变量（*p）不能修改,综上所述，p 以及*p 是不可改变的
const int &q=x;
int &p=x，是起别名，这时用 const 修饰这个别名，说明变量是不改变的
int const *next=&x;这里先看*next，说明 next 是一个指针，const *next,说明指针指向的变量（*next）是不改变的，但是并限制 next 不可改变
const int *j=&x;int* j 说明是一个指针变量，但是 const 指针变量又被 const 修饰，说明*j 是不可改变的，但是 j 是可以改变的

发表于 2019-11-01 23:09:55

* * *

## 26

以下程序

```cpp
#include<iostream> 
using namespace std; 
template <typename T>
T Max(T* a, int n) { 
T max=___________;
for(int i=1;i<n;i++) 
    if(a[i]>max) max=a[i];
    return max; 
} 
int main() { 
    int a[10]={3,7,5,0,2,1,8,4,9,6},*p=a+3; 
    cout<<Max(p,7); 
    return 0; 
} 
```

运行结果是 9，请为横线处选择合适的程序（）

正确答案: A B C D   你的答案: 空 (错误)

```cpp
*a
```

```cpp
a[0]
```

```cpp
0
```

```cpp
a[3]
```

本题知识点

C++工程师 360 公司 C++ 2019 C 语言

讨论

[露西恩缇努维尔](https://www.nowcoder.com/profile/408614969)

这题就是耍流氓。`main`函数中调用的时候，`p`就指向`a`数组的第三个元素了，也就是`a[3]`了。然后进入函数，`a`指针现在就指向原数组的`a[3]`，也就是`0`值这个位置。而`for`循环中明显从 1 开始循环，暗示初始的最大值应给设置为`a[0]`，这个`a`代表`T*a`中的`a`。
`C`和`D`选项是知道整个数组所有元素的情况下才可以这样做。既然一眼就看出就知道最大值是 9，这样赋值这题还有啥意义。选 A，B 更具有通用性，即使数组元素变化了，只要长度不变就没问题。

发表于 2020-06-07 21:04:08

* * *

[宁失天下不负卿](https://www.nowcoder.com/profile/7739018)

求整形数组中元素的最大值，比较函数中的初始比较值可以是数组中任何一元素，或者是小于或等于其最大元素的某一个值（如果比较值比最大值还要大，那么并不能求出最大值）

发表于 2019-08-17 13:13:30

* * *

[杉杉来啦](https://www.nowcoder.com/profile/243827773)

注意 main 函数*p=a+3，Max 函数里面的 a 就是 p，意思是从 a 的地址从 mian 中 a[3]地址开始，函数内的 a 为 a[3]的地址，那么怎么都能取到 9 了，最大是 9，循环 6 次，但 a[3]到 a[8]=9 的距离只有 5

发表于 2020-03-06 14:39:34

* * *

## 27

有以下语句定义

```cpp
int a[2][3];
int (*p)[3]=a; 
int *q=*a;
```

则能输出 a[1][2]的值的语句是（）

正确答案: A B C   你的答案: 空 (错误)

```cpp
cout<<*(*(a+1)+2)
```

```cpp
cout<<p[1][2];
```

```cpp
cout<<*(q+5);
```

```cpp
cout<<q[1][2];
```

本题知识点

C++工程师 360 公司 C++ 2019 C 语言

讨论

[ganming](https://www.nowcoder.com/profile/997783280)

![](img/85ff4f356633192d26046aa1014c21ae.png)

发表于 2019-09-22 19:13:55

* * *

[Tianz](https://www.nowcoder.com/profile/47133793)

首先要明确好一个变量它的类型是啥？如 int a[2][3]， a 的类型是：元素类型为 int[3] 的数组

发表于 2020-02-29 11:23:46

* * *

[牛客 122023670 号](https://www.nowcoder.com/profile/122023670)

D 将指针 q 当数组来用

发表于 2021-08-04 11:17:19

* * *

## 28

下列运算符重载函数中，属于友元函数的是（）

正确答案: B C D   你的答案: 空 (错误)

```cpp
Base operator+(Base);
```

```cpp
Base operator--(Base);
```

```cpp
Base operator&&(Base, Base);
```

```cpp
Base operator++(Base,int);
```

本题知识点

C++工程师 360 公司 C++ 2019 C 语言

讨论

[黄色变白色](https://www.nowcoder.com/profile/8547911)

因为+是双目运算符，但是函数里只传了一个参数，就必然使用了 this 指针，那就肯定不是友元函数了

发表于 2019-08-18 14:47:04

* * *

[Geng1995](https://www.nowcoder.com/profile/327761991)

�   因为友元函数没有当前对象，因此要定义单目运算符，就需要单参函数，要定义双目运算符，就需要双参函数；

�   定义后置“++"或后置“--"运算是特例，它们是单目运算符，但需要两个形参，头一个形参是作用对象，后一个是 int 形参；

�   用友元函数可以定义成员函数不能实现的运算，例如一些双目运算符，右操作数是本类对象，而左操作数不是本类对象；

�   成员函数体中，当前对象作为一个操作数，无形参形式可以定义单目运算符；

发表于 2020-06-06 17:56:18

* * *

[Dreamit.](https://www.nowcoder.com/profile/561761500)

题中 B 是前置 --选项 D 是后置++

发表于 2020-05-17 15:50:08

* * *

## 29

有如下 C 语言程序

```cpp
#include  <stdio.h>
int fun(int * data) {
    *data = *data % 2;
    return (*data) + 1;
}
int main() {
    int data = 12;
    fun(&data);
    printf("%d,", data);
    data = fun(&data);
    printf("%d", data);
}
```

程序运行后的输出结果是（）

正确答案: B   你的答案: 空 (错误)

```cpp
0,0
```

```cpp
0,1
```

```cpp
1,2
```

```cpp
12,13
```

本题知识点

C++工程师 360 公司 C++ 2019 C 语言

讨论

[月、下西楼](https://www.nowcoder.com/profile/8111462)

需要注意第一个 printf 上一句代码是 fun(&data)，不是 data = fun(&data)，没有获取 fun 的返回值，所以 data 是 0，不是 1

发表于 2019-09-23 20:23:52

* * *

[李木槿 201902201512535](https://www.nowcoder.com/profile/993350448)

容易粗心犯错

发表于 2020-03-30 20:29:27

* * *

[花房陈鹿](https://www.nowcoder.com/profile/236359886)

&data 取地址，所以 fun 函数运行过后 data 的值会改变，第一次变为 0，第二次是将函数值返回付给 data，因此 0+1 等于 1.

发表于 2019-09-12 15:34:27

* * *

## 30

有下列 C 语言程序片段。将它的功能用汇编程序实现，下面 1、2、3、4 处那句话有逻辑错误
if(X>Y)
X=X-Y;
else
X=X+Y;
汇编片段为：
MOV AX, X
CMP AX,Y //1
JLE ELSE //2
ADD AX,Y //3
ELSE:
ADD AX,Y //4
OK:
MOV X, AX

正确答案: C   你的答案: 空 (错误)

```cpp
1
```

```cpp
2
```

```cpp
3
```

```cpp
4
```

本题知识点

C++工程师 360 公司 C++ C++工程师 360 公司 2019

讨论

[詹姆斯科比](https://www.nowcoder.com/profile/872649809)

ADD 一般指添加，由于 3 是减，4 是加，所以 3，4 肯定不同

发表于 2019-09-14 00:37:26

* * *

[徐晓明](https://www.nowcoder.com/profile/1308833)

此时应该是减

发表于 2019-08-21 08:38:13

* * *

## 31

有以下 C 语言程序

```cpp
#include   <stdio.h>
int fun(int  x[], int  k)
{  if(k==0) return (x[0]);
return  x[0]+fun(x+1, k-1);
}
int main()
{  int  x[ ]={1,2,3,4,5};
printf("%d\n", fun(x,3));
}
```

程序运行后的输出结果是

正确答案: C   你的答案: 空 (错误)

```cpp
3
```

```cpp
6
```

```cpp
10
```

```cpp
15
```

本题知识点

C++工程师 360 公司 C++ C++工程师 360 公司 2019

讨论

[¤201908290953951](https://www.nowcoder.com/profile/845389854)

递归 ，k==0 时执行了 3 次  x[i]移动到 x[3]值为 4  4+3+2+1

发表于 2019-09-18 19:24:06

* * *

## 32

对定义：

```cpp
void (*f)(int *, int *);
```

描述正确的是（）

正确答案: D   你的答案: 空 (错误)

```cpp
定义了函数的指针 f，f 所指函数返回指针
```

```cpp
声明了一个返回值为指针的函数 f
```

```cpp
声明了一个无返回值的函数 f
```

```cpp
定义了函数的指针 f，f 所指函数无返回值
```

本题知识点

C++工程师 360 公司 C++ 2019 C 语言

讨论

[牛客 829624841 号](https://www.nowcoder.com/profile/829624841)

函数指针是 void(*f)()() 指针函数是返回类型为指针的函数(void*)f()()

发表于 2021-10-30 17:29:43

* * *

[Room_Aimoer](https://www.nowcoder.com/profile/130225889)

函数指针，返回值 void 类型

发表于 2019-10-16 15:17:32

* * *

[AmazingPro](https://www.nowcoder.com/profile/436835463)

D，void 表示无返回值，*f 代表指针，后面的（int* int*）可以理解为函数的后半部分。所以 D

发表于 2019-11-23 13:17:06

* * *

## 33

如果强调一系列相关产品的接口，以便联合使用它们的时候，应该选择何种设计模式：

正确答案: C   你的答案: 空 (错误)

```cpp
模板方法模式
```

```cpp
备忘录模式
```

```cpp
抽象工厂模式
```

```cpp
组合模式
```

本题知识点

C++工程师 360 公司 Java 工程师 测试工程师 设计模式 2019 测试开发工程师

讨论

[每天都说我是过儿](https://www.nowcoder.com/profile/285342323)

A.模版模式：定义一个算法结构，而将一些步骤延迟到子类去实现

B.备忘录模式：在不破坏封装的前提下，保持对象的内部状态

C.抽象工厂：创建相关或依赖对象的家族，而无需指明具体类

D.组合模式：将对象组合成树形结构以表示部分和整体的层次结构

发表于 2018-12-28 09:33:25

* * *

[闲鱼总算翻了身](https://www.nowcoder.com/profile/909589300)

抽象工厂一般针对产品家族，工厂方法一般针对具体产品；工厂方法只是把对象的实例化延迟到子类

发表于 2021-07-31 13:46:21

* * *

## 34

如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变，应该使用何种设计模式：

正确答案: B   你的答案: 空 (错误)

```cpp
职责链模式
```

```cpp
观察者模式
```

```cpp
模板方法模式
```

```cpp
策略模式
```

本题知识点

C++工程师 360 公司 Java 工程师 测试工程师 设计模式 2019 测试开发工程师

讨论

[已注销](https://www.nowcoder.com/profile/7558628)

> 观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

发表于 2018-12-26 20:13:27

* * *

[蒋朴](https://www.nowcoder.com/profile/674056035)

观察者模式：定义对象之间的一种一对多的关系，当一个对象发生改变时，其他依赖于该对象的对象也会被通知自动改变

发表于 2020-08-22 13:24:08

* * *

[如你所愿。](https://www.nowcoder.com/profile/36902960)

观察者，一个变动其他的更着作出对应的处理

发表于 2021-12-13 06:17:02

* * *

## 35

设计模式在实际程序设计过程中应用很广泛，例如微软著名的 MFC 框架就广泛的使用了模板模式，而浏览器、office 等插件开发基本上都使用了策略模式，下面关于模板模式和策略模式说明错误的是（  ）。

正确答案: D   你的答案: 空 (错误)

```cpp
策略模式和模板模式在某些应用场景下可以互换。
```

```cpp
模板模式使用的是继承关系实现，策略模式使用的是组合关系实现。
```

```cpp
模板模式倾向于把解决问题过程定义为一个完整框架，把过程中的若干实现步骤延迟到子类中实现。
```

```cpp
策略模式倾向于把解决问题的算法定义为一个接口，把解决问题的具体过程通过继承的方式封装起来
```

本题知识点

C++工程师 360 公司 Java 工程师 测试工程师 设计模式 2019 测试开发工程师

讨论

[愚人五个字](https://www.nowcoder.com/profile/963871720)

策略模式（Strategy）-定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

发表于 2019-01-09 20:40:46

* * *

[Exupery](https://www.nowcoder.com/profile/8461692)

策略模式使用组合关系实现，通过注入的方式在客户端传入一个具体策略对象。

发表于 2020-03-13 10:17:49

* * *

[如你所愿。](https://www.nowcoder.com/profile/36902960)

策略模式中与接口不是继承，是实现

发表于 2021-11-09 04:09:10

* * *

## 36

公司门户网站随着访问用户增加需要扩展服务器数量,每台服务器在 DNS 配置时，域名与主机相同，为达到负载均衡，DNS 服务器需要开启（      ）

正确答案: C   你的答案: 空 (错误)

```cpp
智能解析
```

```cpp
顺序解析
```

```cpp
启用循环
```

```cpp
反复解析
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 网络基础 2019 系统工程师 测试开发工程师

讨论

[飞鸿踏雪泥 9975](https://www.nowcoder.com/profile/6799891)

DNS 负载均衡是通过循环复用实现的，如果发现[主机名](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA%E5%90%8D/2836107)的多个地址[资源记录](https://baike.baidu.com/item/%E8%B5%84%E6%BA%90%E8%AE%B0%E5%BD%95/6024505)，则可用它循环使用包含在查询应答中的主机资源记录。

发表于 2019-08-14 17:39:45

* * *

[青简](https://www.nowcoder.com/profile/708069809)

DNS 负载均衡是通过循环复用实现的，如果发现主机名的多个地址资源记录，则可用它循环使用包含在查询应答中的主机资源记录

发表于 2019-09-26 16:34:22

* * *

[燎原之火🔱](https://www.nowcoder.com/profile/3633297)

一题通用，程序员这些都应该知道🤐

发表于 2019-01-08 09:44:52

* * *

## 37

IP 数据报的收发方进行跨网投递时，发送方需利用 ARP 协议获取哪些信息（      ）

正确答案: B   你的答案: 空 (错误)

```cpp
接收方 IP 地址的 MAC 地址
```

```cpp
发送方本网段路由器对应端口的 MAC 地址
```

```cpp
接收方本网段路由器对应端口的 MAC 地址
```

```cpp
发送方 IP 地址的 MAC 地址
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 网络基础 2019 系统工程师 测试开发工程师

讨论

[今晚我要学习](https://www.nowcoder.com/profile/5068973)

题目是“收发方跨网投递”。ARP 能获得下一跳主机的 MAC 地址，这看起来像是接收方，然而并不是，接收方可能还很远，我们所获得的仅仅是 B 项描述的：

*   ```cpp
    发送方本网段路由器对应端口的 MAC 地址
    ```

这个端口 MAC 地址可能是已经缓存的，也可能是通过广播获取的。

编辑于 2019-04-03 17:53:48

* * *

[罗蜜斯丹](https://www.nowcoder.com/profile/1812648)

发送方要知道接收方的 IP 地址即可，在路由器中可用 ARP 协议找到接受发的 MAC 地址。所以发送方不关心接收方的 MAC 地址，但发送前要填上自己的 MAC 地址

发表于 2019-02-28 16:22:16

* * *

[牛客 238647254 号](https://www.nowcoder.com/profile/238647254)

因为是"跨网段", 所以 ARP 管不了, 它只能告诉"发送方"怎么从本网段出去. 

发表于 2022-01-25 00:02:41

* * *

## 38

SNMP 协议利用（      ）协议实现管理者与 SNMP 代理之间的信息交互

正确答案: A   你的答案: 空 (错误)

```cpp
UDP
```

```cpp
TCP
```

```cpp
ARP
```

```cpp
ICMP
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 网络基础 2019 系统工程师 测试开发工程师

讨论

[雨*-*](https://www.nowcoder.com/profile/602147864)

TCP 支持的应用协议：TELNET（远程终端登录协议）,FTP（文件传输协议）,SMTP（简单邮件传送协议）,HTTP（传送协议）UDP 支持的应用协议：NFS(网络文件系统)，SNMP（简单网络管理协议），DNS（域名服务），TFTP（简单文件传输协议）

发表于 2019-08-27 10:57:40

* * *

[飞鸿踏雪泥 9975](https://www.nowcoder.com/profile/6799891)

SNMP 采用 UDP 协议在管理端和 agent 之间传输信息。 SNMP 采用 UDP 161 端口接收和发送请求，162 端口接收 trap，执行 SNMP 的设备缺省都必须采用这些端口。SNMP 消息全部通过 UDP 端口 161 接收，只有 Trap 信息采用 UDP 端口 162。

发表于 2019-08-14 17:41:34

* * *

[Lane.](https://www.nowcoder.com/profile/849834097)

简单网络管理协议（SNMP） 是专门设计用于在 IP 网络管理网络节点（服务器、工作站、路由器、交换机及 HUBS 等）的一种标准协议，它是一种应用层协议。

发表于 2019-10-30 10:49:01

* * *

## 39

公司办公室,技术部,开发部,销售部的网络地址分别为 172.16.32.0/24,172.16.33.0/24,172.16.34.0/24,172.16.35.0/24;网络中心进行地址聚合,聚合后覆盖四个部门的网络地址是（      ）

正确答案: C   你的答案: 空 (错误)

```cpp
172.16.32.0/24
```

```cpp
172.16.32.0/23
```

```cpp
172.16.32.0/22
```

```cpp
172.16.32.0/21
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 网络基础 2019 系统工程师 测试开发工程师

讨论

[梅梅 201803241656278](https://www.nowcoder.com/profile/1728579)

每个小数点之间由八位二进制表示，最后的 24 表示前 24 位为网络号，主机号=32-网络号网络地址聚合就是取最大相同的部分。172.16.32.0/24：相同.相同.00010000（32）.不管 172.16.33.0/24：相同.相同.00010001（33）.不管 172.16.34.0/24：相同.相同.00010010（34）.不管 172.16.35.0/24：相同.相同.00010011（35）.不管取最大相同：172.16.000100|不同.不管(|之前为聚合网络地址:16+6=22 位)即表示为：172.16.32.0/22

发表于 2018-12-29 15:49:35

* * *

[千纸鹤千颗心](https://www.nowcoder.com/profile/711830961)

|24 表示前面 24 位相同的作为网络号，而四者取最大相同部分是前面 22 位，因此选择|22.

发表于 2019-04-24 11:27:54

* * *

[飞鸿踏雪泥 9975](https://www.nowcoder.com/profile/6799891)

聚合网络地址：取网络地址的最大相同部分

发表于 2019-08-14 17:44:14

* * *

## 40

数据链路层可以提供哪些服务类型（      ）

正确答案: A B C   你的答案: 空 (错误)

```cpp
无确认的无连接服务
```

```cpp
有确认的无连接服务
```

```cpp
有确认的有连接服务
```

```cpp
无确认的有连接服务
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 网络基础 2019 系统工程师 测试开发工程师

讨论

[barbo](https://www.nowcoder.com/profile/7171527)

只要记住，有连接的一定要确认

发表于 2019-08-15 16:39:59

* * *

[愚人五个字](https://www.nowcoder.com/profile/963871720)

数据链路层一般都提供 3 种基本服务，即无确认的无连接服务、有确认的无连接服务、有确认 的面向连接的服务。 （1）无确认的无连接服务 无确认的无连接服务是源机器向目的机器发送独立的帧，而目的机器对收到的帧不作确认。 如果由于线路上的噪声而造成帧丢失，数据链路层不作努力去恢复它，恢复工作留给上层去完成。 这类服务适用于误码率很低的情况，也适用于像语音之类的实时传输，实时传输情况下有时数据延误比数据损坏影响更严重。 大多数局域网在数据链路层都使用无确认的无连接服务。 （2）有确认的无连接服务 这种服务仍然不建立连接，但是所发送的每一帧都进行单独确认。 以这种方式，发送方就会知道帧是否正确地到达。如果在某个确定的时间间隔内，帧没有到达，就必须重新发此帧。 （3）有确认的面向连接的服务 采用这种服务，源机器和目的机器在传递任何数据之前，先建立一条连接。 在这条连接上所发送的每一帧都被编上号，数据链路层保证所发送的每一帧都确实已收到。 而且，它保证每帧只收到一次，所有的帧都是按正确顺序收到的。面向连接的服务为网络进程间提供了可靠地传送比特流的服务。

发表于 2019-01-09 20:50:18

* * *

## 41

STP 协议可以实现的功能是（      ）

正确答案: B C   你的答案: 空 (错误)

```cpp
隔离冲突域
```

```cpp
防止广播风暴
```

```cpp
防止环路
```

```cpp
提供可靠传输
```

本题知识点

360 公司 Java 工程师 网络基础 2019

讨论

[远山淡影](https://www.nowcoder.com/profile/929506490)

STP（生成树协议）的原理是按照树的结构来构造网络拓扑，消除网络中的环路，避免由于环路的存在而造成广播风暴问题。

发表于 2019-03-06 10:22:18

* * *

[tru-th](https://www.nowcoder.com/profile/4137824)

生成树协议 STP： 工作在数据链路层的透明网桥使用的算法，可以防止环路，防止因环路而产生的广播风暴

发表于 2020-04-20 20:06:53

* * *

[暮秋柒](https://www.nowcoder.com/profile/923002302)

Spanning Tree Protocol 生成树协议

发表于 2019-11-21 10:18:26

* * *

## 42

公司内部为 100Mbps 的企业网,办公室计算机从网络中心下载 25M 的文件,在没有流量控制与无干扰的情况下,大概需要的时间为（      ）

正确答案: C   你的答案: 空 (错误)

```cpp
0.5 秒
```

```cpp
1 秒
```

```cpp
2 秒
```

```cpp
4 秒
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 网络基础 2019 系统工程师 测试开发工程师

讨论

[He110](https://www.nowcoder.com/profile/6472986)

100 Mbps 是按 bit 传输的，所以需要转化为 byte 的传输速度，需要除以 8，即下载速度是 12.5Mb/s，所以需要 2 秒

发表于 2018-12-27 13:04:59

* * *

[sjh123](https://www.nowcoder.com/profile/272256735)

评论里面有些老哥理解错了（虽然答案对的）25M 文件（25MB）的 M 是 1024100Mbps 的 M 是 1000 所以不能直接用 Mb 来除以 Mbps    而是要全部都转化为 b 或 bps25M:25*1024*1024*8 b100Mbps:100*1000*1000 bps 两者相除≈2

编辑于 2020-05-21 20:44:09

* * *

[桔子 201908231619240](https://www.nowcoder.com/profile/953034402)

25Mbyte=25*1024*1024*8 理想时间=(25*1024*1024*1024*8)/ (100 000 000)=2.097152s

发表于 2019-09-19 17:37:55

* * *

## 43

运行哪个协议后可用避免交换机之间存在的环路（      ）

正确答案: A   你的答案: 空 (错误)

```cpp
STP
```

```cpp
RIP
```

```cpp
OSPF
```

```cpp
ARP
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 网络基础 2019 系统工程师 测试开发工程师

讨论

[呆瓜 201903132237485](https://www.nowcoder.com/profile/625376940)

STP（生成树协议）：是按照树的结构来构造网络拓扑，消除网络中的环路，避免由于环路的存在而造成广播风暴问题。

发表于 2019-08-21 16:21:11

* * *

[tru-th](https://www.nowcoder.com/profile/4137824)

&

STP：生成树协议；透明网桥使整个连通网络不存在回路；P99

RIP：路由信息协议；一种分布式的基于距离向量的路由选择协议；P152

OSPF：开放最短路径优先；使用分布式的链路状态协议；P157

ARP：地址解析协议

内部网关协议 IGP：RIP+OSPF ；P151

外部网关协议 EGP：BGP-4

发表于 2020-04-20 10:40:54

* * *

[暮秋柒](https://www.nowcoder.com/profile/923002302)

spanning tree protocol 生成树协议

发表于 2019-12-05 14:51:21

* * *

## 44

有关树的说法正确的是（      ）

正确答案: A C   你的答案: 空 (错误)

```cpp
树中所有结点可以有 0 个或多个后继结点
```

```cpp
二叉树中至少有一个结点的度为 2
```

```cpp
在 AVL 树中根节点的左右子树的深度最多相差 1
```

```cpp
Huffman 树一定是 AVL 树
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 树 2019 系统工程师 测试开发工程师

讨论

[养鱼的小白莲](https://www.nowcoder.com/profile/76251842)

哈夫曼树只是一棵最优二叉树，不一定是完全二叉树，也不一定是平衡二叉树哈夫曼树不关注树的结构，只关注带权路径长度

发表于 2019-08-23 10:29:04

* * *

[远山淡影](https://www.nowcoder.com/profile/929506490)

B 选项：单支二叉树节点度不为 2

发表于 2019-03-06 10:19:42

* * *

[Isoon](https://www.nowcoder.com/profile/628327468)

不是，A 选项语言表述就有问题吧？

发表于 2020-03-23 23:59:37

* * *

## 45

在 AVL 树中，哪个调整操作可以使根节点的平衡因子由 1 变为 2（      ）

正确答案: A C   你的答案: 空 (错误)

```cpp
LL
```

```cpp
RR
```

```cpp
LR
```

```cpp
RL
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 树 2019 系统工程师 测试开发工程师

讨论

[梅梅 201803241656278](https://www.nowcoder.com/profile/1728579)

有四种种情况可能导致二叉查找树不平衡，分别为：

（1）LL：插入一个新节点到根节点的左子树（Left）的左子树（Left），导致根节点的平衡因子由 1 变为 2

（2）RR：插入一个新节点到根节点的右子树（Right）的右子树（Right），导致根节点的平衡因子由-1 变为-2

（3）LR：插入一个新节点到根节点的左子树（Left）的右子树（Right），导致根节点的平衡因子由 1 变为 2

（4）RL：插入一个新节点到根节点的右子树（Right）的左子树（Left），导致根节点的平衡因子由-1 变为-2

针对四种种情况可能导致的不平衡，可以通过旋转使之变平衡。有两种基本的旋转：

（1）左旋转：将根节点旋转到（根节点的）右孩子的左孩子位置

（2）右旋转：将根节点旋转到（根节点的）左孩子的右孩子位置
--------------------- 
作者：披靡 
来源：CSDN 
原文：[`blog.csdn.net/xomlee/article/details/17628681`](https://blog.csdn.net/xomlee/article/details/17628681) 

发表于 2018-12-29 16:08:05

* * *

[罗蜜斯丹](https://www.nowcoder.com/profile/1812648)

插在根节点的左子树即可；平衡因子 = 左子树高度-右子树高度

发表于 2019-02-28 17:48:34

* * *

[August-us2020](https://www.nowcoder.com/profile/2284237)

据我所知，调整不是为了减少平衡因子，怎么还能够增大的？？？？？？

发表于 2020-03-24 13:52:37

* * *

## 46

依次将关键字序列 7, 6, 4, 10, 8, 11 插入到一棵空的平衡二叉树中，插入后的平衡二叉树的根结点为（      ）

正确答案: D   你的答案: 空 (错误)

```cpp
7
```

```cpp
6
```

```cpp
10
```

```cpp
8
```

本题知识点

360 公司 树 2019

讨论

[蹲一大把的 offer](https://www.nowcoder.com/profile/515070749)

平衡二叉树：是一种特殊的二叉排序树，其左右子树都是平衡二叉树，要求 BF（平衡因子=其左子树高-其右子树高）只能取 0，1，-1\.![](img/f49dea5288217868bede844520013d8b.png)

发表于 2019-08-16 20:44:55

* * *

[梅梅 201803241656278](https://www.nowcoder.com/profile/1728579)

在草稿纸上按 7, 6, 4, 10, 8, 11 的顺序插入要求：左<根<右且高度差不能大于 1(不符合要求就调正树)根节点变化为 7->6->8

发表于 2018-12-29 16:22:57

* * *

[牛客 583481012 号](https://www.nowcoder.com/profile/583481012)

平衡二叉树一定是二叉排序树吗？

发表于 2021-01-11 13:12:22

* * *

## 47

已知最大堆的关键字序列为 93,72,48,53,45,30,18,36,15,35，删除关键字 72，调整后得。到的最大堆是（      ）

正确答案: A   你的答案: 空 (错误)

```cpp
93,53,48,36,45,30,18,35,15
```

```cpp
93,48,53,36,45,30,18,35,15
```

```cpp
93,53,48,45,30,36,18,35,15
```

```cpp
93,53,48,45,30,36,35,18,15
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 堆 2019 系统工程师 测试开发工程师

讨论

[小码农 _ 婷婷](https://www.nowcoder.com/profile/6094983)

![](img/5505d070619b64f58d99a3bce4031efa.png)![](img/55ff4c7a71a84b2fb20b497e43861d35.png "点击并拖拽以移动")

1>将要删除的节点与最后一个节点进行交换

2>调整堆成为大顶堆或小顶堆

发表于 2020-03-23 16:21:21

* * *

[NoOfferException](https://www.nowcoder.com/profile/1554976)

删除是将被删除元素和队列最后一个元素进行交换。。。。。。。

发表于 2019-09-26 17:33:55

* * *

[梅梅 201803241656278](https://www.nowcoder.com/profile/1728579)

顺序按层次遍历删除前：               93               |  \                   72  48              | \     |  \
           53 45 30 18
           |  \    \
        36 15  35
删除 72 后：               93               |  \                   53  48              | \     |  \
           36 45 30 18
            | \
         35  15

发表于 2018-12-29 16:56:32

* * *

## 48

产生哈希冲突的影响因素有哪些（      ）  

正确答案: A B D   你的答案: 空 (错误)

```cpp
装填因子
```

```cpp
哈希函数
```

```cpp
哈希表长
```

```cpp
处理冲突的方法
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 哈希 *2019 系统工程师 测试开发工程师* *讨论

[寒月照三更](https://www.nowcoder.com/profile/122796058)

表长对冲突的影响，是受装填因子制约的。表再长，装得满满的，就会容易冲突。

发表于 2019-10-16 17:34:25

* * *

[烬天玉藻前](https://www.nowcoder.com/profile/195480900)

C 选项哈希表长不能算：装填因子 = 数据总数 / 哈希表长是数据总数 / 哈希表长的结果(装填因子)对冲突的产生有影响。想到了高中物理的选择题考公式经常这么来，问哪一个参数对结果有影响(记不太清了，忽略这行)

发表于 2020-08-21 22:22:46

* * *

[法克瓜](https://www.nowcoder.com/profile/598273059)

不是应该哈希表越长越不容易产生冲突嘛？

发表于 2019-02-07 23:44:57

* * *

## 49

设哈希表长为 8，哈希函数为 Hash (key)=key%7。初始记录关键字序列为(32，24，15，27，20，13)，用链地址法作为解决冲突方法的平均查找长度是（      ）

正确答案: B   你的答案: 空 (错误)

```cpp
1.4
```

```cpp
1.5
```

```cpp
1.6
```

```cpp
1.7
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 哈希 *2019 系统工程师 测试开发工程师* *讨论

[梅梅 201803241656278](https://www.nowcoder.com/profile/1728579)

链地址法作为解决冲突方法：冲突以后变成链表，查询次数增加
32%7=4（查一次）24%7=3（查一次）15%7=1（查一次）27%7=6（查一次）20%7=6（查两次）13%7=6（查三次）
ASL=(1*4+2*1+3*1)/6=1.5

发表于 2018-12-29 17:21:03

* * *

[白起丶](https://www.nowcoder.com/profile/815173790)

哈希表长度为 8，故存储的位置分别是 0、1、2、3、4、5、6、7\.根据哈希函数，可以得到关键字序列(32，24，15，27，20，13)存储的位置分别为：4、3、1、6、6、6\.解决冲突的方式是链地址法，故 20 和 13 存储在 27 的下边，三者构成一个链表结构，第一个元素为 27，最后一个元素为 13\.哈希表中查找一个元素的复杂度为 O（1）,故 32、24、15、27 分别查找一次即可找到，而 20 和 13 在链表结构中，需要从 27 开始往下遍历，分别需要额外的一次和两次才能找到，即 20 需要两次，13 需要三次。故最终的平均查找长度为总查询次数 / 关键字个数=（1+1+1+1+2+3）/ 6 = 1.5

编辑于 2020-07-12 11:33:37

* * *

## 50

对字符串 "mabnmnm" 的二进制进行哈夫曼编码有多少位（）

正确答案: B   你的答案: 空 (错误)

```cpp
12
```

```cpp
13
```

```cpp
14
```

```cpp
15
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 字符串 *2019 系统工程师 测试开发工程师* *讨论

[彦祖丶](https://www.nowcoder.com/profile/4900747)

![](img/56507a1ba2c4716f1ae0a5ff683fd14f.png)

发表于 2019-09-21 11:26:33

* * *

[梅梅 201803241656278](https://www.nowcoder.com/profile/1728579)

mabnmnm 频率 m:3/7 a:1/7 b:1/7 n:2/7（频率越高离根越近）建树（o 只占位，|表示 0 ，\表示 1）:            o            |\ m  o |\ n  o |\ a  b 由|,\转为 0,1 得:m->0,n->10,a->110,b->111mabnmnm:0 110 111 10 0 10 0(共 13 位)

发表于 2018-12-29 18:38:36

* * *

[Amo-wintercs](https://www.nowcoder.com/profile/444653760)

![](img/a34fc0ca5a7f7191535e2e2739064a7f.png)tip：当两个数相同时，无论放在左子树或者右子树，其 WPL 值是一样的，并不影响编码的长度，只是对应字符编码的值互换了而已。

发表于 2021-03-17 11:53:11

* * *

## 51

在哈夫曼树中，结点的度可能为（      ）

正确答案: A C   你的答案: 空 (错误)

```cpp
0
```

```cpp
1
```

```cpp
2
```

```cpp
3
```

本题知识点

360 公司 树 2019

讨论

[你的 offer 对我打了烊](https://www.nowcoder.com/profile/598309941)

哈夫曼必须要有两个节点构建一个新的虚拟的父节点吧！毫无疑问这个父节点度为 2，最初构建父节点的两个节点肯定是叶子节点，度为 0

发表于 2020-03-20 14:29:59

* * *

[Why81](https://www.nowcoder.com/profile/1187918)

度，分为 出度 和 入度 ，难道不是  B, C, D 吗？

发表于 2019-02-20 16:33:24

* * *

[_CHENDavid](https://www.nowcoder.com/profile/564273691)

题目更严紧一些的话，应该指明是几叉的霍夫曼树。虽然大部分情况默认 2 叉。

发表于 2020-08-16 16:02:00

* * *

## 44

有关树的说法正确的是（      ）

正确答案: A C   你的答案: 空 (错误)

```cpp
树中所有结点可以有 0 个或多个后继结点
```

```cpp
二叉树中至少有一个结点的度为 2
```

```cpp
在 AVL 树中根节点的左右子树的深度最多相差 1
```

```cpp
Huffman 树一定是 AVL 树
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 树 2019 系统工程师 测试开发工程师

讨论

[养鱼的小白莲](https://www.nowcoder.com/profile/76251842)

哈夫曼树只是一棵最优二叉树，不一定是完全二叉树，也不一定是平衡二叉树哈夫曼树不关注树的结构，只关注带权路径长度

发表于 2019-08-23 10:29:04

* * *

[远山淡影](https://www.nowcoder.com/profile/929506490)

B 选项：单支二叉树节点度不为 2

发表于 2019-03-06 10:19:42

* * *

[Isoon](https://www.nowcoder.com/profile/628327468)

不是，A 选项语言表述就有问题吧？

发表于 2020-03-23 23:59:37

* * *

## 53

对关键码集合 K={22，11，38，68，43，6，10，48},用筛选法创建最小堆时，从关键码（      ）开始调整

正确答案: C   你的答案: 空 (错误)

```cpp
22
```

```cpp
38
```

```cpp
68
```

```cpp
48
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 堆 2019 系统工程师 测试开发工程师

讨论

[everythingisok](https://www.nowcoder.com/profile/725453269)

                                  22                                /       \                             11        38                           /     \      /    \                        68     43  6    10                       /                     48              从下往上，从右到左的顺序，从第一个非叶结点开始调整

发表于 2020-05-26 16:41:56

* * *

[梅梅 201803241656278](https://www.nowcoder.com/profile/1728579)

筛选法就是开始按现有的顺序从上到下，从左到右放到一个完全二叉树里面。
然后把这个树调节成堆。调节的时候从最后一个有儿子的节点开始。 也就是从下往上，从右往左找，找到的第一个有孩子的节点开始。依次把各个节点及下面的孩子组成的树调节成堆。筛选法建堆例子(侵删)：![](img/2ac6a90f937fa270295e99c773befc84.png) 至于本题，打扰了。

发表于 2018-12-29 19:10:55

* * *

[codeDonald](https://www.nowcoder.com/profile/652765175)

68 就是上面说的从上到下排树，从下到上找第一个有叶子节点的节点

发表于 2019-04-23 20:22:07

* * *

## 54

已知有向图 G=(V,E)，其中 V={a,b,c,d,e,f,g}，
E={<a,b>,<a,c>,<a,d>,<b,e>,<c,e>,<c,f>,<d,f>,<e,g>,<f,g>}G 的拓扑序列是（      ）

正确答案: A   你的答案: 空 (错误)

```cpp
a,c,d,f,b,e,g
```

```cpp
a,c,b,f,d,e,g
```

```cpp
a,c,d,e,b,f,g
```

```cpp
a,b,e,c,d,f,g
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 图 2019 系统工程师 测试开发工程师

讨论

[梅梅 201803241656278](https://www.nowcoder.com/profile/1728579)

拓扑序列是顶点活动网中将活动按发生的先后次序进行的一种排列。该排列满足：如果图中有一条从 u 到 v 的路径，则顶点 v 必须出现在顶点 u 之后。找出顶点活动网中的拓扑序列称“拓扑排序”。画图后对照选项 B：f 需 c、d 发生后才能发生 C：e 需 b、c 发生后才能发生 D：同 C

发表于 2018-12-29 19:25:00

* * *

[白起丶](https://www.nowcoder.com/profile/815173790)

拓扑结构：

1.  选择一个入度为 0 的顶点输出；
2.  然后删除此顶点，并删除以此顶点为尾的弧；
3.  继续重复此操作.....
4.  直到输出全部顶点或 AOV 网中不存在入度为 0 的顶点为止。

编辑于 2020-07-07 20:16:22

* * *

[大胖鱼头](https://www.nowcoder.com/profile/636223651)

1：从 DAG 图中选择一个 没有前驱（即入度为 0）的顶点并输出。
2：从图中删除该顶点和所有以它为起点的有向边。
3：重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。![](img/05ea224196d4fe25af615098bc33d2c0.png)

发表于 2021-12-17 14:53:26

* * *

## 55

有向图 G 中有 n 个顶点，e 条边，采用邻接表存储，若采用 BFS 方式遍历其时间复杂度为（      ）

正确答案: C   你的答案: 空 (错误)

```cpp
O(n)
```

```cpp
O(e)
```

```cpp
O(n+e)
```

```cpp
O(n×e)
```

本题知识点

C++工程师 360 公司 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 图 2019 系统工程师 测试开发工程师

讨论

[78018046](https://www.nowcoder.com/profile/78018046)

BFS 和 DFS 都是：邻接矩阵-O(n²)邻接表-O(n+e)

发表于 2019-08-14 13:41:37

* * *

[wind111](https://www.nowcoder.com/profile/398444368)

d

发表于 2019-08-03 23:31:43

* * *

## 56

下面程序执行后的输出值为（）

```cpp
#define  SUM(x) 3*x*x+1
int main() {
    int i=5, j=8;
    printf("%d\n", SUM(i+j));
    return 0;
}
```

正确答案: A   你的答案: 空 (错误)

```cpp
64
```

```cpp
508
```

```cpp
420
```

```cpp
其他几项都不对
```

本题知识点

C++工程师 C++ 2019 C 语言

讨论

[学长有压力](https://www.nowcoder.com/profile/791578968)

直接把表达式中的 x 替换为 i+j 即 3***i+j*****i+j**+1=3*5+8*5+8+1=64

发表于 2019-03-08 16:47:38

* * *

[Jack_Gao](https://www.nowcoder.com/profile/510882680)

#define 宏定义是直接替换(不用在乎括号 直接带入进去)

所以 S(i+j)是 4*i+j*i+j+1（没有括号）,所以结果是 4*6+8*6+8+1=81

发表于 2019-02-12 21:50:11

* * *

[learner111111](https://www.nowcoder.com/profile/970262031)

带入为 3*5+8*5+8+1=64

发表于 2018-12-21 18:09:04

* * *

## 57

在 32 位系统下运行以下程序，可能的输出结果为（）

```cpp
int main () {
    int i,a[5];
    for (i = 0; i <= 30; i++) {
        a[i] = 0;
        printf("%d:hello\n", i);
    }
    printf("%d:hello world",i);
    return 0;
}
```

正确答案: C   你的答案: 空 (错误)

```cpp
三十行的 i:hello (i∈[0,30]) 和一行 30:hello world
```

```cpp
三十行的 i:hello (i∈[0,30]) 和一行 31:hello world
```

```cpp
多行的 i:hello (i∈[0,30] )
```

```cpp
多行的 i:hello (i∈[0,31])
```

本题知识点

360 公司 C++工程师 C++ 2019 C 语言

讨论

[炫歌](https://www.nowcoder.com/profile/622959792)

我看了这道题的解析  写的都不是特别的清晰于是自己写了一下，希望能认真的看完，我相信你是有收获的如果觉得好就点个赞  谢谢😀![](img/355731938306c666e278deba26975093.png) 首先你一定要知道，数组溢出是不会报错的。我们由上图 可知： i  和  a[5] 是同一个地址  ，所以  当循环到  a[5]=0 时   i 也为  0 故就一直循环，造成了死循环。于是本题选 C 再看一幅图 来扩展一下：![](img/ad7699a7717f08ec250d2d2744519414.png)
你会发现这次的 i  和 a[5]  不是同一个地址了  看我圈住的部分你会发现两者之间的区别：我觉得是这样的(可能不是特别的准确)：图一：   int   i,a[5];从右到左 定义   所以  a[0]是高地址  以此类推  所以 a[5]和  i  是同一个地址图二:     int   a[ 5] ,i ;从右到左 定义   所以  i  低地址  以此类推  a[0],a[1]-----所以 a[5]和  i  不是同一个地址这时候我有了一个猜想：  就是先定义的是高地址，后定义的是低地址下面来实验一下，验证猜想：![](img/931f36b0a3a79d96058c9ae71095b2a6.png)
猜想正确。如果觉得好就点个赞  谢谢😀

编辑于 2020-07-14 20:42:00

* * *

[不要浮于表面](https://www.nowcoder.com/profile/4131613)

本题是考察数组越界会导致死循环。经过实验得知，当循环体中改为 i<=7 后，开始 0-6 的死循环，i<=6 及之前的，都可以退出循环。栈中是从高地址指向低地址的，如下：高地址 | i | a[4] | a[3] | a[2] | a[1] | a[0] | 低地址
所以 i 在高地址，而数组是连续存储的，而又由于有些编译器做了优化，使数组和 i 之间留有内存间隙，如开头所述，我用的 VS2010 留了 2 个间隙，但是，如果 i 越界严重，比如不小心给了 50，还是会导致死循环。知 a[6]与 i 占据一块空间，当执行到 i=6，a[6]=0，将 i 的值又变成了 0,又进入循环段执行下去，i 永远的不大于 30，造成死循环

编辑于 2019-08-24 14:02:14

* * *

[十 201904031030829](https://www.nowcoder.com/profile/183346187)

C++数组越界不报错，i 声明在 a 之前，i 相较于 a 位于高地址，a[i]=0 会把 i 的值改变如果 i 声明在 a 之后，则相较于 a 位于低地址，不会被 a[i]=0 冲掉

发表于 2020-05-09 10:11:26

* * *

## 58

下面程序的功能是从输入字符串中找出最长字符串，则下面程序哪行存在错误（）

```cpp
#include "stdio.h"
#include "string.h"
#define N 10
int main()
{
    char s[N][81], * t;                                     // line:1
    int j;                                                  // line:2
    for (j=0; j<N; j++)                                     // line:3
        gets (s[j]);                                        // line:4
    t= *s;                                                  // line:5
    for (j=1; j<N; j++)                                     // line:6
        if (strlen(t)<strlen(s[j]))                         // line:7
            t=&s[j];                                        // line:8
    printf("strings is: %d, %s\n", strlen(t), t);           // line:9
}
```

正确答案: D   你的答案: 空 (错误)

```cpp
line:1
```

```cpp
line:4
```

```cpp
line:6
```

```cpp
line:8
```

本题知识点

360 公司 C++工程师 2019 C 语言

讨论

[001010011010](https://www.nowcoder.com/profile/275339983)

**其实二维数组名的数据类型就是 type(*arrayName)[column]，即一个二级指针,所以将一个二级指针赋值给一级指针需要对二级指针变量使用指针运算符;而 s[j]就是相当于一个行指针是一个一级指针，所以将一个一级指针赋值给一级指针不用取地址运算符;**。

```cpp
t= *s; 
t=s[j];                                                    
```

发表于 2019-10-22 18:26:14

* * *

[我的天鸭](https://www.nowcoder.com/profile/243498)

t=&s[j] 改为 t = s[j]s[j]已经是 char *类型了

发表于 2019-08-17 16:56:25

* * *

[牛客 456891465 号](https://www.nowcoder.com/profile/456891465)

在 2011 年 12 月，ANSI 采纳了 ISO/IEC 9899:2011 标准，标准中删除了 gets()函数，使用一个新的更安全的函数 gets_s()替代。

发表于 2020-06-13 15:18:16

* * *

## 59

类 A 定义如下，则在横线处补充（      ）可以完成拷贝 aa 到 a（      ）

```cpp
Class A{
    Char*a;
Public:
    A():a(0){}
    A(char*aa) {
        a=_________;
        Strcpy(a,aa);
    }
    ~A(){delete [] a;}
};
```

正确答案: A   你的答案: 空 (错误)

```cpp
new char[strlen(aa)+1]
```

```cpp
char[strlen(aa)+1
```

```cpp
char[strlen(aa)]
```

```cpp
new char[sizeof(aa)+1]
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 2019 系统工程师 测试开发工程师

讨论

[regretful](https://www.nowcoder.com/profile/440791680)

关于 d, 这里 aa 是一个指针，sizeof(aa)表示的是 aa 指针的大小，32 位系统则为 4（64 位是 8）

发表于 2020-03-18 18:19:36

* * *

[白菜头 o](https://www.nowcoder.com/profile/236111537)

利用 new 运算符进行内存申请操作，长度为 aa 字符串长度加上字符串结束标志‘\0’，总共申请 strlen(aa)+1 字节

发表于 2019-04-14 14:59:44

* * *

[leo_lee_Gan](https://www.nowcoder.com/profile/285016565)

请教下为什么在拷贝前要先 new 新的内存呢？

发表于 2021-08-09 08:50:30

* * *

## 60

下面程序执行输出结果为（）

```cpp
#include <stdio.h>
int fun(int i) {
    int cnt = 0;
    while(i) {
        cnt++;
        i = i&(i-1);
    }
    return cnt;
}

int main() {
    printf("%d\n", fun(2017));
    return 0;
}
```

正确答案: B   你的答案: 空 (错误)

```cpp
6
```

```cpp
7
```

```cpp
8
```

```cpp
9
```

本题知识点

360 公司 C++工程师 C++ 2019 C 语言

讨论

[牛客 155078183 号](https://www.nowcoder.com/profile/155078183)

i = i & (i-1)，统计 i 二进制中有多少个 1i = i | (i+1)，统计 i 二进制中有多少个 0

发表于 2021-01-16 11:43:51

* * *

[jssqgy](https://www.nowcoder.com/profile/2820086)

2017 的二进制是 11111100001，有 7 个 1n&(n-1)就是从右往左数 1 的个数
举例：第一步：刚开始 n=11111100001!=0,count=1,n=11111100001&11111100000=11111100000,最右边第一个 1 第一步：n!=0，n=11111100000&11111011111=11111000000,最右边第二个 1……以此类推这是剑指 offer 上面关于位运算的题目

发表于 2019-08-15 16:07:02

* * *

[牛壮壮](https://www.nowcoder.com/profile/764544521)

i = i & (i-1)，统计 i 二进制中有多少个 1
i = i | (i+1)，统计 i 二进制中有多少个 0

发表于 2021-12-03 09:22:41

* * *

## 61

下列程序的运行结果是（）

```cpp
#include <iostream>
#include <cmath>
using namespace std;
class Point {
public:
    Point(int X=0, int Y=0);
    Point(Point &p);
    int GetX() {return X;}
    int GetY() {return Y;}
    static int countP;
    static void GetC(Point A,Point B) {
        int  z;
        z=sqrt((B.X-A.X)*(B.X-A.X)+(B.Y-A.Y)*(B.Y-A.Y));
        cout<<z<<endl;}
private:
    int X,Y;
};

Point::Point(int X, int Y)  {
    this->X=X;
    this->Y=Y;
    countP++;
}

Point::Point(Point &p) {
    X=p.X;
    Y=p.Y;
    countP++;
}
int Point::countP=0;

int main() {
    Point D(3,4), *p;
    Point E(D);
    p = &E;

    void (*q)(Point,Point) = Point::GetC;
    (*q)(D, E);
    return 0;
}
```

正确答案: B   你的答案: 空 (错误)

```cpp
2
```

```cpp
0
```

```cpp
3
```

```cpp
4
```

本题知识点

360 公司 C++工程师 C++ 2019 C 语言

讨论

[笑出自信](https://www.nowcoder.com/profile/462762007)

认真做完之后，感觉被侮辱了智商

发表于 2020-08-31 19:00:28

* * *

[HHHusky](https://www.nowcoder.com/profile/245013380)

这是 C++吧，我不是在做 C 语言专项练习吗？

发表于 2021-01-11 14:45:35

* * *

[你今天学到了啥](https://www.nowcoder.com/profile/969193193)

就是求两点距离，那个 countP 就是个干扰，都没用上，输出的就是两点距离，而他的两点都是同一点，所以距离为 0

发表于 2019-10-22 17:18:44

* * *

## 62

有以下程序段

```cpp
char a[2][2] = {{'a','b'},{'c','d'}};
char (*p)[2] = a;
cout<<*(*(p+1));
p++;
cout<<*(*p+1)<<endl;
```

请选择程序的运行结果（      ）

正确答案: D   你的答案: 空 (错误)

```cpp
bd
```

```cpp
ac
```

```cpp
ab
```

```cpp
cd
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 2019 系统工程师 测试开发工程师

讨论

[bobbydaniels](https://www.nowcoder.com/profile/4699672)

p 是一个指向含有两个元素的数组指针，由于指向了二维数组 a，相当于 p 的第一个元素是数组{'a','b'}第二个元素是数组{'c','d'}， 对于*(*(p+1))，先分析 p+1，p 指向的是第一个元素，p+1 就指向了第二个元素，也就是数组{'c','d'}，*(p+1)对 p+1 解引用/取值，返回的是第二个元素的内容，也就是字符 c 的地址，*(*(p+1))再对字符 c 的地址解引用/取值，得到字符 c。 然后 p++，此时 p 应该指向第二个元素数组{'c','d'}，对于*(*p+1)，*p 是数组{'c','d'}的首地址也就是字符 c 的地址，*p+1 则是指向了字符 d 的地址，再对*p+1 解引用/取值，*(*p+1)就是字符 d 了。

发表于 2020-11-26 01:04:50

* * *

[ShenggengHong](https://www.nowcoder.com/profile/214517349)

p 表示指向 a 数组第 0 行的指针 p+1 表示指向 a 数组第 1 行的指针*(*(p+1)) 即 a 数组的第一行第 0 个元素 p++后，p 表示指向 a 数组第一行的指针*p 表示指向 a 数组第一行第 0 个元素的指针，*p+1 表示指向 a 数组第一行第 1 个元素的指针，
*（*p+1）表示指向 a 数组第一行第 1 个元素

发表于 2019-09-07 12:56:29

* * *

## 63

有下列程序
using namespace std;
class SC
{public:
SC(int r){R =_____________;}
int Get(){return *R;};
private:
int *R;  };
int main()
{ SC C(10);
cout <<C.Get()<< endl;
return 0;}
请将构造函数补充完整，使得程序的运行结果是 10（      ）

正确答案: B   你的答案: 空 (错误)

```cpp
new int R
```

```cpp
&r
```

```cpp
r
```

```cpp
*r
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 2019 系统工程师 测试开发工程师

讨论

[夜霄](https://www.nowcoder.com/profile/878899945)

cao，尼玛 R 不就读取了栈里的脏数据？谁这么写代码的，woc

发表于 2019-09-04 18:03:04

* * *

[Wing、M](https://www.nowcoder.com/profile/9644267)

&r

发表于 2019-05-03 16:14:28

* * *

[东二](https://www.nowcoder.com/profile/828044348)

这 B 选项的 &amp 是个撒？有哪位大神晓得呀

发表于 2019-08-24 10:24:19

* * *

## 64

有以下类定义
using namespace std;
class B1{
int b1;
public:
B1(int i){b1=i; cout<<b1; }
~B1( ){ cout<<"#1"; }
};
class B2 {
int b2;
public:
B2( ){b2=0; cout<<"*2"; }
~B2( ){ cout<<"#2"; }
};
class C: virtual public B1,public B2 {
int j;
public:
C(int a,int b,int c):B1(a),_______ ,j(c){cout<<"*3";}
~C( ){ cout<<"#3"; }
private:
B1 c1;
B2 c2;};
请为横线处选择合适的程序将派生类 C 的构造函数补充完整（      ）

正确答案: B   你的答案: 空 (错误)

```cpp
B1(b)
```

```cpp
c1(b)
```

```cpp
c2(b)
```

```cpp
B2(b)
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 安卓工程师 360 公司 2019 C++工程师 360 公司 2019 iOS 工程师 360 公司 2019 Java 工程师 360 公司 2019 系统工程师 360 公司 2019 测试工程师 360 公司 2019 测试开发工程师 360 公司 2019 算法工程师 360 公司 2019

讨论

[我的天鸭](https://www.nowcoder.com/profile/243498)

答案是 B，简单解释一下为什么不选另外三个：A 选项中的 B1(b)：基类 B1 已经在 B1(a)中显式初始化过了，不能再次初始化 C 选项中的 c2(b)：成员变量 c2 是类 B2 的对象，而类 B2 并没有参数列表相匹配的构造函数 D 选项中的 B2(b)：基类 B2 没有参数列表相匹配的构造函数

发表于 2019-08-17 16:49:30

* * *

## 65

有以下程序

```cpp
#include<iostream>
using namespace std;
class Point {
public:
        Point(float xx=0, float yy=0) {X=xx;Y=yy;}
        float GetX() {return X;}
private:
    float X,Y;
};

class Rectangle: private Point {
public:
    Rectangle(float x, float y, float w, float h):Point(x,y) {W=w;H=h;}
    float GetX() {return ___________;}
    float GetH() {return H;}
    float GetW() {return W;}
private:
    float W,H;};

int main() {  
    Rectangle r(1,2,3,4);
    cout<<r.GetX();
    return 0;
}
```

请为横线处选择合适的程序使得程序的运行结果是 1（      ）？

正确答案: B   你的答案: 空 (错误)

```cpp
Y
```

```cpp
Point::GetX()
```

```cpp
GetX()
```

```cpp
X
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 2019 系统工程师 测试开发工程师

讨论

[Rurcher](https://www.nowcoder.com/profile/706315130)

坑有点多，首先是私有继承，基类所有保护和公有继承为派生类私有，基类私有成员，也就是这里 X，Y 不可访问；其次这里 point 的 getX 是可以访问的，但是派生类内部又有个重名的 getX，这会产生二义性，所以要访问基类的 getX，要加上作用域 point::getX

发表于 2020-09-06 10:56:31

* * *

[xcn](https://www.nowcoder.com/profile/158384761)

私有成员调用，需要加上该私有成员的的归属类

发表于 2019-11-10 10:10:31

* * *

[慕竹](https://www.nowcoder.com/profile/951301634)

有哪位大佬能详细说明吗？

发表于 2020-05-19 08:23:30

* * *

## 66

以下程序的输出结果为（      ）

```cpp
using namespace std;
void print(char **str){
    ++str;
    cout<<*str<<endl;
}
int main() {
    static char *arr[]={"hello", "world", "c++"};
    char **ptr;
    ptr=arr;
    print(ptr);
    return 0;
}
```

正确答案: B   你的答案: 空 (错误)

```cpp
hello
```

```cpp
world
```

```cpp
字符 w 的起始地址
```

```cpp
字符 e
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 2019 系统工程师 测试开发工程师

讨论

[牛魔王 king](https://www.nowcoder.com/profile/854653194)

arr 是一个指针数组，ptr 指向此数组首元素的地址(数组名代表数组首元素地址)，ptr+1 指向数组第二个元素的地址，因为数组中的元素为字符型指针，因此*(ptr+1)才是字符串"world"的首地址，输出显示 world

发表于 2020-05-01 18:33:20

* * *

[牛客 814170611 号](https://www.nowcoder.com/profile/814170611)

char＊是指向第二个字符数组，但是说它指向 w 的启始地址有错?

发表于 2021-05-10 23:31:08

* * *

[往梦想所及之地](https://www.nowcoder.com/profile/752933629)

arr 是一个一级指针数组 需要用一个二级指针 ptr 来接收一级指针数组的第一个数组的首地址 另一个函数参数列表中用同样是二级指针的 str 来接收二级指针 ptr 中存放的地址 也就是把一级指针数组的首地址通过中间变量 ptr 交给了二级指针 str ++str 之后 ste 指向了 arr 数组的第二个数组 对 str 解引用 就为第二个数组的内容 即 world

发表于 2021-04-22 22:33:03

* * *

## 67

以下程序的输出结果为（      ）

```cpp
int main() {
    char *ptr;    
    char arr[] = "12345678";
    ptr = arr;
    ptr += 5;
    printf("%s",ptr);
    return 0;
}
```

正确答案: B   你的答案: 空 (错误)

```cpp
5678
```

```cpp
678
```

```cpp
编译错误
```

```cpp
其他选项均不正确
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 2019 系统工程师 测试开发工程师 C 语言

讨论

[牛客 670531181 号](https://www.nowcoder.com/profile/670531181)

指针偏离五个单位，指向了 6，所以字符串打印出 678

发表于 2021-08-24 11:00:11

* * *

[SHIZC](https://www.nowcoder.com/profile/290066178)

此题 x%是地址，s%是字符，

发表于 2020-02-24 11:36:31

* * *

[jssqgy](https://www.nowcoder.com/profile/2820086)

从 arr[5]开始一直输出到最后

发表于 2019-08-15 16:15:53

* * *

## 68

执行如下代码后输出结果为（）

```cpp
int main() {
    int a[5]  = {1, 2, 3, 4, 5};
    int *ptr = (int*)(&a + 1);
    printf("%d, %d", *(a + 1), *(ptr - 1));
    return 0;
}
```

正确答案: D   你的答案: 空 (错误)

```cpp
1，1
```

```cpp
1,3
```

```cpp
3,3
```

```cpp
2,5
```

本题知识点

360 公司 C++工程师 C++ 2019 C 语言

讨论

[甜油条](https://www.nowcoder.com/profile/601822983)

&a + 1，其中 + 1 偏移的大小为 a 整个数组的大小，即 5 个 int 型的大小；a + 1，其中 + 1 偏移的大小为 a 中一个元素的大小，即 1 个 int 型的大小；ptr - 1，由于强制类型转换，此时 - 1 偏移的大小为 1 个 int 型；

发表于 2020-01-27 18:34:44

* * *

[大闸蟹养殖专业户](https://www.nowcoder.com/profile/423282307)

注意 &a 的类型是一个指向大小为 5 的 int 型数组的指针所以 +1 是加了 sizeof(大小为 5 的 int 型数组）

编辑于 2020-03-11 16:07:52

* * *

[learner111111](https://www.nowcoder.com/profile/970262031)

地址 ptr 数值本来是 a 数组的结尾的后一位地址值，减一则为 a 数组最后一位的地址。

发表于 2018-12-21 18:18:57

* * *

## 69

下面程序输出为（）

```cpp
#include <stdio.h>
int fun(int a) { 
    int b = 0;     
    static int c = 3;
    b++; 
    c++; 
    return (a + b + c);
}

int main() {
    int i=0;
    for(; i < 3; i++) 
        printf("%d",fun(2));
    return 0; 
}
```

正确答案: B   你的答案: 空 (错误)

```cpp
777
```

```cpp
789
```

```cpp
7911
```

```cpp
71320
```

本题知识点

360 公司 C++工程师 C++ 2019 C 语言

讨论

[牛顿的第四定论](https://www.nowcoder.com/profile/4786557)

含有静态变量 c 不会被释放，a，b 都是临时变量，所以只需要找到最开始的和为 7，每次只有 c 加 1，所以依次为 789

发表于 2019-09-20 17:43:07

* * *

[初见还是重逢](https://www.nowcoder.com/profile/916928686)

![](img/1d048656ca643756c07bf393df4a4047.png)![](img/2f1bc2511afbb2b9f541f2c8e3031244.png)
![](img/505e982f2330f6738a7e97d1ee14a6a9.png)

发表于 2019-09-19 20:50:27

* * *

[牛客 635608383 号](https://www.nowcoder.com/profile/635608383)

静态变量不会随着函数运行结束而结束，初始值只赋一次，后面再次调用的时候是在上次的值上做相应改变，而不会再赋一次初值，而局部变量则不一样，函数运行完了就被释放了，再次调用就需要再次赋初值。

发表于 2021-03-18 17:35:52

* * *

## 70

有以下类定义

```cpp
#include<iostream>
using namespace std;
class Clock{
public:
    Clock(int NewH=0, int NewM=0, int NewS=0){Hour=NewH; Minute=NewM;Second=NewS;}
    void ShowTime() {cout<<Hour<<":"<<Minute<<":"<<Second;}
    Clock  operator ++();
private:
    int Hour, Minute, Second;};
    Clock Clock::operator ++(){ 
        Second++;
        if(Second>=60){  
            Second=Second-60;
            Minute++;
            if(Minute>=60){
                Minute=Minute-60;
                Hour++;
                Hour=Hour%24;}}
        return ________;
    }
};

int main() {   
    Clock c1;
    (++c1).ShowTime();
    return 0;
}
```

请为横线处选择合适的程序（）使得程序的运行结果是 0:0:1。

正确答案: B   你的答案: 空 (错误)

```cpp
c1
```

```cpp
*this
```

```cpp
Clock
```

```cpp
this
```

本题知识点

360 公司 C++工程师 C++ 2019 C 语言

讨论

[姜小刀](https://www.nowcoder.com/profile/7478339)

选 B。return *this 返回的是当前对象的克隆或者本身，return this 返回当前对象的地址，这里很明显是返回当前对象。c1 是定义在主函数里面的对象，很明显不对。Clock 是类名，也不对。

发表于 2019-12-02 21:21:11

* * *

[阿尔法加](https://www.nowcoder.com/profile/512064526)

运算符++重载，return *this 表示返回使用++运算符的 Clock 类对象 c1，再调用运算后的(*this).ShowTime(),即 c1.ShowTime()显示时间

发表于 2019-10-14 13:54:54

* * *

[杉杉来啦](https://www.nowcoder.com/profile/243827773)

return *this 返回的是当前对象的克隆或者本身，return this 返回当前对象的地址，这里很明显是返回当前对象。c1 是定义在主函数里面的对象，很明显不对。Clock 是类名，也不对。运算符++重载，return *this 表示返回使用++运算符的 Clock 类对象 c1，再调用运算后的(*this).ShowTime(),即 c1.ShowTime()显示时间

发表于 2020-08-16 09:57:23

* * *

## 71

有下列类定义

```cpp
#include<iostream>
using namespace std;
class Point {
public:
    Point(int a=3,int b=5) {X=a; Y=b;}
    int GetX() {return X;}
    int GetY() {return Y;}
private:
    int X,Y;
};
```

现有语句 Point *p=new Point[2];则与(*p).GetX()等效的表达式是（）

正确答案: B C   你的答案: 空 (错误)

```cpp
Point[0]. GetX()
```

```cpp
p[0].GetX()
```

```cpp
p->GetX()
```

```cpp
GetX()
```

本题知识点

360 公司 C++工程师 C++ 2019 C 语言

讨论

[请回答 1988.](https://www.nowcoder.com/profile/6944453)

A 选项的 POINT（class 类型）是类名，不是数组名

发表于 2020-03-26 22:37:56

* * *

[paranoia9](https://www.nowcoder.com/profile/51698405)

请教大佬 b 选项

发表于 2020-04-01 12:54:10

* * *

[秃头大王](https://www.nowcoder.com/profile/939191738)

可能是传出了问题，第三个是 p->

发表于 2019-08-23 14:19:07

* * *

## 72

print 函数声明为

```cpp
void print(int a,char b='b',int c=1); 
```

下面函数调用正确的是（）

正确答案: A B C D   你的答案: 空 (错误)

```cpp
print('a');
```

```cpp
print(5,8);
```

```cpp
print(5,'#');
```

```cpp
print(5,'#',2);
```

本题知识点

360 公司 C++工程师 C++ 2019 C 语言

讨论

[pony 陈](https://www.nowcoder.com/profile/151661749)

函数声明时候参数初始化 可以不传参

如果传参则覆盖 否则就是默认初始化值

发表于 2019-11-09 22:05:35

* * *

[努力奋斗冲冲冲](https://www.nowcoder.com/profile/7221306)

传入参数进行了类型转换

发表于 2020-05-28 23:11:43

* * *

[寸丹心](https://www.nowcoder.com/profile/501695641)

因为整型和字符型隐式转化所以随便调？

发表于 2019-08-27 14:39:27

* * *

## 73

有以下语句定义

```cpp
int x =5;
const int * const p = &x;
const int &q=x; 
int const *next=&x;
const int *j=&x;
```

则有语法错误的是（）

正确答案: A B D   你的答案: 空 (错误)

```cpp
* p =1;
```

```cpp
q++;
```

```cpp
next++;
```

```cpp
(*j)++;
```

本题知识点

360 公司 C++工程师 C++ 2019 C 语言

讨论

[liyuanjine](https://www.nowcoder.com/profile/482941131)

A.p 是指针常量，*p 是代表 x 的值，被定义为常量，不可再赋值，A 错；B.&q 是对 x 变量的引用，但被定义为了常量，故 q 不再是变量，不能自增，B 错；C.如果 const 位于*的左侧，则 const 就是用来修饰指针所指向的变量，即指针指向为常量，故 x 为常量，不能改变，但是 next 指向 x 的地址，next++表示改变地址，故 c 选项无语法错误；
D.（*j）++表示 x 的值自增，但是 const int *j=&x 表示 x 为常量，不能改变，故 d 错误；此题主要考察指针与地址的关系，地址与引用的区别，const 在不同位置的作用，深入了解可参考相关博文：

> [`blog.csdn.net/ypshowm/article/details/89030156`](https://blog.csdn.net/ypshowm/article/details/89030156) c++中 const 的作用；

发表于 2020-04-10 20:54:59

* * *

[仙女山的太阳^_^](https://www.nowcoder.com/profile/307550221)

p 是常量，*p 是常量，故 A 错。 q 是常引用，不可修改，故 B 错。 j 指向的内容是常量 D 错

发表于 2019-08-30 18:02:23

* * *

[henry_dai](https://www.nowcoder.com/profile/116361517)

1>p 是指向常量的常量指针,(*p)是常量不能再赋值,2>q 是常量的引用,不能赋值 3>next 是指向常量的指针,next 本身可以改变 4>j 是指向常量的指针,值不能改变

发表于 2020-03-22 15:17:52

* * *

## 74

以下程序

```cpp
#include<iostream>
using namespace std;
template <typename T>
T Max(T* a, int n) {
T max=___________;
for(int i=1;i<n;i++)
    if(a[i]>max) max=a[i];
    return max;
}
int main() {
    int a[10]={3,7,5,0,2,1,8,4,9,6},*p=a+3;
    cout<<Max(p,7);
    return 0;
}
```

运行结果是 9，请为横线处选择合适的程序（）

正确答案: A B C D   你的答案: 空 (错误)

```cpp
*a
```

```cpp
a[0]
```

```cpp
0
```

```cpp
a[3]
```

本题知识点

360 公司 C++工程师 C++ 2019 C 语言

讨论

[蜀醉游子心](https://www.nowcoder.com/profile/5680535)

不用纠结了，就是一道垃圾题目

发表于 2019-09-12 10:21:46

* * *

[刘诗歌](https://www.nowcoder.com/profile/406172105)

如果针对这道题，四个选项都是对的但是 A 和 B 是通用的做点计算机基础题真不容易这尼玛就是文字游戏

发表于 2019-10-09 16:05:05

* * *

[cherryRed](https://www.nowcoder.com/profile/668491416)

在循环比较中 i 是从 1 开始的，如果是后两个选项，则 a0 的值会被忽略，假如最大值恰好是 a0，这个函数不就找不出来

发表于 2020-07-25 16:04:07

* * *

## 75

有以下语句定义

```cpp
int a[2][3];
int (*p)[3]=a; 
int *q=*a;
```

则能输出 a[1][2]的值的语句是（      ）

正确答案: A B C   你的答案: 空 (错误)

```cpp
cout&lt;&lt;*(*(a+1)+2);
```

```cpp
cout&lt;&lt;p[1][2];
```

```cpp
cout&lt;&lt;*(q+5);
```

```cpp
cout&lt;&lt;q[1][2];
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 2019 系统工程师 测试开发工程师 C 语言

讨论

[浅言 201904111331273](https://www.nowcoder.com/profile/732340711)

A 选项：a 是一个二维数组，*a 是二维数组的第一行（可以看做一维数组），所以*（a+1）是这个**二维数组的第二行**，把它**当做一维数组**b，*（b+2）很好理解了吧，只要明白*(a+i)等价于 a[i]；B 选项：p 是一个指向数组的指针，调试以后是这个样子的（假设 a 为{{1,2,3}，{4,5,6}}），我是这样理解：**p 是第一行第一个数的值，p[0][0]同样具有取到值的能力，因此可以通过 p[1][2]取到目标值；![](img/05a95ad5810239a466cf5e2056b7e902.png)C 选项：q 是指向 a 数组的第一行的指针，*(q+5）就是取往后数第五个元素的值，即 a[1][2];D 选项：VS 里会报语法错误，q[1]本来就是一个常数了（即 a[0][1]），对一个常数后面加 " [2] "显然不符合语法规则，改成 q[5]可以；最后不得不说这里部分代码可读性太差了，工作这么写 读代码的人会分分钟想要你猪命的！

编辑于 2019-10-03 18:47:38

* * *

[fingerling-俞](https://www.nowcoder.com/profile/679591153)

本题考查行指针和列指针相关问题，可以参考[`blog.csdn.net/DYD850804/article/details/80582519`](https://blog.csdn.net/DYD850804/article/details/80582519)**A**：二维数组名 a 是行指针，也就是数组指针，指向第一行的所有元素，a+1 指向第二行，行指针解引用（加*）可以转换为列指针，故*（a+1）为指向第二行首元素的列指针，*（a+1）+2 为指向 a[1][2]的列指针，解引用可得元素值；**B**：行指针 p 指向数组 a 首行，等价于数组名；**C**：*a 为指向数组首行首元素的列指针，所以 q 也是一个列指针，移动 5 个步长即指向元素 a[1][2]，解引用可得元素值；**D**：列指针不等价于数组名，不能这样使用。

发表于 2020-06-01 09:15:06

* * *

[媛 201906061659468](https://www.nowcoder.com/profile/354591388)

前面这一堆是啥玩意

```cpp
cout&lt;&lt;
```

发表于 2020-12-21 20:30:12

* * *

## 76

下列运算符重载函数中，属于友元函数的是（      ）

正确答案: B C D   你的答案: 空 (错误)

```cpp
Base operator+(Base);
```

```cpp
Base operator--(Base);
```

```cpp
Base operator&amp;&amp;(Base, Base);
```

```cpp
Base operator++(Base,int);
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 2019 系统工程师 测试开发工程师 C 语言

讨论

[我的天鸭](https://www.nowcoder.com/profile/243498)

A 选项中，operator+有两个参数，重载函数中只声明了一个参数，属于类的成员函数 B 选项中，**operator--前置运算符没有参数，后置运算符参数应为 int 型**，因此它重载的是前置--友元函数 C 选项中，operator&&有两个参数，属于类的友元函数 D 选项中，重载的是 operator++后置运算符，两个参数，为友元函数

发表于 2019-08-19 16:46:13

* * *

[z 跑跑跑](https://www.nowcoder.com/profile/394250961)

运算符既可以重载为类的成员函数，也可以重载为类的友元函数 对于双目运算符，重载为类的成员函数，有一个参数，重载为类的友元函数带有两个参数；对于单目运算符，重载为成员函数不带参数，重载为类的友元函数带有一个参数

发表于 2021-06-12 20:50:19

* * *

[阿 B](https://www.nowcoder.com/profile/5777315)

[`blog.csdn.net/ayangya/article/details/78901294`](https://blog.csdn.net/ayangya/article/details/78901294) 看这篇就够了

发表于 2019-10-15 21:18:53

* * *

## 77

有如下 C 语言程序

```cpp
#include  <stdio.h>
int fun(int * data)
{
*data = *data % 2;
return (*data) + 1;
}
int main() 
{
int data = 12;
fun(&data);
printf("%d,", data);
data = fun(&data);
printf("%d", data);
}
```

程序运行后的输出结果是

正确答案: B   你的答案: 空 (错误)

```cpp
0,0
```

```cpp
0,1
```

```cpp
1,2
```

```cpp
12,13
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 安卓工程师 360 公司 2019 C++工程师 360 公司 2019 iOS 工程师 360 公司 2019 Java 工程师 360 公司 2019 系统工程师 360 公司 2019 测试工程师 360 公司 2019 测试开发工程师 360 公司 2019 算法工程师 360 公司 2019

讨论

[Room_Aimoer](https://www.nowcoder.com/profile/130225889)

第一次调用函数没用返回值，别被迷惑了

发表于 2020-01-26 13:18:14

* * *

[ZhangRong](https://www.nowcoder.com/profile/463336544)

传参为指针时，函数值*data 变为 0，函数返回值为 1

编辑于 2019-09-04 15:14:46

* * *

## 78

有下列 C 语言程序片段。将它的功能用汇编程序实现，下面 1、2、3、4 处那句话有逻辑错误的是（）

```cpp
if (X>Y) X = X - Y;
else X = X + Y;
```

汇编片段为：

```cpp
MOV AX, X
CMP AX, Y     //1
JLE ELSE      //2
ADD AX, Y     //3
ELSE:
ADD AX, Y     //4
OK:
MOV X, AX
```

正确答案: C   你的答案: 空 (错误)

```cpp
1
```

```cpp
2
```

```cpp
3
```

```cpp
4
```

本题知识点

360 公司 C++工程师 C++ 2019 C 语言

讨论

[zxs 火山](https://www.nowcoder.com/profile/117743917)

程序一共两个错误，其中一个错误，有人指出来了，就是 3 处应该是 sub；第二个错误，3 后面应该 jmp OK。不然还会 3 执行完了还会继续执行下面的 else 块的代码。

发表于 2020-03-31 23:39:03

* * *

[下凡编程](https://www.nowcoder.com/profile/934777666)

微机原理：两个数相减用 SUB,两个数相加用 ADD。 3/处错误，应改为：SUB AX,Y

发表于 2019-09-04 22:22:15

* * *

[无趣良人](https://www.nowcoder.com/profile/781369496)

JLE 不是小等于嘛

发表于 2020-01-30 13:33:38

* * *

## 79

有以下 C 语言程序

```cpp
#include   <stdio.h>
int fun(int  x[], int  k) {  
    if(k==0) return (x[0]);
    return  x[0]+fun(x+1, k-1);
}
int main(){  
    int  x[ ]={1,2,3,4,5};
    printf("%d\n", fun(x,3));
}
```

程序运行后的输出结果是（）

正确答案: C   你的答案: 空 (错误)

```cpp
3
```

```cpp
6
```

```cpp
10
```

```cpp
15
```

本题知识点

C++工程师 C++

讨论

[jssqgy](https://www.nowcoder.com/profile/2820086)

fun(x,3)=x[0]+fun(x+1,2)=x[0]+x[1]+fun(x+2,1)=x[0]+x[1]+x[2]+fun(x+3,0)=x[0]+x[1]+x[2]+x[3]=10

发表于 2019-08-15 16:30:15

* * *

[艾佛森的泪](https://www.nowcoder.com/profile/949330719)

本题关键是要能看来里面的 x 的意思，这里 x 表示地址。x[] 表示数组，所以每次 x+1 都是地址+1 所以，答案是有连续的四个地址组成，对应的是 x[0]到 x[3]之和

发表于 2021-02-02 21:23:38

* * *

[1 册](https://www.nowcoder.com/profile/926366686)

大概明白了，子函数新定义了一个数组，分别把数组的下一位作为这个新的数组的头地址。

发表于 2020-02-29 09:23:50

* * *

## 80

对定义：void  (*f)(int *, int *);描述正确的是

正确答案: D   你的答案: 空 (错误)

```cpp
定义了函数的指针 f，f 所指函数返回指针
```

```cpp
声明了一个返回值为指针的函数 f
```

```cpp
声明了一个无返回值的函数 f
```

```cpp
定义了函数的指针 f，f 所指函数无返回值
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 安卓工程师 360 公司 2019 C++工程师 360 公司 2019 iOS 工程师 360 公司 2019 Java 工程师 360 公司 2019 系统工程师 360 公司 2019 测试工程师 360 公司 2019 测试开发工程师 360 公司 2019 算法工程师 360 公司 2019

## 81

下面程序的输出结果是（      ）

```cpp
#include <iostream>
using namespace std;
void max(int i, int j) 
{
cout << (i>j) ? i : j;
}
int main() 
{
int m = 016, n = 18;
max(m, n);

return 0;
}
```

正确答案: A   你的答案: 空 (错误)

```cpp
0
```

```cpp
16
```

```cpp
18
```

```cpp
其他几项都不对
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 安卓工程师 360 公司 2019 C++工程师 360 公司 2019 iOS 工程师 360 公司 2019 Java 工程师 360 公司 2019 系统工程师 360 公司 2019 测试工程师 360 公司 2019 测试开发工程师 360 公司 2019 算法工程师 360 公司 2019

讨论

[我的天鸭](https://www.nowcoder.com/profile/243498)

注意：**三目运算符 ? : 的优先级是要低于 << 的**

发表于 2019-08-20 11:17:08

* * *

[奋斗之路不堵车](https://www.nowcoder.com/profile/603497382)

注意：三目运算符 ? : 的优先级是要低于 << 的

发表于 2019-10-13 15:45:07

* * *

[火的意志](https://www.nowcoder.com/profile/3649835)

所以是 cout 了(14<18)

发表于 2019-09-14 16:26:11

* * *

## 82

下面程序的输出结果是（）

```cpp
#include <iostream>
using namespace std;

int main() 
{
    char str1[] = "hello world";  
    char str2[] = "hello world";  

    const char str3[] = "hello world";  
    const char str4[] = "hello world";  

    const char* pstring1 = "hello world";  
    const char* pstring2 = "hello world";  

    cout << boolalpha << ( str1==str2 ) <<  ',' ; 
    cout << boolalpha << ( str3==str4 ) << ',' ;  
    cout << boolalpha << ( pstring1==pstring2 ) <<endl;

    return 0;
}
```

正确答案: A   你的答案: 空 (错误)

```cpp
false,false,true
```

```cpp
false,false,false
```

```cpp
true,true,true
```

```cpp
false,true,true
```

本题知识点

360 公司 C++工程师 C++ 2019 C 语言

讨论

[毕梦](https://www.nowcoder.com/profile/87844327)

这个题主要是考察，变量在内存的存放的地点。感觉还可以加强一下变得难一些，比如比较地址的大小等等。str1、str2、str3 以及 str4 都是栈中定义的局部变量数组，并且进行了初始化，地址肯定会不一样。而 pstring1、pstring2 则是指针，虽然本身在栈中，但是所指向的是一个字串常量。题中比较的就是所指向的地址，所以为 true。

```cpp
#include<iostream>
using namespace std;
int main(void)
{
    char str1[] = "hello world";   //存放在栈中的数组
    char str2[] = "hello world";   //存放在栈中的数组

    const char str3[] = "hello world";  //存放在栈中的字符串常量
    const char str4[] = "hello world";  //存放在栈中的字符串常量

    const char* pstring1 = "hello world";   //本身在栈中，指向常量的指针
    const char* pstring2 = "hello world";   //本身在栈中，指向常量的指针     //显然二者所指向的地址一致

    int x = (int)pstring1;
    int y = (int)pstring2;                  //为了方便打印出指针所指向的地址

    cout << boolalpha << ( str1==str2 ) << endl;               //比较字串首地址      flase
    cout << boolalpha << ( str3==str4 ) << endl;               //比较字串首地址      flase
    cout << boolalpha << ( pstring1==pstring2 ) <<endl;        //比较指针所指地址    true

    cout << "str1=" << &str1 << ",";
    cout << "str2=" << &str2 << endl;

    cout << "str3=" << &str3 << ",";
    cout << "str4=" << &str4 << endl;

    cout << "pstring1=" << &pstring1 << ",";
    cout << "pstring2=" << &pstring2 << endl;                   //输出指针本身地址

    cout<<hex;
    cout << "pstring1=" << x << ",";
    cout<<hex;
    cout << "pstring2=" << y << endl;      //16 进制输出指针所指地址

    return 0;
}

```

![](img/272b78c958de051e959bddd869a85bc5.png)

编辑于 2019-11-12 19:00:52

* * *

[FreeLoop201909292343456](https://www.nowcoder.com/profile/737430612)

char *str 和 char str[]的区别：char *str = "hello"; //str 指向字符串常量"hello"的首地址,str 存放在栈上，"hello"保存在文字常量区。通过指针只能访问字符串常量，不可以改变它

char str[] = "hello"; //数组名 str 也是指向字符串的首地址，str，"hello"都存放在栈上。可以通过指针去访问和修改数组内容

查看 const char* pstring1 = "hello world"; 和 const char* pstring2 = "hello world";  的地址时，它们的地址是相同的。

发表于 2019-10-30 11:51:42

* * *

[regretful](https://www.nowcoder.com/profile/440791680)

```cpp
一、预备知识—程序的内存分配

一个由 c/C++编译的程序占用的内存分为以下几个部分
 1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
 2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收 。注意它与数据结构中的堆是两回事，分    配方式倒是类似于链表，呵呵。
 3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始    化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放
 4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放
 5、程序代码区—存放函数体的二进制代码。

二、例子程序

这是一个前辈写的，非常详细
//main.cpp
int a = 0; 全局初始化区
char *p1;  全局未初始化区
main()
{
  int b; 栈
  char s[] = "abc"; 栈
  char *p2; 栈
  char *p3 = "123456"; 123456/0 在常量区，p3 在栈上。
  static int c =0； 全局（静态）初始化区
  p1 = (char *)malloc(10);
  p2 = (char *)malloc(20); 
  分配得来的 10 和 20 字节的区域就在堆区。
  strcpy(p1, "123456"); 123456/0 放在常量区，编译器可能会将它与 p3 所指向的"123456"优化成一个地方。
}  https://blog.csdn.net/daweibalang717/article/details/46724723
```

发表于 2020-03-05 17:27:37

* * *

## 83

下面程序的输出结果是（）

```cpp
#include <iostream>
using namespace std;
class MD {
protected:
    float miles;
public:
    void setDist(float d){miles=d;}
    virtual float getDist(){return miles;}
    float square(){return getDist()*getDist();}
};

class FeetDist: public MD {
protected:
    float feet;
public:
    void setDist(float);
    float getDist(){return feet;}
    float getMiles(){return miles;}
};

void FeetDist::setDist(float ft) {
    feet=ft;    
    MD::setDist(feet/2);
}

int main() {
    FeetDist feet;
    feet.setDist(8);
    cout<<feet.getDist()<<","<<feet.getMiles()<<","<<feet.square()<<endl;
    return 0;
}
```

正确答案: B   你的答案: 空 (错误)

```cpp
8,4,16
```

```cpp
8,4,64
```

```cpp
8,8,64
```

```cpp
其他几项都不对
```

本题知识点

C++工程师 C++

讨论

[天将降大任于吾](https://www.nowcoder.com/profile/178455149)

注意一点 MD::setDist()函数调用。此时是没有父类的对象的，调用函数后设置的变量值当然也不属于父类对象。那他属于谁呢，没错他是子类继承自父类的变量，属于子类对象。本题其实漏掉了一个考点，如果同时创建一个父类对象并给父类对象的成员变量 miles 赋值。此时同时输出父类对象的 getDist(),和子类的 getMiles()函数，通过对比能更直观的理解继承中子类继承全部的父类内容。

编辑于 2020-04-16 10:24:25

* * *

[我的天鸭](https://www.nowcoder.com/profile/243498)

当子类和父类成员函数的返回值参数相同，函数名相同，有 virtual 关键字，则由对象的类型决定调用哪个函数。因为虚函数的存在，这道题的 getDist()调用的是子类的的成员函数。

发表于 2019-08-19 19:15:01

* * *

[Cpp 学渣本渣](https://www.nowcoder.com/profile/199461854)

子类对象，肯定子类的在虚函数表里面找，并且子类已经覆盖了父类的虚函数，所以调用子类虚函数。

编辑于 2020-12-25 01:19:24

* * *

## 84

下面程序的输出结果是（      ）

```cpp
#include <stdio.h>
int fun(int i)
{
return (i==2)?1:(i+fun(i-2));
}

int main()
{ 
printf("%d",fun(10)); 
return 0; 
}
```

正确答案: B   你的答案: 空 (错误)

```cpp
30
```

```cpp
29
```

```cpp
55
```

```cpp
54
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 安卓工程师 360 公司 2019 C++工程师 360 公司 2019 iOS 工程师 360 公司 2019 Java 工程师 360 公司 2019 系统工程师 360 公司 2019 测试工程师 360 公司 2019 测试开发工程师 360 公司 2019 算法工程师 360 公司 2019

讨论

[犇流](https://www.nowcoder.com/profile/139469194)

递归：从根开始算。1+4+6+8+10=29-----B

发表于 2019-10-07 14:47:01

* * *

[秃头大王](https://www.nowcoder.com/profile/939191738)

递归，10+8+6+4+1

发表于 2019-08-23 14:17:58

* * *

## 85

下面程序的输出结果是（）

```cpp
#include <stdio.h>
int main() { 
    int i, n = 0;
    float x = 1, y1 = 2.1 / 1.9, y2 = 1.9 / 2.1;
    for ( i = 1; i < 22; i++)
        x = x * y1;
    while ( x != 1.0 ) {
        x = x * y2; n++;    
    }
    printf( "%d\n", n );
    return 0; 
}
```

正确答案: C   你的答案: 空 (错误)

```cpp
21
```

```cpp
22
```

```cpp
程序无限循环
```

```cpp
运行时崩溃
```

本题知识点

C++工程师 C++

讨论

[小真真](https://www.nowcoder.com/profile/989305023)

浮点类型不能精确相等

发表于 2019-08-30 18:43:23

* * *

[aJanm](https://www.nowcoder.com/profile/987941610)

开开心心算了一下 n 的值。然后记一下这个坑。哈哈哈

发表于 2020-03-14 17:58:17

* * *

[001010011010](https://www.nowcoder.com/profile/275339983)

先来看一个简单的例子:

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int main()
{
    float a = 1.00000001;
    cout << (a == 1.0) << endl; //1
    return 0;
}
```

上述代码再 gcc 编译器编译通过。gcc 编译器表示单精度浮点数是以八位表示指数部分的（包括指数的符号），指数部分超过这个范围就不能精确表示一个单精度浮点数。这就说明浮点类型数据是不能精确比较的。

发表于 2019-10-12 11:52:50

* * *

## 86

有以下程序

```cpp
#include <iostream.h>
using namespace std;
class A {
    int *p,n;
public:
    A():p(0),n(0){}
    A(int q[10], int m) {
        n=m;
        p=__________;
        for(int i=0;i<m;i++)
            p[i]=*(q+i); 
    }
    ~A(){delete p;}
    int Get(int i) {return *(p+i);}
};

int main() {
    int s[10]={10,20,30,40,50,60,70,80,90,100};
    A a(s,10);
    int i=0,sum=0;
    for(;i<10;i++)
        sum=a.Get(i);
    cout<<"sum="<<sum<<endl;
    return 0;
}
```

程序运行结果是 sum=100，请为横线处选择合适的程序（）

正确答案: D   你的答案: 空 (错误)

```cpp
&q[0]
```

```cpp
q
```

```cpp
new int(n)
```

```cpp
new int[n]
```

本题知识点

C++工程师 C++

讨论

[是清欢吖](https://www.nowcoder.com/profile/764043619)

int *p= new int(10)分配一个 int 型变量内存空间，表示创建了一个 int 指针 p，且指向内容初始化为 10 int *p= new int[10]分配 10 个 int 型变量内存空间，表示创建了一个指向有 10 个 int 型元素的数组的 int 型指针 p。

发表于 2020-04-21 17:13:06

* * *

[牛客 835958541 号](https://www.nowcoder.com/profile/835958541)

选 D 的话，在删除内存块的时候没用 delete []p

发表于 2019-08-24 23:18:43

* * *

[betterpig](https://www.nowcoder.com/profile/819960199)

这题应该是想考深层复制吧~析构函数的确有问题，应该释放整个数组的，这里只释放了首元素的内存。

发表于 2020-08-25 18:08:39

* * *

## 65

有以下程序

```cpp
#include<iostream>
using namespace std;
class Point {
public:
        Point(float xx=0, float yy=0) {X=xx;Y=yy;}
        float GetX() {return X;}
private:
    float X,Y;
};

class Rectangle: private Point {
public:
    Rectangle(float x, float y, float w, float h):Point(x,y) {W=w;H=h;}
    float GetX() {return ___________;}
    float GetH() {return H;}
    float GetW() {return W;}
private:
    float W,H;};

int main() {  
    Rectangle r(1,2,3,4);
    cout<<r.GetX();
    return 0;
}
```

请为横线处选择合适的程序使得程序的运行结果是 1（      ）？

正确答案: B   你的答案: 空 (错误)

```cpp
Y
```

```cpp
Point::GetX()
```

```cpp
GetX()
```

```cpp
X
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 2019 系统工程师 测试开发工程师

讨论

[Rurcher](https://www.nowcoder.com/profile/706315130)

坑有点多，首先是私有继承，基类所有保护和公有继承为派生类私有，基类私有成员，也就是这里 X，Y 不可访问；其次这里 point 的 getX 是可以访问的，但是派生类内部又有个重名的 getX，这会产生二义性，所以要访问基类的 getX，要加上作用域 point::getX

发表于 2020-09-06 10:56:31

* * *

[xcn](https://www.nowcoder.com/profile/158384761)

私有成员调用，需要加上该私有成员的的归属类

发表于 2019-11-10 10:10:31

* * *

[慕竹](https://www.nowcoder.com/profile/951301634)

有哪位大佬能详细说明吗？

发表于 2020-05-19 08:23:30

* * *

## 88

有以下程序

```cpp
#include<stdio.h>
int main(){ 
    int sum; 
    for(int i=0; i<6; i+=2){ 
        sum=i; 
        for(int j = i; j<6; j++){
            if(i+j>5) continue;
            sum+=j;
        } 
    }     
    printf("%d",sum);
    return 0; 
} 
```

程序运行后的结果是（）

正确答案: A   你的答案: 空 (错误)

```cpp
4
```

```cpp
3
```

```cpp
5
```

```cpp
2
```

本题知识点

C++工程师 C++

讨论

[牛客 51974349 号](https://www.nowcoder.com/profile/51974349)

里面的那个 for 循环其实完全没有用，主要看外面的 for 循环，第一次 i=0，sum 也为 0，第二次 i=0+2，所以 sum=2，第三次 i=2+2=4，所以 sum=4，第四次 i=4+2=6，满足 i<6，所以结束 for 循环，此时 sum 还是等于 4

发表于 2020-10-02 20:34:18

* * *

[进阶中的牛客人](https://www.nowcoder.com/profile/450066322)

这是一个两重的 for 循环，每当内层循环完毕 跳转到外层循环时，sum 都被重新赋值为 i，因此内层的循环中 sum 的值累加到多少都不重要，主要还是看外层的

发表于 2021-04-20 09:16:43

* * *

[learner111111](https://www.nowcoder.com/profile/970262031)

外层循环一开始是赋值语句，故本题内层循环没用。

发表于 2018-12-21 18:32:50

* * *

## 89

以下程序的运行结果是（） ```cpp
#include <iostream>
using namespace std;

int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};

void fun(int* pa, int n);

int main() {
    int m = 10;
    fun(a, m);
    cout << a[6] << endl;
}

void fun(int* pa, int n) {
    for (int i = n - 1; i > 0; i--)
        *(pa + 6) += pa[i];
}
``` 

正确答案: D   你的答案: 空 (错误)

```cpp
34
```

```cpp
7
```

```cpp
6
```

```cpp
68
```

本题知识点

C++工程师 C++

讨论

[小圣君](https://www.nowcoder.com/profile/373983291)

问题的关键在 i = 6 的时候。

发表于 2019-09-02 10:50:58

* * *

[技术小白请多指教](https://www.nowcoder.com/profile/470614853)

{for (int i=n-1;i>0;i--) *(pa+6)+=pa[i]; }*(pa+6)初始值为 7,即 pa[6]=7，pa[9]=0,pa[8]=9,pa[7]=8 所以，当 i=7 的时候，pa[6]=7+0+9+8=24;当 i=6 的时候，pa[6]已经修改为 24 了，所以自己加自己是 24+24=48 之后就是依次加 5，4，3，2，最后结果 68。

发表于 2020-09-09 09:18:23

* * *

[xiaoxin11](https://www.nowcoder.com/profile/670703292)

应该是 7+0+9+8+（7+0+9+8）+6+5+4+3+2=68

发表于 2019-10-13 12:53:32

* * *

## 90

有以下程序

```cpp
#include <iostream>
#include <deque>
using namespace std;
int main() {
    deque<int> A;
    for(int i=0;i<5;i++)
        A.push_back(2*i+1);
    while(___________) {
        cout << A.front() << "   ";
        A.pop_front();
    }
    cout << endl;
}
```

程序的运行结果是 1   3   5   7   9，请为横线处选择合适的程序（      ）

正确答案: A   你的答案: 空 (错误)

```cpp
!A.empty()
```

```cpp
A
```

```cpp
A(i)!='\0'
```

```cpp
A.length==5
```

本题知识点

C++工程师 C++

讨论

[FreeLoop201909292343456](https://www.nowcoder.com/profile/737430612)

首先，deque 指的是 STL 里的双端数组。她常用的操作有：front()(返回容器中第一个数据)、back()(返回最后一个数据)、push_front()(头插)、push_back()(尾插)、pop_front()(头删)、pop_back()(尾删)；以及题中要用到的 empty()，作用是判断容器是否为空，如果为空则返回 true、不为空返回 false。按题中的意思应该是，先利用尾插法往容器中依次插入 1，3，5，7，9；后面的循环语句里是打印容器第一个数据后，再删除容器中第一个数据的操作；因此横线处应进行的操作是：若容器不为空就执行 while 中的语句。!A.empty()的含义就是当容器不为空就返回 true、进入循环。

发表于 2019-11-21 15:57:11

* * *

[Offer 在向谁招手](https://www.nowcoder.com/profile/507744994)

不是很懂，先收藏

发表于 2019-10-08 16:43:38

* * *

## 91

```cpp
#include <iostream>
using namespace std;

double power(double x, int n) {
    double val = 1.0;
    while (n--)  val *= x;
    return(val);
}

int main() {
    int  i;
    int  value = 0;
    char ch;
    for (i = 7; i >= 0; i--) {
        cin >> ch;
        if (__________)
            value += power(2, i);
    }
    cout << value << endl;
}

```

对于上面的程序，当从键盘输入 00100101，程序的运行结果是 37，请为横线处选择合适的语句（）

正确答案: B   你的答案: 空 (错误)

```cpp
ch
```

```cpp
ch == '1'
```

```cpp
ch==1
```

```cpp
ch!=0
```

本题知识点

C++工程师 C++

讨论

[风中的想念](https://www.nowcoder.com/profile/50409529)

当 ch 输入的字符为‘1’时才调用 power()函数: i=7 时 ch=0,继续循环 i=6 时 ch=0,继续循环 i=5 时 ch=1,pow(2,5)=32,value=32,继续循环 i=4 时 ch=0,继续循环 i=3 时 ch=0,继续循环 i=2 时 ch=1,pow(2,2)=4,value=32+4=36,继续循环 i=1 时 ch=0,继续循环 i=0 时 ch=1,pow(2,0）=1,value=36+1=37,结束

发表于 2019-08-21 21:39:44

* * *

[轻澄](https://www.nowcoder.com/profile/279740504)

首先，cin 的接收变量 ch 接收类型是 char，因此 ch 接收的数据就是 char 类型的，ACD 中这样子比较是把 ch 当作 int 型比较，也就是 ascii 码，其值都大于 0，对于 B 选项，这里就是 char 类型的比较，而且 37=2⁵+2²+2⁰，pow 函数为 2 的 n 次方，for 循环这里相当于 ch 为‘1’的时候进行 2 的 n 次方累加求和

发表于 2020-12-23 20:50:21

* * *

[牛客 839443084 号](https://www.nowcoder.com/profile/839443084)

选 D 的人应该是看懂了这个函数，但是没有注意到字符 0 和 0 的区别

发表于 2021-01-07 09:54:32

* * *

## 92

有以下程序

```cpp
#include<iostream>
using namespace std;

class P {
    char nameP[30];
public:
    P(const char* name = "123") { strcpy(nameP, name); }
    const char* getName() {
        return nameP;
    }
    virtual const char* getType() {
        return "P";
    }
};
class B :public P {
    char nameB[30];
public:
    B(const char* n1, const char* n2) : P(n1) { strcpy(nameB, n2); }
    const char* getName() { return nameB; }
    const char* getType() {
        return "B";
    }
};
void showP(P* p) {
    cout << p->getType() << ":" << p->getName() << endl;
}

int main() {
    B b("book1", "book2");
    showP(&b);
    return 0;
}
```

程序运行后的结果是（）

正确答案: C   你的答案: 空 (错误)

```cpp
P:book1
```

```cpp
B:book2
```

```cpp
B:book1
```

```cpp
P:book2
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 2019 系统工程师 测试开发工程师

讨论

[毕梦](https://www.nowcoder.com/profile/87844327)

希望可以调一下格式，看得头晕

发表于 2019-11-12 15:18:59

* * *

[小黑 lxx](https://www.nowcoder.com/profile/86427226)

p 是基类指针，指向派生类对象。getType()是虚函数，这里是重写；getName()不是虚函数，这里是隐藏。p->getType()调用派生类成员函数；p->getName()调用基类成员函数。我的理解：重写调用函数看对象，隐藏调用函数看指针。

发表于 2020-03-08 10:57:42

* * *

[mudamudamudamudamuda](https://www.nowcoder.com/profile/855415269)

基类和衍生类都有相同的**非虚**函数 getName，调用哪一个是根据**指针类型**决定而不是**指向的对象类型**决定的

发表于 2019-08-28 15:19:14

* * *

## 93

有以下程序,程序的功能是菜单选择：选择 A 输出：ADD；选择 D 输出：DELETE ；选择 S 输出：SORT；选择 Q 则退出。

```cpp
#include <iostream>
using namespace std;
int main()
{
    char choice = ' ';
    while (________)
    {
        cout << "Menu: A(dd) D(elete) S(ort) Q(uit),Select one:";
        cin >> choice;
        if (choice == 'A')
        {
            cout << "ADD" << endl;
            continue;
        }
        else if (choice == 'D')
        {
            cout << "DELETE " << endl;
            continue;
        }
        else if (choice == 'S')
        {
            cout << "SORT" << endl;
            continue;
        }
        else if (choice == 'Q')
            break;
    }
}
```

请为横线处选择合适的程序（      ）

正确答案: A C D   你的答案: 空 (错误)

```cpp
choice!='Q'
```

```cpp
choice!=Q
```

```cpp
choice
```

```cpp
1
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 运维工程师 测试工程师 算法工程师 C++ 2019 系统工程师 测试开发工程师

讨论

[晴好一片天](https://www.nowcoder.com/profile/564763120)

如果对 choice 进行初始化，比如初始化为空字符即 int choice=‘ ’，该答案是 choice!='Q'、choice 和 1

编辑于 2021-02-24 11:10:01

* * *

[夜★](https://www.nowcoder.com/profile/626357968)

choice 没有初始化就是个随机值吧

发表于 2019-08-25 09:45:15

* * *

[ninaaaaaa](https://www.nowcoder.com/profile/715848694)

其实题目里 choice 的初值不是空是空格（32）……

发表于 2022-02-17 16:13:47

* * *

## 94

有以下程序

```cpp
#include<iostream>
using namespace std;
____________________
int main() {
    int a=1,b=2,c=3;
    cout<<add(a,b,c);
    return 0;
}
int add(int x,int y,int z) { return x+y+z; }
```

程序运行的结果是 6，横线处合适的程序是（）

正确答案: A D   你的答案: 空 (错误)

```cpp
int add(int x,int y=5,int z=6);
```

```cpp
int add(int x=1,int y=5,int z);
```

```cpp
int add(int x=1,int y,int z=6);
```

```cpp
int add(int x=1,int y=5,int z=6);
```

本题知识点

C++工程师 C++

讨论

[牛客 361217938 号](https://www.nowcoder.com/profile/361217938)

默认实参作为形参的初始值出现在形参列表中。我们可以为一个或多个形参定义默认值，不过需要注意一点的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值；

发表于 2019-12-09 16:19:09

* * *

[竒竒](https://www.nowcoder.com/profile/41791593)

声明时，必须从右往左初始化，且中间不能跳

发表于 2020-09-15 17:21:40

* * *

[温 201908202232707](https://www.nowcoder.com/profile/120462029)

默认的实参应该全在行参后面

发表于 2019-08-21 21:52:42

* * *

## 95

有以下程序

```cpp
#include <iostream>
#include <vector>
using namespace std;
int main() {
    vector<int> A(10);
    int count=0,n;
    cout<<"请输入 n 的值：";
    cin>>n;
    A.__________(n);
    for(int i=2;i<=n;i++)
        if(i%3==0&&i%5==0) A[count++]=i;
    for(i=0;i<count;i++)
        cout<<A[i]<<" ";
    cout<<endl;
}
```

当键盘输入 20，程序的运行结果是 15，请为横线处选择合适的程序（      ）

正确答案: B C   你的答案: 空 (错误)

```cpp
size
```

```cpp
reserve
```

```cpp
resize
```

```cpp
length
```

本题知识点

C++工程师 C++

讨论

[白驹过隙、](https://www.nowcoder.com/profile/7052607)

Breserve(n)
调用 reserve(n)后，若容器的 capacity<n，则**重新分配内存空间**，从而使得 capacity 等于 nC
resize(n)**调整容器的长度大小**，使其能容纳 n 个元素。如果 n 小于容器的当前的 size，则删除多出来的元素。否则，添加采用值初始化的元素。原来大小是 10，I=15 才会有 A[count++]=15，所以要调整大小，而 AD 大小未发生变化

编辑于 2020-01-16 11:59:38

* * *

[OrientObjectPro](https://www.nowcoder.com/profile/3143319)

你妈死了出这题

发表于 2019-09-03 21:40:05

* * *

[Hardies](https://www.nowcoder.com/profile/325793180)

这题代码本身输入 20，就能输出 15，A.__(n);影响不大，只要编译能过就行。所以本题考查的是 vector 的函数的用法：vector.size();   size()函数没有形参。vector 没有 length()函数。所以 AD 不对；BC 用法上没有错误，程序正常运行。

发表于 2020-09-16 17:09:27

* * *

## 96

有以下程序

```cpp
#include <iostream> 
using namespace std;
class A {
    float *p;  int n;
public: 
    A(int s){ 
        n=s;  
        p=new float[n];
    }
    ~A() {
        delete[] p;
    } 
    int Getn() const {  
        return n; 
    }
    float & operator[](int i) {  
        return _________;
    } 
    void Print() {
        int i; 
        for(i=0;i< this->Getn();i++) 
            {cout<<p[i];}  
    }
};
int main() {
    A a(5); 
    for (int i=0;i<a.Getn();i++) 
        a[i]=i+1; 
    a.Print(); 
    return 0;
}
```

运行结果是 12345,请为横线处选择合适的程序（      ）

正确答案: A D   你的答案: 空 (错误)

```cpp
p[i]
```

```cpp
*p
```

```cpp
p+i
```

```cpp
*(p+i)
```

本题知识点

C++工程师 C++

讨论

[咸鱼半条](https://www.nowcoder.com/profile/197502833)

本题考察运算符重载以及数组。由于数组名就是数组首元素的地址，所以 p[i]=*(p+i)，所以此题选 AD

发表于 2019-10-09 20:15:05

* * *

[晓之铭](https://www.nowcoder.com/profile/537625741)

考数组的特性，P[i]=*(P+i)

发表于 2021-03-25 08:55:35

* * *

## 97

在 Linux 中，下列错误的是（）

正确答案: A   你的答案: 空 (错误)

```cpp
/etc/ld.so.conf 是 ping 的配置文件
```

```cpp
tar -czvf filename.tgz *可以压缩部分文件
```

```cpp
/etc/httpd/conf/httpd.conf 是 apache 的主配置文件
```

```cpp
tar -xzvf filename.tgz 解压缩 tar 文件
```

本题知识点

安卓工程师 360 公司 C++工程师 Java 工程师 测试工程师 算法工程师 Linux 2019

讨论

[大星星和小猩猩](https://www.nowcoder.com/profile/9374535)

/etc/ld.so.conf 此文件记录了编译时使用的动态库的路径，也就是加载 so 库的路径。默认情况下，编译器只会使用/lib 和/usr/lib 这两个目录下的库文件，而通常通过源码包进行安装时，如果不指定--prefix 会将库安装在/usr/local 目录下，而又没有在文件/etc/ld.so.conf 中添加/usr/local/lib 这个目录。

发表于 2020-04-06 00:34:30

* * *

[Wing、M](https://www.nowcoder.com/profile/9644267)

/etc/ld.so.conf 此文件记录了编译时使用的动态库的路径，也就是加载 so 库的路径。

发表于 2019-05-04 10:52:39

* * *

[gybcloud](https://www.nowcoder.com/profile/664012)

请问选项 B，“可以压缩部分文件”中的部分是什么意思？？？？？？？？？？？

发表于 2021-03-18 16:27:35

* * *

## 98

每天开机在/misc 目录下创建一个当天日期的文件夹（      ）

正确答案: D   你的答案: 空 (错误)

```cpp
echo "mkdir /misc/`date %Y%m%d`" >> /etc/rc.d/rc.local
```

```cpp
echo "mkdir /misc/date +%Y%m%d">/etc/rc.d/rc.local
```

```cpp
echo "mkdir /misc/`date +%Y%m%d`"> /etc/rc.d/rc.local
```

```cpp
echo "mkdir /misc/`date +%Y%m%d`">>/etc/rc.d/rc.local
```

本题知识点

安卓工程师 360 公司 C++工程师 Java 工程师 测试工程师 算法工程师 Linux 2019

讨论

[艾伦·耶格尔](https://www.nowcoder.com/profile/542598319)

如果有任何需要在系统启动时运行的工作，则只需写入 /etc/rc.d/rc.local 配置文件即可。把一个程序加入开机启动，一般也可以通过修改 rc.local 来完成。&gt--->  &lt---<  。>和>>：他们俩其实唯一的区别就是>是重定向到一个文件，>>是追加内容到文件。两个命令都是如果文件不存在则创建文件。echo "mkdir /misc/`date +%Y%m%d`" >> /etc/rc.d/rc.local 不一定在实际操作中有用，应为 rc.local 会被 Linux 的不同版本修改，如 ubuntu 中在 case 语句块里脚本就退出了，追加到文件尾部的话不会被执行。所以在 D 选项的时候，相对于 B 选项就有一个单引号，即绝对引用。

发表于 2020-08-24 14:30:04

* * *

[波波 2021 加油](https://www.nowcoder.com/profile/98731584)

那 C 和 D 不就是多个空格的事情， 在 centos 系统上 CD 都对，不知道是不是这个有系统版本限制。感觉题目不严谨

发表于 2021-07-01 16:15:29

* * *

[愚人五个字](https://www.nowcoder.com/profile/963871720)

/etc/rc.d/rc.local：一个启动加载配置文件，这个配置文件会在用户登陆之前读取，这个文件中写入了什么命令，在每次系统启动时都会执行一次。也就是说，如果有任何需要在系统启动时运行的工作，则只需写入 /etc/rc.d/rc.local 配置文件即可。把一个程序加入开机启动，一般也可以通过修改 rc.local 来完成。

>和>>：他们俩其实唯一的区别就是>是重定向到一个文件，>>是追加内容到文件。两个命令都是如果文件不存在则创建文件。

1>>、2>>、1>、2>：1 表示运行程序时程序正确运行输出结果的重定向、1 表示运行程序时时程序错误运行信息（如异常信息）的重定向，然后>>与>的区别和上面一样。

注：echo "mkdir /misc/`date +%Y%m%d`" >> /etc/rc.d/rc.local 不一定在实际操作中有用，应为 rc.local 会被 Linux 的不同版本修改，如 ubuntu 中在 case 语句块里脚本就退出了，追加到文件尾部的话不会被执行。

编辑于 2019-01-12 11:51:00

* * *

## 99

下列不是 dns 服务主配置文件的是(      )。

正确答案: B C D   你的答案: 空 (错误)

```cpp
named.conf
```

```cpp
dns.conf
```

```cpp
name.conf
```

```cpp
named.local
```

本题知识点

安卓工程师 360 公司 C++工程师 Java 工程师 测试工程师 算法工程师 Linux 2019

讨论

[Wing、M](https://www.nowcoder.com/profile/9644267)

DNS 服务器主配置文件：  /etc/named.conf

发表于 2019-05-04 10:57:33

* * *

[落叶无痕 0](https://www.nowcoder.com/profile/3796948)

我选的 A

发表于 2020-01-17 18:32:25

* * *

[大星星和小猩猩](https://www.nowcoder.com/profile/9374535)

dns 服务主配置文件是 **named.conf。**不存在 dns.conf 这个文件。

编辑于 2020-04-05 20:06:29

* * *

## 100

linux 防火墙 iptabls 拒绝所有客户端 ping 数据包的规则是(      )。

正确答案: A C   你的答案: 空 (错误)

```cpp
iptables -A INPUT -s ! 127.0.0.1 -p icmp -j DROP
```

```cpp
iptables -A INPUT -s 127.0.0.1 -p icmp -j DROP
```

```cpp
iptables -A INPUT -s 0.0.0.0 -p icmp -j DROP
```

```cpp
iptables -A INPUT -s 0.0.0.0 -p icmp -j DENY
```

本题知识点

安卓工程师 360 公司 C++工程师 Java 工程师 测试工程师 算法工程师 Linux 2019

讨论

[牛客 76015038 号](https://www.nowcoder.com/profile/76015038)

出的题，哎，学校里没学过，好难受

发表于 2020-08-14 13:53:38

* * *

[山上大木头](https://www.nowcoder.com/profile/939836276)

题目是拒绝，可所有客户端而 a 选项却允许本地客户端，是不是有些矛盾啊？

发表于 2019-08-27 12:34:56

* * *

[大星星和小猩猩](https://www.nowcoder.com/profile/9374535)

A 跟 C 是等价的。

发表于 2020-04-06 10:13:44

* * *

## 101

直接插入排序算法适用于下列哪种情形下（      ）

正确答案: C   你的答案: 空 (错误)

```cpp
待排序数据规模较大时
```

```cpp
任意情况
```

```cpp
待排序数据大部分已排序时
```

```cpp
其他几项都不对
```

本题知识点

排序 *讨论

[凌晨起来背单词](https://www.nowcoder.com/profile/141339970)

直接插入排序是数据越有序越快。

发表于 2020-10-08 22:33:32

* * *

## 102

设二叉排序树由(54,28,16,34,73,62,95,60,26,43)构成如下图二叉树，则在该树中查找任意指定元素的平均查找长度为（      ）![](img/62317e2ab1c02725137b574f7eabd3d3.png)

正确答案: B   你的答案: 空 (错误)

```cpp
1.2
```

```cpp
2.9
```

```cpp
4.1
```

```cpp
5.4
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 树 2019 系统工程师 测试开发工程师

讨论

[卡恩思欧](https://www.nowcoder.com/profile/67607315)

（1+2*2+3*4+4*3）/10

发表于 2018-12-28 09:06:46

* * *

[数字逻辑耙耙](https://www.nowcoder.com/profile/949455492)

(1+4+12+12)/10=2.9

发表于 2018-12-28 00:15:33

* * *

[眸子寒](https://www.nowcoder.com/profile/285683703)

（1+2*2+3*4+4*3）/10

发表于 2020-03-02 11:39:44

* * *

## 103

已知序列(50,30,80,20,40,90,35,85,32,88) ，按照依次插入的方法生成二叉排序树，则在该树中查找关键字值为 35 的结点所需比较次数为（      ）

正确答案: B   你的答案: 空 (错误)

```cpp
3
```

```cpp
4
```

```cpp
5
```

```cpp
6
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 树 2019 系统工程师 测试开发工程师

讨论

[学长有压力](https://www.nowcoder.com/profile/791578968)

![](img/8e342d5c03bf226bd8c4149410c2357c.png)

发表于 2019-03-08 16:58:04

* * *

[北雁依云☁️](https://www.nowcoder.com/profile/656123024)

二叉树基本性质：（1）若左子树不空,则左子树上所有结点的值均小于它的根结点的值；
（2）若右子树不空,则右子树上所有结点的值均大于它的根结点的值； 
（3）左、右子树也分别为二叉排序树；所以根据性质：第一个数 50 为根节点；第二个树：80>50,所以为 50 的右孩子；第三个数 30：因为 30<50<80，所以 30 为 80 的左孩子；第四个数 20：20<30 所以为 30 的左孩子；第五个数 40：因为 30<40<50,所以 40 在根节点的左子树上且为节点 30 的右孩子；第六个数 90：因为 90>80，所以在 80 结点的右子树上且为其右孩子第七个数 35：因为 50>35>30,所以 35 在根节点的左子树，且大于节点 30，故为 30 右子树下中 40 的左孩子。第八个数 85：首先 85>50,所以为根右子树上的节点，又 90<85<80,所以为 90 左子树上的节点，所以为 90 的左孩子。第九个数 32：因为 50>32>30,所以 32 在根节点的左子树，且大于节点 30，故为 30 右子树下。因为 32<35,故为 35 节点的左孩子第十个数 88：首先 88>50,所以位于根节点右子树上，又 88>80>85,所以为 80 的右子树上，所以为 85 的右孩子 over~

发表于 2020-04-09 15:23:36

* * *

[逆袭的黑马](https://www.nowcoder.com/profile/508968808)

没有算上最后和 35 比较，所以做错为 3 次

发表于 2020-12-27 17:24:08

* * *

## 104

使用快速排序算法对序列 9,1,3,8,23,5,7,10,29,19 进行排序，基准数取 9，则第 1 趟排序后的结果为（      ）

正确答案: B   你的答案: 空 (错误)

```cpp
9,1,3,8,23,5,7,10,29,19
```

```cpp
7,1,3,8,5,9,23,10,29,19
```

```cpp
1,3,8,9,23,5,7,10,29,19
```

```cpp
9,1,3,8,23,5,7,10,19,29
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 排序 *2019 系统工程师 测试开发工程师* *讨论

[冰镇可乐](https://www.nowcoder.com/profile/770698837)

我咋感觉是 5,1,3,8,7,9,23,10,29,19
挠头

发表于 2019-03-02 11:22:55

* * *

[wlsn](https://www.nowcoder.com/profile/599323175)

先确定基准值，然后从后向前找比基准值小的数，找到后将其与比它小的数进行交换，然后从前向后找比基准值大的数，将其交换，周而复始，直到确定下基准值的位置

发表于 2019-10-19 14:50:15

* * *

[k99999](https://www.nowcoder.com/profile/994717614)

这道题之所以有争议是因为快排有几种不同的写法：用的最多的是填坑法和交换法，这道题答案是以填坑法为基础的。可以说题目本身就存在问题。

发表于 2019-12-29 16:18:02

* * *

## 105

使用直接选择排序算法对序列 18,23,19,9,23,15 进行排序，第 3 趟排序后的结果为（      ）

正确答案: B   你的答案: 空 (错误)

```cpp
9,23,19,18,23,15
```

```cpp
9,15,18,19,23,23
```

```cpp
18,19,23,9,23,15
```

```cpp
18,19,23,9,15,23
```

本题知识点

排序 *讨论

[等一个 oc](https://www.nowcoder.com/profile/364417350)

我怎么觉得是 9 15 18 19 23 23 呢

发表于 2019-04-03 11:17:38

* * *

[jannyi](https://www.nowcoder.com/profile/823773293)

每次选最小的与第一个数（除排好序的）交换；9 18 23 19 23 15-->9 15 23 19 23 189 15 18 19 23 23

发表于 2020-03-13 13:52:28

* * *

[Neil201909152159170](https://www.nowcoder.com/profile/125216117)

![](img/9a8f1711ed4e1611925877e4d83747de.png)第三次应该是 9,15,18,19,23,23

发表于 2019-11-21 16:23:56

* * *

## 106

关于归并排序叙述正确的是（      ）

正确答案: A D   你的答案: 空 (错误)

```cpp
归并排序使用了分治策略的思想
```

```cpp
归并排序使用了贪心策略的思想
```

```cpp
子序列的长度一定相等
```

```cpp
归并排序是稳定的
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 排序 *2019 系统工程师 测试开发工程师* *讨论

[Porsche](https://www.nowcoder.com/profile/148222868)

A 归并排序就是先不断二分整个序列，然后排好每一段再合并的

发表于 2019-11-08 13:53:55

* * *

[不做人了](https://www.nowcoder.com/profile/250145)

可能出现素数个不好分组的情况

发表于 2020-04-28 19:18:22

* * *

[dengboyuan2020](https://www.nowcoder.com/profile/958218527)

A

发表于 2019-11-07 21:24:35

* * *

## 107

对于初始关键字(67,66,77,82,78,51,58),使用二路归并排序,第一趟归并之后其序列变为（      ）

正确答案: B   你的答案: 空 (错误)

```cpp
66,67,77,82,51,58,78
```

```cpp
66,67,77,82,51,78,58
```

```cpp
51,58,66,67,77,78,82
```

```cpp
67,66,77,78,82,51,58
```

本题知识点

排序 *讨论

[你的 offer 对我打了烊](https://www.nowcoder.com/profile/598309941)

按照顺序两两组合，每个组里两个元素进行排序，最后一个元素落单不去管

发表于 2020-03-27 08:26:13

* * *

[梅梅 201803241656278](https://www.nowcoder.com/profile/1728579)

![](img/5d419cfe47a41a930ec114f2e73df27c.png)第 1 趟排序结果如第 5 行(侵删)

发表于 2018-12-29 20:02:58

* * *

[愚人五个字](https://www.nowcoder.com/profile/963871720)

和这个类似：
![](img/32a58a7439ef4009e005c1757b97c74a.png)核心代码：int mid = (first + last) / 2;
    merge_sort(a, first, mid, res);     //左边有序   
    merge_sort(a, mid + 1, last, res);  //右边有序   
    Merge(a, first, mid, last, res);    //将左右两个有序数列进行排序归并

发表于 2019-01-12 14:47:08

* * *

## 108

下列哪种算法平均情况、最好情况和最坏情况下的时间复杂度都为![](img/d3f5725f9324c5db442bbeb848a8a419.svg)

正确答案: A   你的答案: 空 (错误)

```cpp
直接选择排序
```

```cpp
直接插入排序
```

```cpp
冒泡排序
```

```cpp
归并排序
```

本题知识点

排序 *讨论

[大小满](https://www.nowcoder.com/profile/159018122)

1.选择排序：不稳定，时间复杂度 O(n²)
选择排序的基本思想是对待排序的记录序列进行 n-1 遍的处理，第 i 遍处理是将 L[i..n]中最小者与 L[i]交换位置。这样，经过 i 遍处理之后，前 i 个记录的位置已经是正确的了。
2.插入排序：稳定，时间复杂度 O(n²)
插入排序的基本思想是，经过[i-1](https://www.baidu.com/s?wd=i-1&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)遍处理后,L[1..[i-1](https://www.baidu.com/s?wd=i-1&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)]己排好序。第 i 遍处理仅将 L[i]插入 L[1..[i-1](https://www.baidu.com/s?wd=i-1&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)]的适当位置，使得 L[1..i] 又是排好序的序列。要达到这个目的，我们可以用顺序比较的方法。首先比较 L[i]和 L[i-1]，如果 L[i-1]≤ L[i]，则 L[1..i]已排好序，第 i 遍处理就结束了；否则交换 L[i]与 L[i-1]的位置，继续比较 L[i-1]和 L[i-2]，直到找到某一个位置 j(1≤j≤i-1)，使得 L[j] ≤L[j+1]时为止。图 1 演示了对 4 个元素进行插入排序的过程，共需要(a),(b),(c)三次插入。
3.冒泡排序：稳定，时间复杂度 O(n²)
冒泡排序方法是最简单的排序方法。这种方法的基本思想是，将待排序的元素看作是竖着排列的“气泡”，较小的元素比较轻，从而要往上浮。在冒泡排序算法中我们要对这个“气泡”序列处理若干遍。所谓一遍处理，就是自底向上检查一遍这个序列，并时刻注意两个相邻的元素的顺序是否正确。如果发现两个相邻元素的顺序不对，即“轻”的元素在下面，就交换它们的位置。显然，处理一遍之后，“最轻”的元素就浮到了最高位置；处理二遍之后，“次轻”的元素就浮到了次高位置。在作第二遍处理时，由于最高位置上的元素已是“最轻”元素，所以不必检查。一般地，第 i 遍处理时，不必检查第 i 高位置以上的元素，因为经过前面 i-1 遍的处理，它们已正确地排好序。
4.堆排序：不稳定，时间复杂度 O(nlog n)
堆排序是一种树形选择排序，在排序过程中，将 A[n]看成是完全二叉树的[顺序存储结构](https://www.baidu.com/s?wd=%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。
5.归并排序：稳定，时间复杂度 O(nlog n)
设有两个有序（升序）序列存储在同一数组中相邻的位置上，不妨设为 A[l..m]，A[m+1..h]，将它们归并为一个有序数列，并存储在 A[l..h]。
6.快速排序：不稳定，时间复杂度 最理想 O(nlogn) 最差时间 O(n²)
快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少 1。快速排序通过一趟扫描，就能确保某个数（以它为基准点吧）的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。

发表于 2019-06-21 14:34:27

* * *

[WonderWu](https://www.nowcoder.com/profile/56712837)

针对本题目解释一下选项：

*   A.直接选择排序由于每次都需要遍历整个序列选出最大（最小）值，所以平均、最好、最坏都是 O（N²）
*   B.直接插入排序最好情况下复杂度为 O（N），假设是一个已经排好序的序列，每次选取的插入值都是比较一次即可，一个需要表 N 次
*   C.冒泡排序最好情况下复杂度为 O（N），同样假设是一个已经排好序的序列，只需要遍历一遍即可完成排序
*   D.归并排序每次进行都需要进行分组、合并，复杂度都为 O（N logN）

发表于 2022-03-12 15:40:15

* * *

## 109

下列哪些排序方法在最坏的情况下的时间复杂度为![](img/d3f5725f9324c5db442bbeb848a8a419.svg)

正确答案: B C D   你的答案: 空 (错误)

```cpp
归并排序
```

```cpp
快速排序
```

```cpp
冒泡排序
```

```cpp
插入排序
```

本题知识点

360 公司 复杂度 2019

讨论

[rinzuki](https://www.nowcoder.com/profile/812026351)

| 排序方法 | 时间复杂度（平均） | 时间复杂度（最坏) | 时间复杂度（最好) | 空间复杂度 | 稳定性 | 复杂性 |
| 直接插入排序 | O(n2) | O(n2) | O(n) | O(1) | 稳定 | 简单 |
| 希尔排序 | O(nlog2n) | O(n2) | O(n) | O(1) | 不稳定 | 较复杂 |
| 直接选择排序 | O(n2) | O(n2) | O(n2) | O(1) | 不稳定 | 简单 |
| 堆排序 | O(nlog2n) | O(nlog2n) | O(nlog2n) | O(1) | 不稳定 | 较复杂 |
| 冒泡排序 | O(n2) | O(n2) | O(n) | O(1) | 稳定 | 简单 |
| 快速排序 | O(nlog2n) | O(n2) | O(nlog2n) | O(nlog2n) | 不稳定 | 较复杂 |
| 归并排序 | O(nlog2n) | O(nlog2n) | O(nlog2n) | O(n) | 稳定 | 较复杂 |
| 基数排序 | O(d(n+r)) | O(d(n+r)) | O(d(n+r)) | O(n+r) | 稳定 | 较复杂 |

发表于 2019-09-23 13:43:25

* * *

[softwareGxy](https://www.nowcoder.com/profile/560840485)

快 些(希) 以*（O(nlog2)）* 归 队，最坏情况下 快 些（希） 退化成*O(n2).*

发表于 2020-09-04 21:31:19

* * *

## 110

待排序元素规模较小时，宜选取哪种排序算法效率最高（      ）

正确答案: C   你的答案: 空 (错误)

```cpp
堆排序
```

```cpp
归并排序
```

```cpp
冒泡排序
```

```cpp
希尔排序
```

本题知识点

排序 *讨论

[喵喵狂吠](https://www.nowcoder.com/profile/969895020)

笔记：递归时间可能长于比较时间

发表于 2019-12-16 19:22:32

* * *

[牛客 808362388 号](https://www.nowcoder.com/profile/808362388)

递归本身需要处理的时间就比普通比较长。如果数据越大，时间复杂度的优势就越明显。如果数据量小，时间复杂度的优势就不明显。

发表于 2022-01-14 11:43:46

* * *

[淇神](https://www.nowcoder.com/profile/561565628)

360 公司是傻雕吗

发表于 2020-04-18 10:55:38

* * *

## 111

对 n 个元素用插入法建堆的时间复杂度是（）

正确答案: A   你的答案: 空 (错误)

```cpp
O(nlog(n))
```

```cpp
O(n)
```

```cpp
O(log(n))
```

```cpp
O(n²)
```

本题知识点

排序 *讨论

[HengV](https://www.nowcoder.com/profile/158271087)

建堆有 2 种方法第一种方法：HeapInsert（本题就是这种方法），它可以假定我们事先不知道有多少个元素，通过不断往堆里面插入元素进行调整来构建堆。这种插入建堆的时间复杂度是 O(NlogN)第二种方法：Heapify
从最后一个非叶子节点一直到根结点进行堆化的调整。如果当前节点小于某个自己的孩子节点（大根堆中），那么当前节点和这个孩子交换。这种建堆的时间复杂度是 O(N)Heapify 是一种类似下沉的操作，HeapInsert 是一种类似上浮的操作。 

发表于 2020-07-15 10:35:01

* * *

[Mrs_ 柳](https://www.nowcoder.com/profile/547832387)

快（快排）些（希尔）以 O（n㏒n）的速度归（归并）队（堆）

发表于 2020-02-15 16:30:19

* * *

[只有更坑，没有最坑](https://www.nowcoder.com/profile/979541802)

建堆难道不是初始化堆吗？

发表于 2020-03-08 14:49:10

* * *

## 112

利用动态规划计算以下矩阵连乘：A1(20*25)、A2(25*5)、A3(5*15)、A4(15*10)、A5(10*20)、A6(20*25)

正确答案: A   你的答案: 空 (错误)

```cpp
(A1A2)(((A3A4)A5)A6)
```

```cpp
(A1A2A3)((A4A5)A6)
```

```cpp
(((A1((A2A3)A4))A5)A6)
```

```cpp
(A1A2)((A3(A4A5))A6)
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 动态规划 2019 系统工程师 测试开发工程师

讨论

[chris_huang](https://www.nowcoder.com/profile/195923842)

矩阵 A（m*n）和 B（n*k）的乘法运算次数为：m*n*k；连乘次数最小选 A
选项  连乘次数
A.(A1A2)(((A3A4)A5)A6)=20*25*5（A1A2）+ 5*15*10（A3A4）+ 5*10*20+5*20*25+ 20*5*25=  9250
B.(A1A2A3)((A4A5)A6)  22000
C.(((A1((A2A3)A4))A5)A6)  26375
D.(A1A2)((A3(A4A5))A6)  12000

编辑于 2019-06-21 15:02:51

* * *

[大王内推](https://www.nowcoder.com/profile/269462648)

没看懂，望大神解析

发表于 2019-08-14 11:17:58

* * *

## 113

适用动态规划算法求解的问题一般应具有哪些特征（      ）

正确答案: A B   你的答案: 空 (错误)

```cpp
满足最优化原理
```

```cpp
待解决问题存在重叠子问题
```

```cpp
具有最优子结构性质
```

```cpp
问题规模缩小到一定程度后就容易解决
```

本题知识点

安卓工程师 360 公司 C++工程师 iOS 工程师 Java 工程师 前端工程师 运维工程师 测试工程师 算法工程师 动态规划 2019 系统工程师 测试开发工程师

讨论

[August-us2020](https://www.nowcoder.com/profile/2284237)

多学习比做这过于有争议的题目好多了，没有下面 CD 两个特征，你用什么动态规划？？？[`blog.csdn.net/m0_38065572/article/details/104195388`](https://blog.csdn.net/m0_38065572/article/details/104195388)

发表于 2020-03-24 17:31:23

* * *

[81192_J](https://www.nowcoder.com/profile/8657090)

请问这个题 C 可以选吗

发表于 2019-08-15 15:51:43

* * *

## 114

以下算法中哪些算法的空间复杂度为 O(1)？

正确答案: A D   你的答案: 空 (错误)

```cpp
简单选择排序
```

```cpp
快速排序
```

```cpp
基数排序
```

```cpp
堆排序
```

本题知识点

360 公司 复杂度 2019

讨论

[紫菜菜](https://www.nowcoder.com/profile/831220)

基数排序：k 进制的话需要 k 个桶快速排序：基于递归，考虑栈空间，空间复杂度从最坏 O(N)到最好 O(logN)

发表于 2019-08-14 11:17:11

* * *

[20190716092877](https://www.nowcoder.com/profile/755609122)

算法空间复杂度(辅助空间)
O(1) 冒泡排序
O(1) 简单选择
O(1) 直接插入
O(1) 希尔排序
O(1) 堆排序
O(n) 归并排序
O(log n)~O(n) 快速排序

发表于 2019-08-19 17:09:10

* * *

[小六喜欢赵小刀](https://www.nowcoder.com/profile/860595925)

除了基数和快排不就是都是 O（1）吗？

发表于 2020-07-05 21:41:59

* * *************