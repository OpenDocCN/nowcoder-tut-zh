# 第二章 第 1 节 C++操作系统-1

> 原文：[`www.nowcoder.com/tutorial/10069/00433f744f9e4c319576fabfe90c590f`](https://www.nowcoder.com/tutorial/10069/00433f744f9e4c319576fabfe90c590f)

### 2.1 Linux 中查看进程运行状态的指令、查看内存使用情况的指令、tar 解压文件的参数。

**参考回答**

1.  **查看进程运行状态的指令**：ps 命令。“**ps -aux | grep PID**”，用来查看某 PID 进程状态

2.  **查看内存使用情况的指令**：free 命令。“**free -m**”，命令查看内存使用情况。

3.  **tar 解压文件的参数**：

    ```cpp
    五个命令中必选一个
         -c: 建立压缩档案
         -x：解压
         -t：查看内容
         -r：向压缩归档文件末尾追加文件
         -u：更新原压缩包中的文件
    这几个参数是可选的
         -z：有 gzip 属性的
         -j：有 bz2 属性的
         -Z：有 compress 属性的
         -v：显示所有过程
         -O：将文件解开到标准输出
    ```

**答案解析**

```cpp
//ps 使用示例
//显示当前所有进程  
ps -A  
//与 grep 联用查找某进程  
ps -aux | grep apache  

//查看进程运行状态、查看内存使用情况的指令均可使用 top 指令。
top
```

### 2.2 文件权限怎么修改

**参考回答**

Linux 文件的基本权限就有九个，分别是 owner/group/others 三种身份各有自己的 read/write/execute 权限

修改权限指令：**chmod**

**答案解析**

举例：文件的权限字符为 -rwxrwxrwx 时，这九个权限是三个三个一组。其中，我们可以使用数字来代表各个权限。

各权限的分数对照如下：

| r | w | x |
| :-: | :-: | :-: |
| 4 | 2 | 1 |

每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，

例如当权限为： [-rwxrwx---] ，则分数是：

owner = rwx = 4+2+1 = 7

group = rwx = 4+2+1 = 7

others= --- = 0+0+0 = 0

所以我们设定权限的变更时，该文件的权限数字就是 770！变更权限的指令 chmod 的语法是这样的：

```cpp
[root@www ~]# chmod [-R] xyz 文件或目录 
选项与参数： 
xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 
-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更

# chmod 770 douya.c //即修改 douya.c 文件的权限为 770
```

### 2.3 说说常用的 Linux 命令

**参考回答**

1.  cd 命令：用于切换当前目录

2.  ls 命令：查看当前文件与目录

3.  grep 命令：该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工。

4.  cp 命令：复制命令

5.  mv 命令：移动文件或文件夹命令

6.  rm 命令：删除文件或文件夹命令

7.  ps 命令：查看进程情况

8.  kill 命令：向进程发送终止信号

9.  tar 命令：对文件进行打包，调用 gzip 或 bzip 对文件进行压缩或解压

10.  cat 命令：查看文件内容，与 less、more 功能相似

11.  top 命令：可以查看操作系统的信息，如进程、CPU 占用率、内存信息等

12.  pwd 命令：命令用于显示工作目录。

### 2.4 说说如何以 root 权限运行某个程序。

**参考回答**

```cpp
sudo chown root app（文件名）
sudo chmod u+s app（文件名）
```

输入上面两条指令后即可

### 2.5 说说软链接和硬链接的区别。

**参考回答**

1.  **定义不同**

    软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。

    硬链接就是一个文件的一个或多个文件名。把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。

2.  **限制不同**

    硬链接只能对已存在的文件进行创建，不能交叉文件系统进行硬链接的创建；

    软链接可对不存在的文件或目录创建软链接；可交叉文件系统；

3.  **创建方式不同**

    硬链接不能对目录进行创建，只可对文件创建；

    软链接可对文件或目录创建；

4.  **影响不同**

    删除一个硬链接文件并不影响其他有相同 inode 号的文件。

    删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。

### 2.6 说说静态库和动态库怎么制作及如何使用，区别是什么。

**参考回答**

**静态库的制作：**

```cpp
gcc  hello.c  -c //这样就生成 hello.o 目标文件

ar rcs libhello.a  hello.o//生成 libhello.a 静态库
```

**静态库的使用：**

```cpp
gcc main.c -lhello -o staticLibrary//main.c 和 hello 静态库链接，生成 staticLibrary 执行文件
/*
main.c：  是指 main 主函数
-lhello： 是我们生成的.a 文件砍头去尾（lib 不要 .a 也不要）前面加-l
-L：      是指告诉 gcc 编译器先从-L 指定的路径去找静态库，默认是从/usr/lib/ 或者  /usr/local/lib/ 去找。
./：      是指当前路径的意思
staticLibrary： 是最后想生成的文件名（这里可随意起名字）
*/
```

**动态库的制作：**

```cpp
gcc -shared -fpic hello.c -o libhello.so
-shared 指定生成动态库
-fpic ：fPIC 选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。
```

**动态库的使用：**

```cpp
gcc main.c -lhello -L ./ -o dynamicDepot
/*
main.c：  是指 main 主函数
-lhello： 是我们生成的.so 文件砍头去尾（lib 不要 .so 也不要）前面加-l
-L：      是指告诉 gcc 编译器先从-L 指定的路径去找静态库，默认是从/usr/lib/ 或者 /usr/local/lib/ 去找。
./：      是指当前路径的意思
dynamicDepot： 是最后想生成的文件名（这里可随意起名字）
*/
```

**区别：**

1.  静态库代码装载的速度快，执行速度略比动态库快。
2.  动态库更加节省内存，可执行文件体积比静态库小很多。
3.  静态库是在编译时加载，动态库是在运行时加载。
4.  生成的静态链接库，Windows 下以.lib 为后缀，Linux 下以.a 为后缀。生成的动态链接库，Windows 下以.dll 为后缀，Linux 下以.so 为后缀。

### 2.7 简述 GDB 常见的调试命令，什么是条件断点，多进程下如何调试。

**参考回答**

**GDB 调试**：gdb 调试的是可执行文件，在 gcc 编译时加入 -g ，告诉 gcc 在编译时加入调试信息，这样 gdb 才能调试这个被编译的文件 gcc -g tesst.c -o test

**GDB 命令格式：**

1.  quit：退出 gdb，结束调试

2.  list：查看程序源代码

    list 5，10：显示 5 到 10 行的代码

    list test.c:5, 10: 显示源文件 5 到 10 行的代码，在调试多个文件时使用

    list get_sum: 显示 get_sum 函数周围的代码

    list test,c get_sum: 显示源文件 get_sum 函数周围的代码，在调试多个文件时使用

3.  reverse-search：字符串用来从当前行向前查找第一个匹配的字符串

4.  run：程序开始执行

5.  help list/all：查看帮助信息

6.  break：设置断点

    break 7：在第七行设置断点

    break get_sum：以函数名设置断点

    break 行号或者函数名 if 条件：以条件表达式设置断点

7.  watch 条件表达式：条件表达式发生改变时程序就会停下来

8.  next：继续执行下一条语句 ，会把函数当作一条语句执行

9.  step：继续执行下一条语句，会跟踪进入函数，一次一条的执行函数内的代码

**条件断点：**break if 条件 以条件表达式设置断点

**多进程下如何调试：**用 set follow-fork-mode child 调试子进程

​ 或者 set follow-fork-mode parent 调试父进程

### 2.8 说说什么是大端小端，如何判断大端小端？

**参考回答**

**小端模式**：**低**的有效字节存储在**低的**存储器地址。小端一般为主机字节序；常用的 X86 结构是小端模式。很多的 ARM，DSP 都为小端模式。

**大端模式**：**高**的有效字节存储在**低的**存储器地址。大端为网络字节序；KEIL C51 则为大端模式。

有些 ARM 处理器还可以由硬件来选择是大端模式还是小端模式。

如何判断：我们可以根据**联合体**来判断系统是大端还是小端。因为联合体变量总是从**低地址**存储。

```cpp
int fun1(){  
    union test{   
        char c;   
        int i; 
    };  
    test t; t.i = 1;  
    //如果是大端，则 t.c 为 0x00，则 t.c != 1，反之是小端  
    return (t.c == 1);  
}  
```

**答案解析**

1.  **在进行网络通信时是否需要进行字节序转换？**

    相同字节序的平台在进行网络通信时可以不进行字节序转换，但是跨平台进行网络数据通信时必须进行字节序转换。

    原因如下：网络协议规定接收到得第一个字节是高字节，存放到低地址，所以发送时会首先去低地址取数据的高字节。小端模式的多字节数据在存放时，低地址存放的是低字节，而被发送方网络协议函数发送时会首先去低地址取数据（想要取高字节，真正取得是低字节），接收方网络协议函数接收时会将接收到的第一个字节存放到低地址（想要接收高字节，真正接收的是低字节），所以最后双方都正确的收发了数据。而相同平台进行通信时，如果双方都进行转换最后虽然能够正确收发数据，但是所做的转换是没有意义的，造成资源的浪费。而不同平台进行通信时必须进行转换，不转换会造成错误的收发数据，字节序转换函数会根据当前平台的存储模式做出相应正确的转换，如果当前平台是大端，则直接返回不进行转换，如果当前平台是小端，会将接收到得网络字节序进行转换。

2.  **网络字节序**

    网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题; UDP/TCP/IP 协议规定:把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的; 所以说,网络字节序是大端字节序; 比如,我们经过网络发送整型数值 0x12345678 时,在 80X86 平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数 htonl()将其转换成大端法存放的数值;