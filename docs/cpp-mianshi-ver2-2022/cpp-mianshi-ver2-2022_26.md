# 第二章 第 3 节 C++操作系统-3

> 原文：[`www.nowcoder.com/tutorial/10069/b32eab9fad4b40988ed777c1b0434060`](https://www.nowcoder.com/tutorial/10069/b32eab9fad4b40988ed777c1b0434060)

### 2.22 32 位系统能访问 4GB 以上的内存吗？

**参考回答**

**正常情况下是不可以的**。原因是计算机使用二进制，每位数只有 0 或 1 两个状态，32 位正好是 2 的 32 次方，正好是 4G，所以大于 4G 就没办法表示了，而在 32 位的系统中，因其它原因还需要占用一部分空间，所以内存只能识别 3G 多。要使用 4G 以上就只能换 64 位的操作系统了。

但是使用**PAE 技术**就可以实现 32 位系统能访问 4GB 以上的内存。

**答案解析**

Physical Address Extension（PAE）技术最初是为了弥补 32 位地址在 PC 服务器应用上的不足而推出的。我们知道，传统的 IA32 架构只有 32 位地址总线，只能让系统容纳不超过 4GB 的内存，这么大的内存，对于普通的桌面应用应该说是足够用了。可是，对于服务器应用来说，还是显得不足，因为服务器上可能承载了很多同时运行的应用。PAE 技术将地址扩展到了 36 位，这样，系统就能够容纳 2³⁶=64GB 的内存。

### 2.23 请你说说并发和并行

**参考回答**

1.  **并发**：对于单个 CPU，在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级，多个任务不停来回快速切换。

2.  **并行**：对于多个 CPU，多个进程同时运行。

3.  **区别**。通俗来讲，它们虽然都说是"多个进程同时运行"，但是它们的"同时"不是一个概念。并行的"同时"是同一时刻可以多个任务在运行(处于 running)，并发的"同时"是经过不同线程快速切换，使得看上去多个任务同时都在运行的现象。

### 2.24 说说进程、线程、协程是什么，区别是什么？

**参考回答**

1.  **进程**：程序是指令、数据及其组织形式的描述，而进程则是程序的运行实例，包括程序计数器、寄存器和变量的当前值。

2.  **线程**：微进程，一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务。

3.  **协程**：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。

**区别**：

1.  **线程与进程的区别**：

    （1）一个线程从属于一个进程；一个进程可以包含多个线程。

    （2）一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。

    （3）进程是系统资源调度的最小单位；线程 CPU 调度的最小单位。

    （4）进程系统开销显著大于线程开销；线程需要的系统资源更少。

    （5）进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。

    （6）进程切换时需要刷新 TLB 并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。

    （7）通信方式不一样。

    （8）进程适应于多核、多机分布；线程适用于多核

2.  **线程与协程的区别：**

    （1）协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小。

    （2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。

    （3）一个线程可以有多个协程。

### 2.25 请你说说 Linux 的 fork 的作用

**参考回答**

fork 函数用来创建一个子进程。对于父进程，fork()函数返回新创建的子进程的 PID。对于子进程，fork()函数调用成功会返回 0。如果创建出错，fork()函数返回-1。

**答案解析**

fork()函数，其原型如下：

```cpp
#include <unistd.h>  
pid_t fork(void);  
```

fork()函数不需要参数，返回值是一个进程标识符 PID。返回值有以下三种情况：

（1） 对于父进程，fork()函数返回新创建的子进程的 PID。
（2） 对于子进程，fork()函数调用成功会返回 0。
（3） 如果创建出错，fork()函数返回-1。

fork()函数创建一个新进程后，会为这个新进程分配进程空间，将父进程的进程空间中的内容复制到子进程的进程空间中，包括父进程的数据段和堆栈段，并且和父进程共享代码段。这时候，子进程和父进程一模一样，都接受系统的调度。因为两个进程都停留在 fork()函数中，最后 fork()函数会返回两次，一次在父进程中返回，一次在子进程中返回，两次返回的值不一样，如上面的三种情况。

### 2.26 请你说说什么是孤儿进程，什么是僵尸进程，如何解决僵尸进程

**参考回答**

1.  **孤儿进程**：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为 1）所收养，并且由 init 进程对它们完整状态收集工作。

2.  **僵尸进程**：是指一个进程使用 fork 函数创建子进程，如果子进程退出，而父进程并没有调用 wait()或者 waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。

3.  **如何解决僵尸进程**：

    （1）一般，为了防止产生僵尸进程，在 fork 子进程之后我们都要及时使用**wait 系统调用**；同时，当子进程退出的时候，内核都会给父进程一个 SIGCHLD 信号，所以我们可以建立一个捕获 SIGCHLD 信号的信号处理函数，在函数体中调用 wait（或 waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。

    （2）**使用 kill 命令**。

    ​ 打开终端并输入下面命令:

    ```cpp
        ps aux | grep Z
    ```

    ​ 会列出进程表中所有僵尸进程的详细内容。

    ​ 然后输入命令：

    ```cpp
        kill -s SIGCHLD pid(父进程 pid)
    ```

### 2.27 请你说说什么是守护进程，如何实现？

**参考回答**

1.  **守护进程**：守护进程是运行在后台的一种生存期长的特殊进程。它独立于控制终端，处理一些系统级别任务。

2.  **如何实现**：

    （1）创建子进程，终止父进程。方法是调用 fork() 产生一个子进程，然后使父进程退出。

    （2）调用 setsid() 创建一个新会话。

    （3）将当前目录更改为根目录。使用 fork() 创建的子进程也继承了父进程的当前工作目录。

    （4）重设文件权限掩码。文件权限掩码是指屏蔽掉文件权限中的对应位。

    （5）关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。

**答案解析**

实现代码如下：

```cpp
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
#include <fcntl.h>  
#include <unistd.h>  
#include <sys/wait.h>  
#include <sys/types.h>  
#include <sys/stat.h>  

#define MAXFILE 65535  

int main(){  
    //第一步:创建进程   
    int pid = fork();  
    if (pid > 0)  
        exit(0);//结束父进程   
    else if (pid < 0){  
        printf("fork error!\n");  
        exit(1);//fork 失败，退出   
    }  
    //第二步:子进程成为新的会话组长和进程组长,并与控制终端分离   
       setsid();  
    //第三步:改变工作目录到  
    chdir("/");  
    //第四步:重设文件创建掩模   
    umask(0);  
    //第五步:关闭打开的文件描述符  
    for (int i=0; i<MAXFILE; ++i)   
        close(i); 
        sleep(2);  
    }  
    return 0;  
}  
```

### 2.28 说说进程通信的方式有哪些？

**参考回答**

进程间通信主要包括**管道**、**系统 IPC**（包括消息队列、信号量、信号、共享内存）、**套接字 socket**。

1.  **管道**：包括无名管道和命名管道，无名管道半双工，只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程），可以看作一种特殊的文件；命名管道可以允许无亲缘关系进程间的通信。

2.  **系统 IPC**

    **消息队列**：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。

    **信号量 semaphore**：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。

    **信号**：用于通知接收进程某个事件的发生。

    **内存共享**：使多个进程访问同一块内存空间。

3.  **套接字 socket**：用于不同主机直接的通信。

### 2.29 说说进程同步的方式？

**参考回答**

1.  **信号量 semaphore**：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。P 操作(递减操作)可以用于阻塞一个进程，V 操作(增加操作)可以用于解除阻塞一个进程。
2.  **管道**：一个进程通过调用管程的一个过程进入管程。在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。
3.  **消息队列**：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。

### 2.30 说说 Linux 进程调度算法及策略有哪些？

**参考回答**

1.  先来先服务调度算法
2.  短作业(进程)优先调度算法
3.  高优先级优先调度算法
4.  时间片轮转法
5.  多级反馈队列调度算法

**答案解析**

1.  先来先服务调度算法：每次调度都是从后备作业（进程）队列中选择一个或多个最先进入该队列的作业（进程），将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。
2.  短作业(进程)优先调度算法：短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业（进程），将它们调入内存运行。
3.  高优先级优先调度算法：当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程
4.  时间片轮转法：每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。
5.  多级反馈队列调度算法：综合前面多种调度算法。

在这些调度算法中，有抢占式和非抢占式的区别。

1.  非抢占式优先权算法
    在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。
2.  抢占式优先权调度算法
    在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程 i 时，就将其优先权 Pi 与正在执行的进程 j 的优先权 Pj 进行比较。如果 Pi≤Pj，原进程 Pj 便继续执行；但如果是 Pi>Pj，则立即停止 Pj 的执行，做进程切换，使 i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。

区别：

非抢占式（Nonpreemptive）：让进程运行直到结束或阻塞的调度方式，容易实现，适合专用系统，不适合通用系统。
抢占式（Preemptive）：允许将逻辑上可继续运行的在运行过程暂停的调度方式可防止单一进程长时间独占，CPU 系统开销大（降低途径：硬件实现进程切换，或扩充主存以贮存大部分程序）