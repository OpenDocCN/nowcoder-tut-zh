# 第一章 第 14 节 C++stl-1

> 原文：[`www.nowcoder.com/tutorial/10069/623fb615a9ae403d8eb5509015ce9dd0`](https://www.nowcoder.com/tutorial/10069/623fb615a9ae403d8eb5509015ce9dd0)

### 1.4 STL

#### 1.4.1 请说说 STL 的基本组成部分

**参考回答**

​ 标准模板库（Standard Template Library,简称 STL）简单说，就是一些常用数据结构和算法的模板的集合。

​ **广义上讲**，STL 分为 3 类：Algorithm（算法）、Container（容器）和 Iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。

​ **详细的说**，STL 由 6 部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。

**答案解析**

​ 标准模板库 STL 主要由 6 大组成部分：

1.  容器(Container)

    ​ 是一种数据结构， 如 list, vector, 和 deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。

2.  算法（Algorithm）

    ​ 是用来操作容器中的数据的模板函数。例如，STL 用 sort()来对一 个 vector 中的数据进行排序，用 find()来搜索一个 list 中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。

3.  迭代器（Iterator）

    ​ 提供了访问容器中对象的方法。例如，可以使用一对迭代器指定 list 或 vector 中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了 operator*()以及其他类似于指针的操作符方法的类对象;

4.  仿函数（Function object）

    ​ 仿函数又称之为函数对象， 其实就是重载了操作符的 struct,没有什么特别的地方。

5.  适配器（Adaptor）

    ​ 简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括 3 中适配器 Container Adaptor、Iterator Adaptor、Function Adaptor。

6.  空间配制器（Allocator）

    ​ 为 STL 提供空间配置的系统。其中主要工作包括两部分：

    （1）对象的创建与销毁；

    （2）内存的获取与释放。

#### 1.4.2 请说说 STL 中常见的容器，并介绍一下实现原理

**参考回答**

​ 容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：

1.  顺序容器

    ​ 容器并非排序的，元素的插入位置同元素的值无关。包含 vector、deque、list，具体实现原理如下：

    （1）vector 头文件

    ​ 动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。

    （2）deque 头文件

    ​ 双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于 vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

    （3）list 头文件

    ​ 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。

2.  关联式容器

    ​ 元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含 set、multiset、map、multimap，具体实现原理如下：

    （1）set/multiset 头文件

    ​ set 即集合。set 中不允许相同元素，multiset 中允许存在相同元素。

    （2）map/multimap 头文件<map></map>

    ​ map 与 set 的不同在于 map 中存放的元素有且仅有两个成员变，一个名为 first,另一个名为 second, map 根据 first 值对元素从小到大排序，并可快速地根据 first 来检索元素。

    ​ **注意：**map 同 multimap 的不同在于是否允许相同 first 值的元素。

3.  容器适配器

    ​ 封装了一些基本的容器，使之具备了新的函数功能，比如把 deque 封装一下变为一个具有 stack 功能的数据结构。这新得到的数据结构就叫适配器。包含 stack,queue,priority_queue，具体实现原理如下：

    （1）stack 头文件<stack></stack>

    ​ 栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。

    （2）queue 头文件

    ​ 队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。

    （3）priority_queue 头文件

    ​ 优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。

#### 1.4.3 说说 STL 中 map hashtable deque list 的实现原理

**参考回答**

​ map、hashtable、deque、list 实现机理分别为红黑树、函数映射、双向队列、双向链表，他们的特性分别如下：

1.  map 实现原理

    ​ map 内部实现了一个**红黑树**（红黑树是非严格平衡的二叉搜索树，而 AVL 是严格平衡二叉搜索树），红黑树有自动排序的功能，因此 map 内部所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map 中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。

2.  hashtable（也称散列表，直译作哈希表）实现原理

    ​ hashtable 采用了**函数映射的思想**记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。这决定了哈希表特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。

3.  deque 实现原理

    ​ deque 内部实现的是一个**双向队列**。元素在内存连续存放。随机存取任何元素都在常数时间完成（仅次于 vector）。所有适用于 vector 的操作都适用于 deque。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

4.  list 实现原理

    ​ list 内部实现的是一个**双向链表**。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。无成员函数，给定一个下标 i，访问第 i 个元素的内容，只能从头部挨个遍历到第 i 个元素。

#### 1.4.4 请你来介绍一下 STL 的空间配置器（allocator）

**参考回答**

​ 一般情况下,一个程序包括数据结构和相应的算法，而数据结构作为存储数据的组织形式，与内存空间有着密切的联系。在 C++ STL 中，空间配置器便是用来实现内存空间(一般是内存，也可以是硬盘等空间)分配的工具，他与容器联系紧密，每一种容器的空间分配都是通过空间分配器 alloctor 实现的。

**答案解析**

1.  两种 C++类对象实例化方式的异同

    ​ 在 c++中，创建类对象一般分为两种方式：一种是直接利用构造函数,直接构造类对象，如 Test test()；另一种是通过 new 来实例化一个类对象，如 Test *pTest = new Test；那么，这两种方式有什么异同点呢？

    我们知道，内存分配主要有三种方式：

    （1） 静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行空间内都存在。如全局变量,静态变量等。

    （2） 栈空间分配：程序在运行期间，函数内的局部变量通过栈空间来分配存储（函数调用栈），当函数执行完毕返回时，相对应的栈空间被立即回收。主要是局部变量。
    （3）堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，通过 malloc 和 new 创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过 free()或者是 delete()函数对堆空间进行释放，否则会造成内存溢出。

    那么，从**内存空间分配的角度**来对这两种方式的区别，就比较容易区分:

    （1）对于第一种方式来说，是直接通过调用 Test 类的构造函数来实例化 Test 类对象的,如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间。
    （2）对于第二种方式来说,就显得比较复杂。这里主要以 new 类对象来说明一下。new 一个类对象,其实是执行了两步操作：首先,调用 new 在堆空间分配内存,然后调用类的构造函数构造对象的内容；同样，使用 delete 释放时，也是经历了两个步骤：首先调用类的析构函数释放类对象，然后调用 delete 释放堆空间。

2.  C++ STL 空间配置器实现

    ​ 很容易想象，为了实现空间配置器，完全可以利用 new 和 delete 函数并对其进行封装实现 STL 的空间配置器，的确可以这样。但是，为了最大化提升效率，SGI STL 版本并没有简单的这样做，而是采取了一定的措施，实现了更加高效复杂的空间分配策略。由于以上的构造都分为两部分，所以，在 SGI STL 中，将对象的构造切分开来，分成空间配置和对象构造两部分。

    ​ 内存配置操作: 通过 alloc::allocate()实现
    ​ 内存释放操作: 通过 alloc::deallocate()实现
    ​ 对象构造操作: 通过::construct()实现
    ​ 对象释放操作: 通过::destroy()实现

    ​ 关于内存空间的配置与释放，SGI STL 采用了两级配置器：一级配置器主要是考虑大块内存空间，利用 malloc 和 free 实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用链表 free_list 来维护内存池（memory pool），free_list 通过 union 结构实现，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。

#### 1.4.5 STL 容器用过哪些，查找的时间复杂度是多少，为什么？

**参考回答**

​ STL 中常用的容器有 vector、deque、list、map、set、multimap、multiset、unordered_map、unordered_set 等。容器底层实现方式及时间复杂度分别如下：

1.  vector

    采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为：

    插入: O(N)

    查看: O(1)

    删除: O(N)

2.  deque

    采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为：

    插入: O(N)

    查看: O(1)

    删除: O(N)

3.  list

    采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为：

    插入: O(1)

    查看: O(N)

    删除: O(1)

4.  map、set、multimap、multiset

    上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:

    插入: O(logN)

    查看: O(logN)

    删除: O(logN)

5.  unordered_map、unordered_set、unordered_multimap、 unordered_multiset

    上述四种容器采用哈希表实现，不同操作的时间复杂度为：
    插入: O(1)，最坏情况 O(N)

    查看: O(1)，最坏情况 O(N)

    删除: O(1)，最坏情况 O(N)

    **注意：**容器的时间复杂度取决于其底层实现方式。