# 第一章 第 4 节 语言基础-4

> 原文：[`www.nowcoder.com/tutorial/10069/ad6b48325414495293d576d648ddcd8d`](https://www.nowcoder.com/tutorial/10069/ad6b48325414495293d576d648ddcd8d)

#### 1.1.10 说说什么是函数指针，如何定义函数指针，有什么使用场景

**参考回答**

1.  **概念：**函数指针就是**指向函数**的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。

2.  **定义**形式如下：

```cpp
int func(int a);  
int (*f)(int a);  
f = &func;  
```

3.  函数指针的**应用场景**：**回调**（callback）。我们调用别人提供的 API 函数(Application Programming Interface,应用程序编程接口)，称为 Call；如果别人的库里面调用我们的函数，就叫 Callback。

**答案解析**

```cpp
//以库函数 qsort 排序函数为例，它的原型如下：
void qsort(void *base,//void*类型，代表原始数组
           size_t nmemb, //第二个是 size_t 类型，代表数据数量
           size_t size, //第三个是 size_t 类型，代表单个数据占用空间大小
           int(*compar)(const void *,const void *)//第四个参数是函数指针
          );
//第四个参数告诉 qsort，应该使用哪个函数来比较元素，即只要我们告诉 qsort 比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数 qsort 调用我们自定义的比较函数，这就是回调的应用。

//示例
int num[100];
int cmp_int(const void* _a , const void* _b){//参数格式固定
    int* a = (int*)_a;    //强制类型转换
    int* b = (int*)_b;
    return *a - *b;　　
}
qsort(num,100,sizeof(num[0]),cmp_int); //回调
```

#### 1.1.11 说说静态变量什么时候初始化？

**参考回答**

对于 C 语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。

而 C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。

**答案解析**

1.  **作用域**：C++里作用域可分为 6 种：全局，局部，类，语句，命名空间和文件作用域。

    静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。

    静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。

    类静态成员变量：类作用域。

2.  **所在空间**：都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。

3.  **生命周期**：静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。

#### 1.1.12 nullptr 调用成员函数可以吗？为什么？

**参考回答**

能。

原因：因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。

**答案解析**

```cpp
//给出实例
class animal{
public:
    void sleep(){ cout << "animal sleep" << endl; }
    void breathe(){ cout << "animal breathe haha" << endl; }
};
class fish :public animal{
public:
    void breathe(){ cout << "fish bubble" << endl; }
};
int main(){
    animal *pAn=nullptr;
    pAn->breathe();   // 输出：animal breathe haha
    fish *pFish = nullptr;
    pFish->breathe(); // 输出：fish bubble
    return 0;
}  
```

原因：因为在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。pAn->breathe();编译的时候，函数的地址就和指针 pAn 绑定了；调用 breath(*this), this 就等于 pAn。由于函数中没有需要解引用 this 的地方，所以函数运行不会出错，但是若用到 this，因为 this=nullptr，运行出错。

#### 1.1.13 说说什么是野指针，怎么产生的，如何避免？

**参考回答**

1.  **概念：**野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）

2.  **产生原因**：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。

3.  **避免办法：**

    （1）初始化置 NULL

    （2）申请内存后判空

    （3）指针释放后置 NULL

    （4）使用智能指针

**答案解析**

**产生原因**：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。如：

```cpp
char *p = (char *)malloc(sizeof(char)*100);  
strcpy(p, "Douya");  
free(p);//p 所指向的内存被释放，但是 p 所指的地址仍然不变  
...  
if (p != NULL){//没有起到防错作用  
    strcpy(p, "hello, Douya!");//出错  
}  
```

**避免办法：**

（1）初始化置 NULL

（2）申请内存后判空

（3）指针释放后置 NULL

```cpp
int *p = NULL; //初始化置 NULL
p = (int *)malloc(sizeof(int)*n); //申请 n 个 int 内存空间  
assert(p != NULL); //判空，防错设计
p = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址
free(p);  
p = NULL; //释放后置空

int *p1 = NULL; //初始化置 NULL
p1 = (int *)calloc(n, sizeof(int)); //申请 n 个 int 内存空间同时初始化为 0 
assert(p1 != NULL); //判空，防错设计
free(p1);  
p1 = NULL; //释放后置空

int *p2 = NULL; //初始化置 NULL
p2 = new int[n]; //申请 n 个 int 内存空间  
assert(p2 != NULL); //判空，防错设计
delete []p2;  
p2 = nullptr; //释放后置空  
```

#### 1.1.14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景

**参考回答**

1.  **首先从作用域考虑**：C++里作用域可分为 6 种：全局，局部，类，语句，命名空间和文件作用域。

    全局变量：全局作用域，可以通过 extern 作用于其他非定义的源文件。

    静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。

    局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。

    静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。

2.  **从所在空间考虑**：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。

3.  **生命周期**： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。

4.  **使用场景**：从它们各自特点就可以看出各自的应用场景，不再赘述。

#### 1.1.15 说说内联函数和宏函数的区别

**参考回答**

区别：

1.  **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；**而内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。
2.  **宏函数**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；**而内联函数**则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率
3.  **宏定义**是没有类型检查的，无论对还是错都是直接替换；**而内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等

**答案解析**

```cpp
//宏定义示例
#define MAX(a，b) ((a)>(b)?(a):(b))
MAX(a,"Hello")； //错误地比较 int 和字符串，没有参数类型检查

//内联函数示例
#include <stdio.h>
inline int add(int a, int b){
    return (a + b);
}
int main(void){
    int a;
    a = add(1, 2);
    printf("a+b=%d\n", a);
    return 0;
}
//以上 a = add(1, 2);处在编译时将被展开为：a = (a + b);
```

**1、使用时的一些注意事项：**

*   使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性
*   inline 函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字 inline，即可将函数指定为 inline 函数。
*   同其它函数不同的是，最好将 inline 函数定义在头文件，而不仅仅是声明，因为编译器在处理 inline 函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。

**2、内联函数使用的条件：**

*   内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：
*   （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
*   （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
*   内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。

#### 1.1.16 说说运算符 i++和++i 的区别

**参考回答**

**先看到实现代码：**

```cpp
#include <stdio.h>
int main(){
       int i = 2;
    int j = 2;
    j += i++; //先赋值后加
    printf("i= %d, j= %d\n",i, j); //i= 3, j= 4
    i = 2;
    j = 2;
    j += ++i; //先加后赋值
    printf("i= %d, j= %d",i, j); //i= 3, j= 5
}
```

1.  **赋值顺序不同**：++ i 是先加后赋值；i ++ 是先赋值后加；++i 和 i++都是分两步完成的。

2.  **效率不同**：后置++执行速度比前置的慢。

3.  **i++ 不能作为左值，而++i 可以**：

    ```cpp
    int i = 0;
    int *p1 = &（++i）；//正确
    int *p2 = &（i++）；//错误
    ++i = 1；//正确
    i++ = 1；//错误
    ```

4.  两者都不是原子操作。

#### 1.1.17 说说 new 和 malloc 的区别，各自底层实现原理。

**参考回答**

1.  new 是操作符，而 malloc 是函数。
2.  new 在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而 malloc 没有构造函数和析构函数。
3.  malloc 需要给定申请内存的大小，返回的指针需要强转；new 会调用构造函数，不用指定内存的大小，返回指针不用强转。
4.  new 可以被重载；malloc 不行
5.  new 分配内存更直接和安全。
6.  new 发生错误抛出异常，malloc 返回 null

**答案解析**

**malloc 底层实现：**当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用 mmap（）。malloc 采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

**new 底层实现：**关键字 new 在调用构造函数的时候实际上进行了如下的几个步骤：

1.  创建一个新的对象
2.  将构造函数的作用域赋值给这个新的对象（因此 this 指向了这个新的对象）
3.  执行构造函数中的代码（为这个新对象添加属性）
4.  返回新对象

#### 1.1.18 说说 const 和 define 的区别。

**参考回答**

const 用于定义常量；而 define 用于定义宏，而宏也可以用于定义常量。都用于常量定义时，它们的区别有：

1.  const 生效于编译的阶段；define 生效于预处理阶段。
2.  const 定义的常量，在 C 语言中是存储在内存中、需要额外的内存空间的；define 定义的常量，运行时是直接的操作数，并不会存放在内存中。
3.  const 定义的常量是带类型的；define 定义的常量不带类型。因此 define 定义的常量不利于类型检查。