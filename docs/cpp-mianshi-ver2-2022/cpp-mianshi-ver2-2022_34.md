# 第三章 第 4 节 C++计算机网络-4

> 原文：[`www.nowcoder.com/tutorial/10069/5bcff6dba3f84f05a3aba1d1baedffe1`](https://www.nowcoder.com/tutorial/10069/5bcff6dba3f84f05a3aba1d1baedffe1)

### 3.28 简述 TCP 协议的延迟 ACK 和累计应答

**参考回答**

1.  延迟应答指的是：TCP 在接收到对端的报文后，并不会立即发送 ack，而是等待一段时间发送 ack，以便将 ack 和要发送的数据一块发送。当然 ack 不能无限延长，否则对端会认为包超时而造成报文重传。linux 采用动态调节算法来确定延时的时间。

2.  累计应答指的是：为了保证**顺序性**，每一个包都有一个**ID**（序号），在建立连接的时候，会商定起始的 ID 是多少，然后按照 ID 一个个发送。而为了保证不丢包，对应发送的包都要进行应答，但不是一个个应答，而是会**应答某个之前的 ID**，该模式称为**累计应答**

### 3.29 说说 TCP 如何加速一个大文件的传输

**参考回答**

1.  建连优化：TCP 在建立连接时，如果丢包，会进入重试，重试时间是 1s、2s、4s、8s 的指数递增间隔，缩短定时器可以让 TCP 在丢包环境建连时间更快，非常适用于高并发短连接的业务场景。

2.  平滑发包：在 RTT 内均匀发包，规避微分时间内的流量突发，尽量避免瞬间拥塞

3.  丢包预判：有些网络的丢包是有规律性的，例如每隔一段时间出现一次丢包，例如每次丢包都连续丢几个等，如果程序能自动发现这个规律（有些不明显），就可以针对性提前多发数据，减少重传时间、提高有效发包率。

4.  RTO 探测：若始终收不到 ACK 报文，则需要触发 RTO 定时器。RTO 定时器一般都时间非常长，会浪费很多等待时间，而且一旦 RTO，CWND 就会骤降（标准 TCP），因此利用 Probe 提前与 RTO 去试探，可以规避由于 ACK 报文丢失而导致的速度下降问题。

5.  带宽评估：通过单位时间内收到的 ACK 或 SACK 信息可以得知客户端有效接收速率，通过这个速率可以更合理的控制发包速度。

6.  带宽争抢：有些场景（例如合租）是大家互相挤占带宽的，假如你和室友各 1Mbps 的速度看电影，会把 2Mbps 出口占满，而如果一共有 3 个人看，则每人只能分到 1/3。若此时你的流量流量达到 2Mbps，而他俩还都是 1Mbps，则你至少仍可以分到 2/(2+1+1) * 2Mbps = 1Mbps 的 50% 的带宽，甚至更多，代价就是服务器侧的出口流量加大，增加成本。（TCP 优化的本质就是用带宽换用户体验感）

### 3.30 服务器怎么判断客户端断开了连接

**参考回答**

1.  检测连接是否丢失的方法大致有两种：**keepalive**和**heart-beat**

2.  （tcp 内部机制）采用 keepalive，它会先要求此连接一定时间没有活动（一般是几个小时），然后发出数据段，经过多次尝试后（每次尝试之间也有时间间隔），如果仍没有响应，则判断连接中断。可想而知，整个**周期需要很长**的时间。

3.  （应用层实现）一个简单的 heart-beat 实现一般测试连接是否中断采用的时间间隔都比较短，可以**很快的决定连接是否中断**。并且，由于是在应用层实现，因为可以自行决定当判断连接中断后应该采取的行为，而 keepalive 在判断连接失败后只会将连接丢弃。

### 3.31 说说端到端，点到点的区别

**参考回答**

1.  端到端通信是针对传输层来说的，传输层为网络中的主机提供端到端的通信。因为无论 tcp 还是 udp 协议，都要负责把上层交付的数据从发送端传输到接收端，不论其中间跨越多少节点。只不过 tcp 比较可靠而 udp 不可靠而已。所以称之为端到端，也就是从发送端到接收端。

    它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据，知道数据发送完毕，接收端确认接收成功。 也就是说在数据传输之前，先为数据的传输开辟一条通道，然后在进行传输。从发送端发出数据到接收端接收完毕，结束。

    端到端通信建立在点到点通信的基础之上，它是由一段段的点到点通信信道构成的，是比点到点通信更高一级的通信方式，完成应用程序(进程)之间的通信。

    端到端的优点：

    链路建立之后，发送端知道接收端一定能收到，而且经过中间交换设备时不需要进行存储转发，因此传输延迟小。

    端到端传输的缺点：

    （1）直到接收端收到数据为止，发送端的设备一直要参与传输。如果整个传输的延迟很长，那么对发送端的设备造成很大的浪费。

    （2）如果接收设备关机或故障，那么端到端传输不可能实现。

2.  点到点通信是针对数据链路层或网络层来说的，因为数据链路层只负责直接相连的两个节点之间的通信，一个节点的数据链路层接受 ip 层数据并封装之后，就把数据帧从链路上发送到与其相邻的下一个节点。 点对点是基于 MAC 地址和或者 IP 地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。

    直接相连的节点对等实体的通信叫点到点通信。它只提供一台机器到另一台机器之间的通信，不会涉及到程序或进程的概念。同时点到点通信并不能保证数据传输的可靠性，也不能说明源主机与目的主机之间是哪两个进程在通信。

    由物理层、数据链路层和网络层组成的通信子网为网络环境中的主机提供点到点的服务

    点到点的优点：

    （1）发送端设备送出数据后，它的任务已经完成，不需要参与整个传输过程，这样不会浪费发送端设备的资源。

    （2）即使接收端设备关机或故障，点到点传输也可以采用存储转发技术进行缓冲。

    点到点的缺点：

    点到点传输的缺点是发送端发出数据后，不知道接收端能否收到或何时能收到数据。

    在一个网络系统的不同分层中，可能用到端到端传输，也可能用到点到点传输。如 Internet 网，IP 及以下各层采用点到点传输，4 层以上采用端到端传输。

### 3.32 说说浏览器从输入 URL 到展现页面的全过程

**参考回答**

*   1、输入地址

*   2、浏览器查找域名的 IP 地址

*   3、浏览器向 web 服务器发送一个 HTTP 请求

*   4、服务器的永久重定向响应

*   6、服务器处理请求

*   7、服务器返回一个 HTTP 响应

*   8、浏览器显示 HTML

*   9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS 等等）

### 3.33 简述 HTTP 和 HTTPS 的区别？

**参考回答**

1.  HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

    HTTPS：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。

    HTTPS 协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

2.  HTTP 与 HTTPS 的区别 　　

*   https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。 　　
*   http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。
*   http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 　　
*   http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。

### 3.34 说说 HTTP 中的 referer 头的作用

**参考回答**

1.  HTTP Referer 是 header 的一部分，当浏览器向 web 服务器发送请求的时候，一般会带上 Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。

2.  防盗链。假如在[www.google.com 里有一个\`www.baidu.com\`链接，那么点击进入这个\`www.baidu.com\`，它的 header 信息里就有：Referer=](http://www.google.com%E9%87%8C%E6%9C%89%E4%B8%80%E4%B8%AA%5C%60www.baidu.com%5C%60%E9%93%BE%E6%8E%A5%EF%BC%8C%E9%82%A3%E4%B9%88%E7%82%B9%E5%87%BB%E8%BF%9B%E5%85%A5%E8%BF%99%E4%B8%AA%5C%60www.baidu.com%5C%60%EF%BC%8C%E5%AE%83%E7%9A%84header%E4%BF%A1%E6%81%AF%E9%87%8C%E5%B0%B1%E6%9C%89%EF%BC%9AReferer=) [`www.google.com`](http://www.google.com)

    只允许我本身的网站访问本身的图片服务器，假如域是`www.google.com`，那么图片服务器每次取到 Referer 来判断一下域名是不是`www.google.com`，如果是就继续访问，不是就拦截。

    将这个 http 请求发给服务器后，如果服务器要求必须是某个地址或者某几个地址才能访问，而你发送的 referer 不符合他的要求，就会拦截或者跳转到他要求的地址，然后再通过这个地址进行访问。

3.  防止恶意请求

    比如静态请求是`*.html`结尾的，动态请求是`*.shtml`，那么由此可以这么用，所有的`*.shtml`请求，必须 Referer 为我自己的网站。

4.  空 Referer

    **定义**：Referer 头部的内容为空，或者，一个 HTTP 请求中根本不包含 Referer 头部（一个请求并不是由链接触发产生的）

    直接在浏览器的地址栏中输入一个资源的 URL 地址，那么这种请求是不会包含 Referer 字段的，因为这是一个“凭空产生”的 HTTP 请求，并不是从一个地方链接过去的。

    那么在防盗链设置中，允许空 Referer 和不允许空 Referer 有什么区别？

    允许 Referer 为空，意味着你允许比如浏览器直接访问。

5.  防御 CSRF

    比对 HTTP 请求的来源地址，如果 Referer 中的地址是安全可信任的地址，那么就放行

### 3.35 说说 HTTP 的方法有哪些

**参考回答**

*   GET： 用于请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL 传参给服务器
*   POST：用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐使用 POST 方式。
*   PUT： 传输文件，报文主体中包含文件内容，保存到对应 URI 位置。
*   HEAD： 获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。
*   DELETE：删除文件，与 PUT 方法相反，删除对应 URI 位置的文件。
*   OPTIONS：查询相应 URI 支持的 HTTP 方法。

### 3.36 简述 HTTP 1.0，1.1，2.0 的主要区别

**参考回答**

http/1.0 :

1.  默认不支持长连接，需要设置 keep-alive 参数指定
2.  强缓存 expired、协商缓存 last-modified\if-modified-since 有一定的缺陷

http 1.1 :

1.  默认长连接(keep-alive)，http 请求可以复用 Tcp 连接，但是同一时间只能对应一个 http 请求(http 请求在一个 Tcp 中是串行的)
2.  增加了强缓存 cache-control、协商缓存 etag\if-none-match 是对 http/1 缓存的优化

http/2.0 :

1.  多路复用，一个 Tcp 中多个 http 请求是并行的 (雪碧图、多域名散列等优化手段 http/2 中将变得多余)
2.  二进制格式编码传输
3.  使用 HPACK 算法做 header 压缩
4.  服务端推送

### 3.37 说说 HTTP 常见的响应状态码及其含义

**参考回答**

*   **200** : 从状态码发出的请求被服务器正常处理。
*   **204** : 服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分【即没有内容】。
*   **206** : 部分的内容（如：客户端进行了范围请求，但是服务器成功执行了这部分的干请求）。
*   **301** : 跳转，代表永久性重定向（请求的资源已被分配了新的 URI，以后已使用资源，现在设置了 URI）。
*   **302** : 临时性重定向（请求的资源已经分配了新的 URI，希望用户本次能够使用新的 URI 来进行访问）。
*   **303** : 由于请求对应的资源存在的另一个 URI（因使用 get 方法，定向获取请求的资源）。
*   **304** : 客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回了 304。
*   **307** : 临时重定向【该状态码与 302 有着相同的含义】。
*   **400** : 请求报文中存在语法错误（当错误方式时，需修改请求的内容后，再次发送请求）。
*   **401** : 发送的请求需要有通过 HTTP 认证的认证信息。
*   **403** : 对请求资源的访问被服务器拒绝了。
*   **404** : 服务器上无法找到请求的资源。
*   **500** : 服务器端在执行请求时发生了错误。
*   **503** : 服务器暂时处于超负载或者是正在进行停机维护，现在无法处理请求。

**答案解析**

*   1XX : 信息类状态码（表示接收请求状态处理）
*   2XX : 成功状态码（表示请求正常处理完毕）
*   3XX : 重定向（表示需要进行附加操作，已完成请求）
*   4XX : 客户端错误（表示服务器无法处理请求）
*   5XX : 服务器错误状态码（表示服务器处理请求的时候出错）

### 3.38 说说 GET 请求和 POST 请求的区别

**参考回答**

1.  GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。

2.  GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。

3.  GET 参数通过 URL 传递，POST 放在 Request body 中。

4.  GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。

5.  GET 请求只能进行 url 编码，而 POST 支持多种编码方式。

6.  GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。

7.  GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。

8.  GET 在浏览器回退时是无害的，而 POST 会再次提交请求。

### 3.39 说说 Cookie 和 Session 的关系和区别是什么

**参考回答**

1.  Cookie 与 Session 都是会话的一种方式。它们的典型使用场景比如“购物车”，当你点击下单按钮时，服务端并不清楚具体用户的具体操作，为了标识并跟踪该用户，了解购物车中有几样物品，服务端通过为该用户创建 Cookie/Session 来获取这些信息。

2.  cookie 数据存放在客户的浏览器上，session 数据放在服务器上。

3.  cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗 考虑到安全应当使用 session。

4.  session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用 COOKIE。

5.  单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。

### 3.40 简述 HTTPS 的加密与认证过程

**参考回答**

1.  客户端在浏览器中输入一个 https 网址，然后连接到 server 的 443 端口 采用 https 协议的 server 必须有一套数字证书（一套公钥和密钥） 首先 server 将证书（公钥）传送到客户端 客户端解析证书，验证成功，则生成一个随机数（私钥），并用证书将该随机数加密后传回 server server 用密钥解密后，获得这个随机值，然后将要传输的信息和私钥通过某种算法混合在一起（加密）传到客户端 客户端用之前的生成的随机数（私钥）解密服务器端传来的信息

2.  首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。

    用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。