# 第四章 第 2 节 C++数据库-2

> 原文：[`www.nowcoder.com/tutorial/10069/48f34648ace64bffa195f6e420c6cebf`](https://www.nowcoder.com/tutorial/10069/48f34648ace64bffa195f6e420c6cebf)

#### 4.2.3 如何创建及保存 MySQL 的索引？

**参考答案**

MySQL 支持多种方法在单个或多个列上创建索引：

在创建表的时候创建索引：

使用 CREATE TABLE 创建表时，除了可以定义列的数据类型，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。创建表时创建索引的基本语法如下：

```cpp
CREATE TABLE table_name [col_name data_type]
[UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name [length]) [ASC|DESC]
```

其中，UNIQUE、FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；INDEX 与 KEY 为同义词，两者作用相同，用来指定创建索引。

例如，可以按照如下方式，在 id 字段上使用 UNIQUE 关键字创建唯一索引：

```cpp
CREATE TABLE t1 (
    id INT NOT NULL,
    name CHAR(30) NOT NULL,
    UNIQUE INDEX UniqIdx(id)
);
```

在已存在的表上创建索引

在已经存在的表中创建索引，可以使用 ALTER TABLE 语句或者 CREATEINDEX 语句。

ALTER TABLE 创建索引的基本语法如下：

```cpp
ALTER TABLE table_name ADD 
[UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name[length],...) [ASC|DESC]
```

例如，可以按照如下方式，在 bookId 字段上建立名称为 UniqidIdx 的唯一索引：

```cpp
ALTER TABLE book ADD UNIQUE INDEX UniqidIdx (bookId);
```

CREATE INDEX 创建索引的基本语法如下：

```cpp
CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name 
ON table_name (col_name [length],...) [ASC|DESC]
```

例如，可以按照如下方式，在 bookId 字段上建立名称为 UniqidIdx 的唯一索引：

```cpp
CREATE UNIQUE INDEX UniqidIdx ON book (bookId);
```

#### 4.2.4 MySQL 怎么判断要不要加索引？

**参考答案**

建议按照如下的原则来创建索引：

1.  当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。
2.  在频繁进行排序或分组（即进行 group by 或 order by 操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。

#### 4.2.5 只要创建了索引，就一定会走索引吗？

**参考答案**

不一定。

比如，在使用组合索引的时候，如果没有遵从“最左前缀”的原则进行搜索，则索引是不起作用的。

举例，假设在 id、name、age 字段上已经成功建立了一个名为 MultiIdx 的组合索引。索引行中按 id、name、age 的顺序存放，索引可以搜索 id、（id,name）、（id, name, age）字段组合。如果列不构成索引最左面的前缀，那么 MySQL 不能使用局部索引，如（age）或者（name,age）组合则不能使用该索引查询。

#### 4.2.6 如何判断数据库的索引有没有生效？

**参考答案**

可以使用 EXPLAIN 语句查看索引是否正在使用。

举例，假设已经创建了 book 表，并已经在其 year_publication 字段上建立了普通索引。执行如下语句：

```cpp
EXPLAIN SELECT * FROM book WHERE year_publication=1990;
```

EXPLAIN 语句将为我们输出详细的 SQL 执行信息，其中：

*   possible_keys 行给出了 MySQL 在搜索数据记录时可选用的各个索引。
*   key 行是 MySQL 实际选用的索引。

如果 possible_keys 行和 key 行都包含 year_publication 字段，则说明在查询时使用了该索引。

#### 4.2.7 如何评估一个索引创建的是否合理？

建议按照如下的原则来设计索引：

1.  避免对经常更新的表进行过多的索引，并且索引中的列要尽可能少。应该经常用于查询的字段创建索引，但要避免添加不必要的字段。
2.  数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。
3.  在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引，如果建立索引不但不会提高查询效率，反而会严重降低数据更新速度。
4.  当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。
5.  在频繁进行排序或分组（即进行 group by 或 order by 操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。

#### 4.2.8 索引是越多越好吗？

**参考答案**

索引并非越多越好，一个表中如有大量的索引，不仅占用磁盘空间，还会影响 INSERT、DELETE、UPDATE 等语句的性能，因为在表中的数据更改时，索引也会进行调整和更新。

#### 4.2.9 数据库索引失效了怎么办？

**参考答案**

可以采用以下几种方式，来避免索引失效：

1.  使用组合索引时，需要遵循“最左前缀”原则；
2.  不在索引列上做任何操作，例如计算、函数、类型转换，会导致索引失效而转向全表扫描；
3.  尽量使用覆盖索引（之访问索引列的查询），减少 `select *` 覆盖索引能减少回表次数；
4.  MySQL 在使用不等于（!=或者<>）的时候无法使用索引会导致全表扫描；
5.  LIKE 以通配符开头（%abc）MySQL 索引会失效变成全表扫描的操作；
6.  字符串不加单引号会导致索引失效（可能发生了索引列的隐式转换）；
7.  少用 or，用它来连接时会索引失效。

#### 4.2.10 所有的字段都适合创建索引吗？

**参考答案**

不是。

下列几种情况，是不适合创建索引的：

1.  频繁更新的字段不适合建立索引；
2.  where 条件中用不到的字段不适合建立索引；
3.  数据比较少的表不需要建索引；
4.  数据重复且分布比较均匀的的字段不适合建索引，例如性别、真假值；
5.  参与列计算的列不适合建索引。

#### 4.2.11 说一说索引的实现原理

**参考答案**

在 MySQL 中，索引是在存储引擎层实现的，不同存储引擎对索引的实现方式是不同的，下面我们探讨一下 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。

MyISAM 索引实现：

MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址，MyISAM 索引的原理图如下。这里假设表一共有三列，假设我们以 Col1 为主键，则上图是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。

![](img/353127ed91d335c73f2b437dde5b6b55.png)

如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示。同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。

![](img/805427432228d78107ca3581be7d9054.png)

InnoDB 索引实现：

虽然 InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却与 MyISAM 截然不同。

第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道，MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。

下图是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形。

![](img/051f49ef125100c4dc7c1b4c16f716d0.png)

第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说，InnoDB 的所有辅助索引都引用主键作为 data 域。下图为定义在 Col3 上的一个辅助索引。这里以英文字符的 ASCII 码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

![](img/82f4f38485460f5b59c3d244717be0a6.png)

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了 InnoDB 的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在 InnoDB 中不是个好主意，因为 InnoDB 数据文件本身是一颗 B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

#### 4.2.12 介绍一下数据库索引的重构过程

**参考答案**

什么时候需要重建索引呢？

1.  表上频繁发生 update,delete 操作；
2.  表上发生了 alter table ..move 操作（move 操作导致了 rowid 变化）。

怎么判断索引是否应该重建？

1.  一般看索引是否倾斜的严重，是否浪费了空间，对索引进行结构分析：

    ```cpp
    analyze index index_name validate structure;
    ```

2.  在相同的 session 中查询 index_stats 表：

    ```cpp
    select height,DEL_LF_ROWS/LF_ROWS from index_stats;
    ```

    当查询的 height>=4（索引的深度，即从根到叶节点的高度）或 DEL_LF_ROWS/LF_ROWS>0.2 的情况下，就应该考虑重建该索引。

如何重建索引？

*   drop 原索引，然后再创建索引：

    ```cpp
    drop index index_name;
    create index index_name on table_name (index_column);
    ```

    这种方式相当耗时，一般不建议使用。

*   直接重建索引：

    ```cpp
    alter index indexname rebuild;
    alter index indexname rebuild online;
    ```

    此方法较快，建议使用。

rebuild 是快速重建索引的一种有效的办法，因为它是一种使用现有索引项来重建新索引的方法。如果重建索引时有其他用户在对这个表操作，尽量使用带 online 参数来最大限度的减少索引重建时将会出现的任何加锁问题。由于新旧索引在建立时同时存在，因此，使用这种重建方法需要有额外的磁盘空间可供临时使用，当索引建完后把老索引删除，如果没有成功，也不会影响原来的索引。利用这种办法可以用来将一个索引移到新的表空间。

rebuild 重建索引的过程：

1.  Rebuild 以 index fast full scan 或 table full scan 方式（采用那种方式取决于 cost）读取原索引中的数据来构建一个新的索引，重建过程中有排序操作，rebuild online 执行表扫描获取数据，重建过程中有排序的操作；
2.  Rebuild 会阻塞 DML 操作，rebuild online 不会阻塞 DML 操作；
3.  rebuild online 时系统会产生一个 SYS_JOURNAL_xxx 的 IOT 类型的系统临时日志表，所有 rebuild online 时索引的变化都记录在这个表中，当新的索引创建完成后，把这个表的记录维护到新的索引中去，然后 drop 掉旧的索引，rebuild online 就完成了。

重建索引过程中的注意事项：

1.  执行 rebuild 操作时，需要检查表空间是否足够；
2.  虽然说 rebuild online 操作允许 DML 操作，但还是建议在业务不繁忙时间段进行；
3.  Rebuild 操作会产生大量 Redo Log；

#### 4.2.13 MySQL 的索引为什么用 B+树？

**参考答案**

B+树由 B 树和索引顺序访问方法演化而来，它是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在 B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点，各叶子节点通过指针进行链接。如下图：

![](img/f84ee8042168e009f0dee755840195fd.png)

B+树索引在数据库中的一个特点就是高扇出性，例如在 InnoDB 存储引擎中，每个页的大小为 16KB。在数据库中，B+树的高度一般都在 2～4 层，这意味着查找某一键值最多只需要 2 到 4 次 IO 操作，这还不错。因为现在一般的磁盘每秒至少可以做 100 次 IO 操作，2～4 次的 IO 操作意味着查询时间只需 0.02～0.04 秒。

#### 4.2.14 联合索引的存储结构是什么，它的有效方式是什么？

**参考答案**

从本质上来说，联合索引还是一棵 B+树，不同的是联合索引的键值数量不是 1，而是大于等于 2，参考下图。另外，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，所以使用联合索引时遵循最左前缀集合。

![](img/4e8a51e3aec62d9a72efb0b52c73327a.png)

#### 4.2.15 MySQL 的 Hash 索引和 B 树索引有什么区别？

**参考答案**

hash 索引底层就是 hash 表，进行查找时，调用一次 hash 函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树，对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。它们有以下的不同：

*   hash 索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。因为在 hash 索引中经过 hash 函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而 B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
*   hash 索引不支持使用索引进行排序，原理同上。
*   hash 索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为 hash 函数的不可预测。
*   hash 索引任何时候都避免不了回表查询数据，而 B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
*   hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 hash 碰撞，此时效率可能极差。而 B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。

因此，在大多数情况下，直接选择 B+树索引可以获得稳定且较好的查询速度。而不需要使用 hash 索引。

#### 4.2.16 聚簇索引和非聚簇索引有什么区别？

**参考答案**

在 InnoDB 存储引擎中，可以将 B+树索引分为聚簇索引和辅助索引（非聚簇索引）。无论是何种索引，每个页的大小都为 16KB，且不能更改。

聚簇索引是根据主键创建的一棵 B+树，聚簇索引的叶子节点存放了表中的所有记录。辅助索引是根据索引键创建的一棵 B+树，与聚簇索引不同的是，其叶子节点仅存放索引键值，以及该索引键值指向的主键。也就是说，如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚簇索引来得到数据，这种查找方式又被称为书签查找。因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于聚簇索引。

#### 4.2.17 什么是联合索引？

**参考答案**

联合索引是指对表上的多个列进行索引，联合索引的创建方法与单个索引创建的方法一样，不同之处仅在于有多个索引列。从本质上来说，联合索引还是一棵 B+树，不同的是联合索引的键值数量不是 1，而是大于等于 2，参考下图。另外，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，所以使用联合索引时遵循最左前缀集合。

![](img/4e8a51e3aec62d9a72efb0b52c73327a.png)

#### 4.2.18 select in 语句中如何使用索引？

**参考答案**

索引是否起作用，主要取决于字段类型：

*   如果字段类型为字符串，需要给 in 查询中的数值与字符串值都需要添加引号，索引才能起作用。
*   如果字段类型为 int，则 in 查询中的值不需要添加引号，索引也会起作用。

IN 的字段，在联合索引中，按以上方法，也会起作用。

#### 4.2.19 模糊查询语句中如何使用索引？

**参考答案**

在 MySQL 中模糊查询 `mobile like ‘%8765’`，这种情况是不能使用 mobile 上的索引的，那么如果需要根据手机号码后四位进行模糊查询，可以用一下方法进行改造。

我们可以加入冗余列（MySQL5.7 之后加入了虚拟列，使用虚拟列更合适，思路相同），比如 mobile_reverse，内部存储为 mobile 的倒叙文本，如 mobile 为 17312345678，那么 mobile_reverse 存储 87654321371，为 mobile_reverse 列建立索引，查询中使用语句 mobile_reverse like reverse(’%5678’) 即可。

reverse 是 MySQL 中的反转函数，这条语句相当于 mobile_reverse like ‘8765%’ ，这种语句是可以使用索引的。

### 4.3 事务

#### 4.3.1 说一说你对数据库事务的了解

**参考答案**

事务可由一条非常简单的 SQL 语句组成，也可以由一组复杂的 SQL 语句组成。在事务中的操作，要么都执行修改，要么都不执行，这就是事务的目的，也是事务模型区别于文件系统的重要特征之一。

事务需遵循 ACID 四个特性：

*   A（atomicity），原子性。原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，整个事务的执行才算成功。事务中任何一个 SQL 语句执行失败，那么已经执行成功的 SQL 语句也必须撤销，数据库状态应该退回到执行事务前的状态。
*   C（consistency），一致性。一致性指事务将数据库从一种状态转变为另一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
*   I（isolation），隔离性。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，这通常使用锁来实现。
*   D（durability） ，持久性。事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复。持久性保证的是事务系统的高可靠性，而不是高可用性。

事务可以分为以下几种类型：

*   扁平事务：是事务类型中最简单的一种，而在实际生产环境中，这可能是使用最为频繁的事务。在扁平事务中，所有操作都处于同一层次，其由 BEGIN WORK 开始，由 COMMIT WORK 或 ROLLBACK WORK 结束。处于之间的操作是原子的，要么都执行，要么都回滚。
*   带有保存点的扁平事务：除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（savepoint）用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。
*   链事务：可视为保存点模式的一个变种。链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的。
*   嵌套事务：是一个层次结构框架。有一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换。
*   分布式事务：通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。对于分布式事务，同样需要满足 ACID 特性，要么都发生，要么都失效。

对于 MySQL 的 InnoDB 存储引擎来说，它支持扁平事务、带有保存点的扁平事务、链事务、分布式事务。对于嵌套事务，MySQL 数据库并不是原生的，因此对于有并行事务需求的用户来说 MySQL 就无能为力了，但是用户可以通过带有保存点的事务来模拟串行的嵌套事务。

#### 4.3.2 事务有哪几种类型，它们之间有什么区别？

**参考答案**

事务可以分为以下几种类型：

*   扁平事务：是事务类型中最简单的一种，而在实际生产环境中，这可能是使用最为频繁的事务。在扁平事务中，所有操作都处于同一层次，其由 BEGIN WORK 开始，由 COMMIT WORK 或 ROLLBACK WORK 结束。处于之间的操作是原子的，要么都执行，要么都回滚。
*   带有保存点的扁平事务：除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（savepoint）用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。
*   链事务：可视为保存点模式的一个变种。链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的。
*   嵌套事务：是一个层次结构框架。有一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换。
*   分布式事务：通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。对于分布式事务，同样需要满足 ACID 特性，要么都发生，要么都失效。

对于 MySQL 的 InnoDB 存储引擎来说，它支持扁平事务、带有保存点的扁平事务、链事务、分布式事务。对于嵌套事务，MySQL 数据库并不是原生的，因此对于有并行事务需求的用户来说 MySQL 就无能为力了，但是用户可以通过带有保存点的事务来模拟串行的嵌套事务。