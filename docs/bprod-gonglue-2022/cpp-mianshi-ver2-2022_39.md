# 第四章 第 4 节 C++数据库-4

> 原文：[`www.nowcoder.com/tutorial/10069/3fbb74d60c2f4387b8f0ec09129fc9b2`](https://www.nowcoder.com/tutorial/10069/3fbb74d60c2f4387b8f0ec09129fc9b2)

### 4.5 优化

#### 4.5.1 说一说你对数据库优化的理解

**参考答案**

MySQL 数据库优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统的反应速度。例如，通过优化文件系统，提高磁盘 I\O 的读写速度；通过优化操作系统调度策略，提高 MySQL 在高负荷情况下的负载能力；优化表结构、索引、查询语句等使查询响应更快。

针对查询，我们可以通过使用索引、使用连接代替子查询的方式来提高查询速度。

针对慢查询，我们可以通过分析慢查询日志，来发现引起慢查询的原因，从而有针对性的进行优化。

针对插入，我们可以通过禁用索引、禁用检查等方式来提高插入速度，在插入之后再启用索引和检查。

针对数据库结构，我们可以通过将字段很多的表拆分成多张表、增加中间表、增加冗余字段等方式进行优化。

#### 4.5.2 该如何优化 MySQL 的查询？

**参考答案**

使用索引：

如果查询时没有使用索引，查询语句将扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。如果使用索引进行查询，查询语句可以根据索引快速定位到待查询记录，从而减少查询的记录数，达到提高查询速度的目的。

索引可以提高查询的速度，但并不是使用带有索引的字段查询时索引都会起作用。有几种特殊情况，在这些情况下有可能使用带有索引的字段查询时索引并没有起作用。

1.  使用 LIKE 关键字的查询语句

    在使用 LIKE 关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置，索引才会起作用。

2.  使用多列索引的查询语句

    MySQL 可以为多个字段创建索引。一个索引可以包括 16 个字段。对于多列索引，只有查询条件中使用了这些字段中的第 1 个字段时索引才会被使用。

3.  使用 OR 关键字的查询语句

    查询语句的查询条件中只有 OR 关键字，且 OR 前后的两个条件中的列都是索引时，查询中才使用索引。否则，查询将不使用索引。

优化子查询：

使用子查询可以进行 SELECT 语句的嵌套查询，即一个 SELECT 查询的结果作为另一个 SELECT 语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的 SQL 操作。

子查询虽然可以使查询语句很灵活，但执行效率不高。执行子查询时，MySQL 需要为内层查询语句的查询结果建立一个临时表。然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。因此，子查询的速度会受到一定的影响。如果查询的数据量比较大，这种影响就会随之增大。

在 MySQL 中，可以使用连接（JOIN）查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引，性能会更好。

#### 4.5.3 怎样插入数据才能更高效？

**参考答案**

影响插入速度的主要是索引、唯一性校验、一次插入记录条数等。针对这些情况，可以分别进行优化。

对于 MyISAM 引擎的表，常见的优化方法如下：

1.  禁用索引

    对于非空表，插入记录时，MySQL 会根据表的索引对插入的记录建立索引。如果插入大量数据，建立索引会降低插入记录的速度。为了解决这种情况，可以在插入记录之前禁用索引，数据插入完毕后再开启索引。对于空表批量导入数据，则不需要进行此操作，因为 MyISAM 引擎的表是在导入数据之后才建立索引的。

2.  禁用唯一性检查

    插入数据时，MySQL 会对插入的记录进行唯一性校验。这种唯一性校验也会降低插入记录的速度。为了降低这种情况对查询速度的影响，可以在插入记录之前禁用唯一性检查，等到记录插入完毕后再开启。

3.  使用批量插入

    插入多条记录时，可以使用一条 INSERT 语句插入一条记录，也可以使用一条 INSERT 语句插入多条记录。使用一条 INSERT 语句插入多条记录的情形如下，而这种方式的插入速度更快。

    ```cpp
    INSERT INTO fruits VALUES
    ('x1', '101', 'mongo2', '5.7'),
    ('x2', '101', 'mongo3', '5.7'),
    ('x3', '101', 'mongo4', '5.7');
    ```

4.  使用 LOAD DATA INFILE 批量导入

    当需要批量导入数据时，如果能用 LOAD DATA INFILE 语句，就尽量使用。因为 LOAD DATA INFILE 语句导入数据的速度比 INSERT 语句快。

对于 InnoDB 引擎的表，常见的优化方法如下：

1.  禁用唯一性检查

    插入数据之前执行`set unique_checks=0`来禁止对唯一索引的检查，数据导入完成之后再运行`set unique_checks=1`。这个和 MyISAM 引擎的使用方法一样。

2.  禁用外键检查

    插入数据之前执行禁止对外键的检查，数据插入完成之后再恢复对外键的检查。

3.  禁用自动提交

    插入数据之前禁止事务的自动提交，数据导入完成之后，执行恢复自动提交操作。

#### 4.5.4 表中包含几千万条数据该怎么办？

**参考答案**

建议按照如下顺序进行优化：

1.  优化 SQL 和索引；
2.  增加缓存，如 memcached、redis；
3.  读写分离，可以采用主从复制，也可以采用主主复制；
4.  使用 MySQL 自带的分区表，这对应用是透明的，无需改代码，但 SQL 语句是要针对分区表做优化的；
5.  做垂直拆分，即根据模块的耦合度，将一个大的系统分为多个小的系统；
6.  做水平拆分，要选择一个合理的 sharding key，为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql 中尽量带 sharding key，将数据定位到限定的表上去查，而不是扫描全部的表。

#### 4.5.5 MySQL 的慢查询优化有了解吗？

**参考答案**

优化 MySQL 的慢查询，可以按照如下步骤进行：

开启慢查询日志：

MySQL 中慢查询日志默认是关闭的，可以通过配置文件 my.ini 或者 my.cnf 中的 log-slow-queries 选项打开，也可以在 MySQL 服务启动的时候使用`--log-slow-queries[=file_name]`启动慢查询日志。

启动慢查询日志时，需要在 my.ini 或者 my.cnf 文件中配置 long_query_time 选项指定记录阈值，如果某条查询语句的查询时间超过了这个值，这个查询过程将被记录到慢查询日志文件中。

分析慢查询日志：

直接分析 mysql 慢查询日志，利用 explain 关键字可以模拟优化器执行 SQL 查询语句，来分析 sql 慢查询语句。

常见慢查询优化：

1.  索引没起作用的情况

    *   在使用 LIKE 关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置，索引才会起作用。
    *   MySQL 可以为多个字段创建索引。一个索引可以包括 16 个字段。对于多列索引，只有查询条件中使用了这些字段中的第 1 个字段时索引才会被使用。
    *   查询语句的查询条件中只有 OR 关键字，且 OR 前后的两个条件中的列都是索引时，查询中才使用索引。否则，查询将不使用索引。
2.  优化数据库结构

    *   对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。
    *   对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。
3.  分解关联查询

    很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效。

4.  优化 LIMIT 分页

    当偏移量非常大的时候，例如可能是 limit 10000,20 这样的查询，这是 mysql 需要查询 10020 条然后只返回最后 20 条，前面的 10000 条记录都将被舍弃，这样的代价很高。优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。

#### 4.5.6 说一说你对 explain 的了解

**参考答案**

MySQL 中提供了 EXPLAIN 语句和 DESCRIBE 语句，用来分析查询语句，EXPLAIN 语句的基本语法如下：

```cpp
EXPLAIN [EXTENDED] SELECT select_options
```

使用 EXTENED 关键字，EXPLAIN 语句将产生附加信息。执行该语句，可以分析 EXPLAIN 后面 SELECT 语句的执行情况，并且能够分析出所查询表的一些特征。下面对查询结果进行解释：

*   id：SELECT 识别符。这是 SELECT 的查询序列号。
*   select_type：表示 SELECT 语句的类型。
*   table：表示查询的表。
*   type：表示表的连接类型。
*   possible_keys：给出了 MySQL 在搜索数据记录时可选用的各个索引。
*   key：是 MySQL 实际选用的索引。
*   key_len：给出索引按字节计算的长度，key_len 数值越小，表示越快。
*   ref：给出了关联关系中另一个数据表里的数据列名。
*   rows：是 MySQL 在执行这个查询时预计会从这个数据表里读出的数据行的个数。
*   Extra：提供了与关联操作有关的信息。

**扩展阅读**

DESCRIBE 语句的使用方法与 EXPLAIN 语句是一样的，分析结果也是一样的，并且可以缩写成 DESC。。DESCRIBE 语句的语法形式如下：

```cpp
DESCRIBE SELECT select_options
```

#### 4.5.7 explain 关注什么？

**参考答案**

重点要关注如下几列：

| 列名 | 备注 |
| --- | --- |
| type | 本次查询表联接类型，从这里可以看到本次查询大概的效率。 |
| key | 最终选择的索引，如果没有索引的话，本次查询效率通常很差。 |
| key_len | 本次查询用于结果过滤的索引实际长度。 |
| rows | 预计需要扫描的记录数，预计需要扫描的记录数越小越好。 |
| Extra | 额外附加信息，主要确认是否出现 Using filesort、Using temporary 这两种情况。 |

其中，type 包含以下几种结果，从上之下依次是最差到最好：

| 类型 | 备注 |
| --- | --- |
| ALL | 执行 full table scan，这是最差的一种方式。 |
| index | 执行 full index scan，并且可以通过索引完成结果扫描并且直接从索引中取的想要的结果数据，也就是可以避免回表，比 ALL 略好，因为索引文件通常比全部数据要来的小。 |
| range | 利用索引进行范围查询，比 index 略好。 |
| index_subquery | 子查询中可以用到索引。 |
| unique_subquery | 子查询中可以用到唯一索引，效率比 index_subquery 更高些。 |
| index_merge | 可以利用 index merge 特性用到多个索引，提高查询效率。 |
| ref_or_null | 表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值。 |
| fulltext | 全文检索。 |
| ref | 基于索引的等值查询，或者表间等值连接。 |
| eq_ref | 表连接时基于主键或非 NULL 的唯一索引完成扫描，比 ref 略好。 |
| const | 基于主键或唯一索引唯一值查询，最多返回一条结果，比 eq_ref 略好。 |
| system | 查询对象表只有一行数据，这是最好的情况。 |

另外，Extra 列需要注意以下的几种情况：

| 关键字 | 备注 |
| --- | --- |
| Using filesort | 将用外部排序而不是按照索引顺序排列结果，数据较少时从内存排序，否则需要在磁盘完成排序，代价非常高，需要添加合适的索引。 |
| Using temporary | 需要创建一个临时表来存储结果，这通常发生在对没有索引的列进行 GROUP BY 时，或者 ORDER BY 里的列不都在索引里，需要添加合适的索引。 |
| Using index | 表示 MySQL 使用覆盖索引避免全表扫描，不需要再到表中进行二次查找数据，这是比较好的结果之一。注意不要和 type 中的 index 类型混淆。 |
| Using where | 通常是进行了全表/全索引扫描后再用 WHERE 子句完成结果过滤，需要添加合适的索引。 |
| Impossible WHERE | 对 Where 子句判断的结果总是 false 而不能选择任何数据，例如 where 1=0，无需过多关注。 |
| Select tables optimized away | 使用某些聚合函数来访问存在索引的某个字段时，优化器会通过索引直接一次定位到所需要的数据行完成整个查询，例如 MIN()\MAX()，这种也是比较好的结果之一。 |

### 4.6 其他

#### 4.6.1 介绍一下数据库设计的三大范式

**参考答案**

目前关系数据库有六种范式，一般来说，数据库只需满足第三范式(3NF）就行了。

第一范式（1NF）：

是指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。

即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。

第二范式（2NF）：

在 1NF 的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖）。

第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。

例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复，无法区分出实体时，设计辟如 ID 等不重复的编号以实现区分，被添加的编号或 ID 选作主键。

第三范式（3NF）：

在 2NF 基础上，任何非主属性不依赖于其它非主属性（在 2NF 基础上消除传递依赖）。

第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。

例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。

#### 4.6.2 说一说你对 MySQL 引擎的了解

**参考答案**

MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。MySQL 8.0 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。其中，最常用的引擎是 InnoDB 和 MyISAM。

InnoDB 存储引擎：

InnoDB 是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎，主要特性如下：

1.  InnoDB 给 MySQL 提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID 兼容）存储引擎。InnoDB 锁定在行级并且也在 SELECT 语句中提供一个类似 Oracle 的非锁定读。这些功能增加了多用户部署和性能。在 SQL 查询中，可以自由地将 InnoDB 类型的表与其他 MySQL 表的类型混合起来，甚至在同一个查询中也可以混合。
2.  InnoDB 是为处理巨大数据量的最大性能设计。它的 CPU 效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。
3.  InnoDB 存储引擎完全与 MySQL 服务器整合，为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB 将它的表和索引存在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与 MyISAM 表不同，比如在 MyISAM 表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为 2GB 的操作系统上。
4.  InnoDB 支持外键完整性约束（FOREIGN KEY）。存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB 会为每一行生成一个 6B 的 ROWID，并以此作为主键。
5.  InnoDB 被用在众多需要高性能的大型数据库站点上。InnoDB 不创建目录，使用 InnoDB 时，MySQL 将在数据目录下创建一个名为 ibdata1 的 10MB 大小的自动扩展数据文件，以及两个名为 ib_logfile0 和 ib_logfile1 的 5MB 大小的日志文件。

MyISAM 存储引擎：

MyISAM 基于 ISAM 存储引擎，并对其进行扩展。它是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。MyISAM 的主要特性如下：

1.  在支持大文件（达 63 位文件长度）的文件系统和操作系统上被支持。
2.  当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块以及若下一个块被删除则扩展到下一块来自动完成。
3.  每个 MyISAM 表最大的索引数是 64，这可以通过重新编译来改变。每个索引最大的列数是 16 个。
4.  最大的键长度是 1000B，这也可以通过编译来改变。对于键长度超过 250B 的情况，一个超过 1024B 的键将被用上。
5.  BLOB 和 TEXT 列可以被索引。
6.  NULL 值被允许在索引的列中，这个值占每个键的 0~1 个字节。
7.  所有数字键值以高字节优先被存储，以允许一个更高的索引压缩。
8.  每个表一个 AUTO_INCREMENT 列的内部处理。MyISAM 为 INSERT 和 UPDATE 操作自动更新这一列，这使得 AUTO_INCREMENT 列更快（至少 10%）。在序列顶的值被删除之后就不能再利用。
9.  可以把数据文件和索引文件放在不同目录。
10.  每个字符列可以有不同的字符集。
11.  有 VARCHAR 的表可以固定或动态记录长度。
12.  VARCHAR 和 CHAR 列可以多达 64KB。

#### 4.6.3 说一说你对 redo log、undo log、binlog 的了解

**参考答案**

binlog（Binary Log）：

二进制日志文件就是常说的 binlog。二进制日志记录了 MySQL 所有修改数据库的操作，然后以二进制的形式记录在日志文件中，其中还包括每条语句所执行的时间和所消耗的资源，以及相关的事务信息。

默认情况下，二进制日志功能是开启的，启动时可以重新配置`--log-bin[=file_name]`选项，修改二进制日志存放的目录和文件名称。

redo log：

重做日志用来实现事务的持久性，即事务 ACID 中的 D。它由两部分组成：一是内存中的重做日志缓冲（redo log buffer），其是易失的；二是重做日志文件（redo log file），它是持久的。

InnoDB 是事务的存储引擎，它通过 Force Log at Commit 机制实现事务的持久性，即当事务提交（COMMIT）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的 COMMIT 操作完成才算完成。这里的日志是指重做日志，在 InnoDB 存储引擎中，由两部分组成，即 redo log 和 undo log。

redo log 用来保证事务的持久性，undo log 用来帮助事务回滚及 MVCC 的功能。redo log 基本上都是顺序写的，在数据库运行时不需要对 redo log 的文件进行读取操作。而 undo log 是需要进行随机读写的。

undo log：

重做日志记录了事务的行为，可以很好地通过其对页进行“重做”操作。但是事务有时还需要进行回滚操作，这时就需要 undo。因此在对数据库进行修改时，InnoDB 存储引擎不但会产生 redo，还会产生一定量的 undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条 ROLLBACK 语句请求回滚，就可以利用这些 undo 信息将数据回滚到修改之前的样子。

redo 存放在重做日志文件中，与 redo 不同，undo 存放在数据库内部的一个特殊段（segment）中，这个段称为 undo 段（undo segment），undo 段位于共享表空间内。

#### 4.6.4 谈谈你对 MVCC 的了解

**参考答案**

InnoDB 默认的隔离级别是 RR（REPEATABLE READ），RR 解决脏读、不可重复读、幻读等问题，使用的是 MVCC。MVCC 全称 Multi-Version Concurrency Control，即多版本的并发控制协议。它最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB 实现 MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：

1.  隐藏列：InnoDB 中每行数据都有隐藏列，隐藏列中包含了本行数据的事务 id、指向 undo log 的指针等。
2.  基于 undo log 的版本链：每行数据的隐藏列中包含了指向 undo log 的指针，而每条 undo log 也会指向更早版本的 undo log，从而形成一条版本链。
3.  ReadView：通过隐藏列和版本链，MySQL 可以将数据恢复到指定版本。但是具体要恢复到哪个版本，则需要根据 ReadView 来确定。所谓 ReadView，是指事务（记做事务 A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务 id 与 trx_sys 快照比较，从而判断数据对该 ReadView 是否可见，即对事务 A 是否可见。

#### 4.6.5 MySQL 主从同步是如何实现的？

**参考答案**

复制（replication）是 MySQL 数据库提供的一种高可用高性能的解决方案，一般用来建立大型的应用。总体来说，replication 的工作原理分为以下 3 个步骤：

1.  主服务器（master）把数据更改记录到二进制日志（binlog）中。
2.  从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。
3.  从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。

复制的工作原理并不复杂，其实就是一个完全备份加上二进制日志备份的还原。不同的是这个二进制日志的还原操作基本上实时在进行中。这里特别需要注意的是，复制不是完全实时地进行同步，而是异步实时。这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大。复制的工作原理如下图所示，其中从服务器有 2 个线程，一个是 I/O 线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是 SQL 线程，复制执行中继日志。

![](img/4d979f762fcad30de1d558c0088bf46e.png)