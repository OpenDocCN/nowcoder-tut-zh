# 第四章 第 3 节 Java-中间件-3

> 原文：[`www.nowcoder.com/tutorial/10070/08f2435ea7dc49a28086f54961b6799b`](https://www.nowcoder.com/tutorial/10070/08f2435ea7dc49a28086f54961b6799b)

#### 1.19 请介绍 Redis 集群的实现方案

**参考答案**

Redis 集群的分区方案：

Redis 集群采用虚拟槽分区来实现数据分片，它把所有的键根据哈希函数映射到`0-16383`整数槽内，计算公式为`slot=CRC16(key)&16383`，每一个节点负责维护一部分槽以及槽所映射的键值数据。虚拟槽分区具有如下特点：

1.  解耦数据和节点之间的关系，简化了节点扩容和收缩的难度；

2.  节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据；

3.  支持节点、槽、键之间的映射查询，用于数据路由，在线伸缩等场景。

Redis 集群中数据的分片逻辑如下图：

![](img/42734c799b3f145602f072347ec2e73a.png)

Redis 集群的功能限制：

Redis 集群方案在扩展了 Redis 处理能力的同时，也带来了一些使用上的限制：

1.  key 批量操作支持有限。如 mset、mget，目前只支持具有相同 slot 值的 key 执行批量操作。对于映射为不同 slot 值的 key 由于执行 mset、mget 等操作可能存在于多个节点上所以不被支持。

2.  key 事务操作支持有限。同理只支持多 key 在同一节点上的事务操作，当多个 key 分布在不同的节点上时无法使用事务功能。

3.  key 作为数据分区的最小粒度，因此不能将一个大的键值对象（如 hash、list 等）映射到不同的节点。

4.  不支持多数据库空间。单机下的 Redis 可以支持 16 个数据库，集群模式下只能使用一个数据库空间，即 DB0。

5.  复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。

Redis 集群的通信方案：

在分布式存储中需要提供维护节点元数据信息的机制，所谓元数据是指：节点负责哪些数据，是否出现故障等状态信息。常见的元数据维护方式分为：集中式和 P2P 方式。

Redis 集群采用 P2P 的 Gossip（流言）协议，Gossip 协议的工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播。通信的大致过程如下：

1.  集群中每个节点都会单独开辟一个 TCP 通道，用于节点之间彼此通信，通信端口号在基础端口号上加 10000；

2.  每个节点再固定周期内通过特定规则选择几个节点发送 ping 消息；

3.  接收 ping 消息的节点用 pong 消息作为响应。

其中，Gossip 协议的主要职责就是信息交换，而信息交换的载体就是节点彼此发送的 Gossip 消息，Gossip 消息分为：meet 消息、ping 消息、pong 消息、fail 消息等。

*   meet 消息：用于通知新节点加入，消息发送者通知接受者加入到当前集群。meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong 消息交换。

*   ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。ping 消息封装了自身节点和一部分其他节点的状态数据。

*   pong 消息：当接收到 meet、ping 消息时，作为响应消息回复给发送方确认消息正常通信。pong 消息内封装了自身状态数据，节点也可以向集群内广播自身的 pong 消息来通知整个集群对自身状态进行更新。

*   fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到 fail 消息之后把对应节点更新为下线状态。

虽然 Gossip 协议的信息交换机制具有天然的分布式特性，但它是有成本的。因为 Redis 集群内部需要频繁地进行节点信息交换，而 ping/pong 消息会携带当前节点和部分其他节点的状态数据，势必会加重带宽和计算的负担。所以，Redis 集群的 Gossip 协议需要兼顾信息交换的实时性和成本的开销。

*   集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这五个节点中最长时间没有发送过 PING 消息的节点发送 PING 消息，以此来检测被选中的节点是否在线。

*   如果节点 A 最后一次收到节点 B 发送的 PONG 消息的时间，距离当前时间已经超过了节点 A 的超时选项设置时长的一半（cluster-node-timeout/2），那么节点 A 也会向节点 B 发送 PING 消息，这可以防止节点 A 因为长时间没有随机选中节点 B 作为 PING 消息的发送对象而导致对节点 B 的信息更新滞后。

*   每个消息主要的数据占用：slots 槽数组（2KB）和整个集群 1/10 的状态数据（10 个节点状态数据约 1KB）。

#### 1.20 说一说 Redis 集群的分片机制

**参考答案**

Redis 集群采用虚拟槽分区来实现数据分片，它把所有的键根据哈希函数映射到`0-16383`整数槽内，计算公式为`slot=CRC16(key)&16383`，每一个节点负责维护一部分槽以及槽所映射的键值数据。虚拟槽分区具有如下特点：

1.  解耦数据和节点之间的关系，简化了节点扩容和收缩的难度；

2.  节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据；

3.  支持节点、槽、键之间的映射查询，用于数据路由，在线伸缩等场景。

Redis 集群中数据的分片逻辑如下图：

![](img/42734c799b3f145602f072347ec2e73a.png)

#### 1.21 说一说 Redis 集群的应用和优劣势

**参考答案**

优势：

Redis Cluster 是 Redis 的分布式解决方案，在 3.0 版本正式推出，有效地解决了 Redis 分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用 Cluster 架构方案达到负载均衡的目的。

劣势：

Redis 集群方案在扩展了 Redis 处理能力的同时，也带来了一些使用上的限制：

1.  key 批量操作支持有限。如 mset、mget，目前只支持具有相同 slot 值的 key 执行批量操作。对于映射为不同 slot 值的 key 由于执行 mset、mget 等操作可能存在于多个节点上所以不被支持。

2.  key 事务操作支持有限。同理只支持多 key 在同一节点上的事务操作，当多个 key 分布在不同的节点上时无法使用事务功能。

3.  key 作为数据分区的最小粒度，因此不能将一个大的键值对象（如 hash、list 等）映射到不同的节点。

4.  不支持多数据库空间。单机下的 Redis 可以支持 16 个数据库，集群模式下只能使用一个数据库空间，即 DB0。

5.  复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。

#### 1.22 说一说 hash 类型底层的数据结构

**参考答案**

哈希对象有两种编码方案，当同时满足以下条件时，哈希对象采用 ziplist 编码，否则采用 hashtable 编码：

*   哈希对象保存的键值对数量小于 512 个；
*   哈希对象保存的所有键值对中的键和值，其字符串长度都小于 64 字节。

其中，ziplist 编码采用压缩列表作为底层实现，而 hashtable 编码采用字典作为底层实现。

压缩列表：

压缩列表（ziplist），是 Redis 为了节约内存而设计的一种线性数据结构，它是由一系列具有特殊编码的连续内存块构成的。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。

压缩列表的结构如下图所示：

![](img/c51ef49dc897973f634454ce0203df38.png)

该结构当中的字段含义如下表所示：

| **属性** | **类型** | **长度** | **说明** |
| --- | --- | --- | --- |
| zlbytes | uint32_t | 4 字节 | 压缩列表占用的内存字节数； |
| zltail | uint32_t | 4 字节 | 压缩列表表尾节点距离列表起始地址的偏移量（单位字节）； |
| zllen | uint16_t | 2 字节 | 压缩列表包含的节点数量，等于 UINT16_MAX 时，需遍历列表计算真实数量； |
| entryX | 列表节点 | 不固定 | 压缩列表包含的节点，节点的长度由节点所保存的内容决定； |
| zlend | uint8_t | 1 字节 | 压缩列表的结尾标识，是一个固定值 0xFF； |

其中，压缩列表的节点由以下字段构成：

![](img/cb781d7f6ffdc2abaf22ae8df3cd8a13.png)

previous_entry_length（pel）属性以字节为单位，记录当前节点的前一节点的长度，其自身占据 1 字节或 5 字节：

1.  如果前一节点的长度小于 254 字节，则“pel”属性的长度为 1 字节，前一节点的长度就保存在这一个字节内；

2.  如果前一节点的长度达到 254 字节，则“pel”属性的长度为 5 字节，其中第一个字节被设置为 0xFE，之后的四个字节用来保存前一节点的长度；

基于“pel”属性，程序便可以通过指针运算，根据当前节点的起始地址计算出前一节点的起始地址，从而实现从表尾向表头的遍历操作。

content 属性负责保存节点的值（字节数组或整数），其类型和长度则由 encoding 属性决定，它们的关系如下：

| **encoding** | **长度** | **content** |
| --- | --- | --- |
| 00 xxxxxx | 1 字节 | 最大长度为 26 -1 的字节数组； |
| 01 xxxxxx bbbbbbbb | 2 字节 | 最大长度为 214-1 的字节数组； |
| 10 **__** bbbbbbbb ... ... ... | 5 字节 | 最大长度为 232-1 的字节数组； |
| 11 000000 | 1 字节 | int16_t 类型的整数； |
| 11 010000 | 1 字节 | int32_t 类型的整数； |
| 11 100000 | 1 字节 | int64_t 类型的整数； |
| 11 110000 | 1 字节 | 24 位有符号整数； |
| 11 111110 | 1 字节 | 8 位有符号整数； |
| 11 11xxxx | 1 字节 | 没有 content 属性，xxxx 直接存[0,12]范围的整数值； |

字典：

字典（dict）又称为散列表，是一种用来存储键值对的数据结构。C 语言没有内置这种数据结构，所以 Redis 构建了自己的字典实现。

Redis 字典的实现主要涉及三个结构体：字典、哈希表、哈希表节点。其中，每个哈希表节点保存一个键值对，每个哈希表由多个哈希表节点构成，而字典则是对哈希表的进一步封装。这三个结构体的关系如下图所示：

![](img/2632e59ae418deee3e908dab8dc9c662.png)

其中，dict 代表字典，dictht 代表哈希表，dictEntry 代表哈希表节点。可以看出，dictEntry 是一个数组，这很好理解，因为一个哈希表里要包含多个哈希表节点。而 dict 里包含 2 个 dictht，多出的哈希表用于 REHASH。当哈希表保存的键值对数量过多或过少时，需要对哈希表的大小进行扩展或收缩操作，在 Redis 中，扩展和收缩哈希表是通过 REHASH 实现的，执行 REHASH 的大致步骤如下：

1.  为字典的 ht[1]哈希表分配内存空间

    如果执行的是扩展操作，则 ht[1]的大小为第 1 个大于等于 ht[0].used*2 的 2n。如果执行的是收缩操作，则 ht[1]的大小为第 1 个大于等于 ht[0].used 的 2n。

2.  将存储在 ht[0]中的数据迁移到 ht[1]上

    重新计算键的哈希值和索引值，然后将键值对放置到 ht[1]哈希表的指定位置上。

3.  将字典的 ht[1]哈希表晋升为默认哈希表

    迁移完成后，清空 ht[0]，再交换 ht[0]和 ht[1]的值，为下一次 REHASH 做准备。

当满足以下任何一个条件时，程序会自动开始对哈希表执行扩展操作：

1.  服务器目前没有执行 bgsave 或 bgrewriteof 命令，并且哈希表的负载因子大于等于 1；

2.  服务器目前正在执行 bgsave 或 bgrewriteof 命令，并且哈希表的负载因子大于等于 5。

为了避免 REHASH 对服务器性能造成影响，REHASH 操作不是一次性地完成的，而是分多次、渐进式地完成的。渐进式 REHASH 的详细过程如下：

1.  为 ht[1]分配空间，让字典同时持有 ht[0]和 ht[1]两个哈希表；

2.  在字典中的索引计数器 rehashidx 设置为 0，表示 REHASH 操作正式开始；

3.  在 REHASH 期间，每次对字典执行添加、删除、修改、查找操作时，程序除了执行指定的操作外，还会顺带将 ht[0]中位于 rehashidx 上的所有键值对迁移到 ht[1]中，再将 rehashidx 的值加 1；

4.  随着字典不断被访问，最终在某个时刻，ht[0]上的所有键值对都被迁移到 ht[1]上，此时程序将 rehashidx 属性值设置为-1，标识 REHASH 操作完成。

REHSH 期间，字典同时持有两个哈希表，此时的访问将按照如下原则处理：

1.  新添加的键值对，一律被保存到 ht[1]中；

2.  删除、修改、查找等其他操作，会在两个哈希表上进行，即程序先尝试去 ht[0]中访问要操作的数据，若不存在则到 ht[1]中访问，再对访问到的数据做相应的处理。