# 第四章 第 9 节 前端框架-补充

> 原文：[`www.nowcoder.com/tutorial/10072/c841de4145e741379fe7135dca44ee63`](https://www.nowcoder.com/tutorial/10072/c841de4145e741379fe7135dca44ee63)

## 4\. 概念

#### 4.1 mvc 和 mvvm 的区别

**参考答案：**

MVC: MVC 是应用最广泛的软件架构之一,一般`MVC`分为:`Model(模型)`,`View(视图)`,`Controller(控制器)`。 这主要是基于分层的目的,让彼此的职责分开.`View`一般用过`Controller`来和`Model`进行联系。`Controller`是`Model`和`View`的协调者,`View`和`Model`不直接联系。基本都是单向联系。

MVVM: `MVVM`是把`MVC`中的`Controller`改变成了`ViewModel`。`View`的变化会自动更新到`ViewModel`,`ViewModel`的变化也会自动同步到`View 上`显示,通过数据来显示视图层。

MVVM 和 MVC 的区别:

*   MVC 中 Controller 演变成 MVVM 中的 ViewModel
*   MVVM 通过数据来显示视图层而不是节点操作
*   MVVM 主要解决了 MVC 中大量的 dom 操作使页面渲染性能降低,加载速度变慢,影响用户体验

#### 4.2 单页应用优缺点

**参考答案：**

优点

1.  良好的交互体验

    单页应用的内容的改变不需要重新加载整个页面，获取数据也是通过 Ajax 异步获取，没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象，页面显示流畅，web 应用更具响应性和更令人着迷。

2.  良好的前后端工作分离模式

    后端不再负责模板渲染、输出页面工作，后端 API 通用化，即同一套后端程序代码，不用修改就可以用于 Web 界面、手机、平板等多种客户端。

3.  减轻服务器压力

　　单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍。

缺点

1.  首屏加载慢

    *   如果不对路由进行处理，在加载首页的时候，就会将所有组件全部加载，并向服务器请求数据，这必将拖慢加载速度；
    *   通过查看 Network，发现整个网站加载试讲长达 10 几秒，加载时间最长的就是 js、css 文件和媒体文件及图片

    解决方案：

    *   Vue-router 懒加载

        Vue-router 懒加载就是按需加载组件，只有当路由被访问时才会加载对应的组件，而不是在加载首页的时候就加载，项目越大，对首屏加载的速度提升得越明显。

    *   使用 CDN 加速

    　　在做项目时，我们会用到很多库，采用 cdn 加载可以加快加载速度。

    *   异步加载组件

    *   服务端渲染

        服务端渲染还能对 seo 优化起到作用，有利于搜索引擎抓取更多有用的信息（如果页面纯前端渲染，搜索引擎抓取到的就只是空页面）

2.  不利于 SEO

    seo 本质是一个服务器向另一个服务器发起请求，解析请求内容。但一般来说搜索引擎是不会去执行请求到的 js 的。也就是说，搜索引擎的基础爬虫的原理就是抓取 url，然后获取 html 源代码并解析。 如果一个单页应用，html 在服务器端还没有渲染部分数据，在浏览器才渲染出数据，即搜索引擎请求到的 html 是模型页面而不是最终数据的渲染页面。 这样就很不利于内容被搜索引擎搜索到。

    解决方案：

*   服务端渲染:服务器合成完整的 html 文件再输出到浏览器

*   页面预渲染

*   路由采用 h5 history 模式

3.  不适合开发大型项目

　　大型项目中可能会涉及大量的 DOM 操作、复杂的动画效果，也就不适合使用 Vue、react 框架进行开发。

#### 4.3 虚拟 DOM 和 Diff 算法

**参考答案：**

虚拟 dom 是什么？

Virtual dom, 即虚拟 DOM 节点。它通过`JS`的 Object 对象模拟 DOM 中的节点，然后再通过特定的 render 方法将其渲染成真实的 DOM 节点。比操作真实 dom 减少性能开销

diff 算法又是什么？

传统的 Diff 算法也是一直都有的;`diff`算法，会对比新老虚拟`DOM`，记录下他们之间的变化，然后将变化的部分更新到视图上。其实之前的`diff`算法，是通过循环递归每个节点，然后进行对比，复杂程度为`O(n³)`，`n`是树中节点的总数，这样性能是非常差的。

dom-diff 的原理？

`dom-diff`算法会比较前后虚拟`DOM`，从而得到`patches`(补丁)，然后与老`Virtual DOM`进行对比，将其应用在需要更新的地方，将 O(n³) 复杂度的问题转换成 O(n¹=n) 复杂度的问题，得到新的`Virtual DOM`。降低时间复杂度的方法：

1.  两个不同类型的元素会产生不同的树
2.  对于同一层级的一组子节点，它们可以通过唯一 key 进行区分

#### 4.4 框架带来的好处和弊端

**参考答案：**

优势：

1.  组件化：其中以 react 的组件化最为彻底，甚至可以到函数级别的原子组件，高度的组件化可以使我们的工程易于维护，易于组合扩展；

2.  天然分层：jQuery 时代的代码大部分情况下是面条代码，耦合严重，现代框架不管是 MVC、MVP 还是 MVVM 模式都可以帮我们进行分层，代码解耦更易于读写；

3.  生态：现代主流框架都自带生态，不管是数据流管理架构还是 UI 库都有成熟的解决方案；

4.  开发效率：现在前端框架都默认自动更新 DOM，而非我们手动操作，解放了开发者的手动 DOM 成本，提高开发效率，从根本上解决了 UI 与状体同步问题。

劣势：

1.  兼容性问题，SEO 不友好
2.  有场景要求，开发自由度降低
3.  有黑盒开发，框架本身有出错的风险
4.  有学习成本

​

#### 4.5 模块化、组件化、工程化

**参考答案：**

工程化：

前端工程化是一个高层次的思想，而模块化和组件化是为工程化思想下相对较具体的开发方式，因此可以简单的认为模块化和组件化是工程化的表现形式。工程化是将前端项目当成一项系统工程进行分析、组织和构建从而达到项目结构清晰、分工明确、团队配合默契、开发效率提高的目的。

模块化：

一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。

js 模块化方案很多有 AMD、CommonJS、UMD、ES6 Module 等。css 模块化开发大多数是在 less、sass、stylus 等预处理器的 import、minxin 特性支持下实现。

模块化优势：

*   避免变量污染，命名冲突
*   提高代码复用率
*   提高维护性
*   依赖关系的管理

组件化：

页面上的每个独立的、可视/可交互区域视为一个组件

每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护；由于组件具有独立性，因此组件与组件之间可以自由组合；页面不过是组件的容器，负责组合组件形成功能完整的界面；

#### 4.6 谈谈对 MVC、MVP、MVVM 模式的理解

**参考答案**：

在开发图形界面应用程序的时候，会把管理用户界面的层次称为 View，应用程序的数据为 Model，Model 提供数据操作的接口，执行相应的业务逻辑。

**MVC**

MVC 除了把应用程序分为 View、Model 层，还额外的加了一个 Controller 层，它的职责是进行 Model 和 View 之间的协作（路由、输入预处理等）的应由逻辑（application logic）；Model 进行处理业务逻辑。

用户对 View 操作以后，View 捕获到这个操作，会把处理的权利交移给 Controller（Pass calls）；Controller 会对来自 View 数据进行预处理、决定调用哪个 Model 的接口；然后由 Model 执行相关的业务逻辑；当 Model 变更了以后，会通过观察者模式（Observer Pattern）通知 View；View 通过观察者模式收到 Model 变更的消息以后，会向 Model 请求最新的数据，然后重新更新界面。

**MVP**

和 MVC 模式一样，用户对 View 的操作都会从 View 交易给 Presenter。Presenter 会执行相应的应用程序逻辑，并且会对 Model 进行相应的操作；而这时候 Model 执行业务逻辑以后，也是通过观察者模式把自己变更的消息传递出去，但是是传给 Presenter 而不是 View。Presenter 获取到 Model 变更的消息以后，通过 View 提供的接口更新界面。

**MVVM**

MVVM 可以看做是一种特殊的 MVP（Passive View）模式，或者说是对 MVP 模式的一种改良。

MVVM 代表的是 Model-View-ViewModel，可以简单把 ViewModel 理解为页面上所显示内容的数据抽象，和 Domain Model 不一样，ViewModel 更适合用来描述 View。 MVVM 的依赖关系和 MVP 依赖关系一致，只不过是把 P 换成了 VM。

MVVM 的调用关系：

MVVM 的调用关系和 MVP 一样。但是，在 ViewModel 当中会有一个叫 Binder，或者是 Data-binding engine 的东西。以前全部由 Presenter 负责的 View 和 Model 之间数据同步操作交由给 Binder 处理。你只需要在 View 的模板语法当中，指令式声明 View 上的显示的内容是和 Model 的哪一块数据绑定的。当 ViewModel 对进行 Model 更新的时候，Binder 会自动把数据更新到 View 上，当用户对 View 进行操作（例如表单输入），Binder 也会自动把数据更新到 Model 上。这种方式称为：Two-way data-binding，双向数据绑定。可以简单而不恰当地理解为一个模板引擎，但是会根据数据变更实时渲染。