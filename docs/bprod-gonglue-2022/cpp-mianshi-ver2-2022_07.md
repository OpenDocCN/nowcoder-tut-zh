# 第一章 第 6 节 C++内存-1

> 原文：[`www.nowcoder.com/tutorial/10069/eb6c07eabfc1489bb40aeae403da5b50`](https://www.nowcoder.com/tutorial/10069/eb6c07eabfc1489bb40aeae403da5b50)

### 1.2 C++内存

#### 1.2.1 简述一下堆和栈的区别

**参考回答**

区别：

1.  **堆栈空间分配不同**。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。
2.  **堆栈缓存方式不同**。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。
3.  **堆栈数据结构不同**。堆类似数组结构；栈类似栈结构，先进后出。

#### 1.2.2 简述 C++的内存管理

**参考回答**

1.  **内存分配方式**：

    在 C++中，内存分成 5 个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

    **栈**，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。

    **堆**，就是那些由 new 分配的内存块，一般一个 new 就要对应一个 delete。

    **自由存储区**，就是那些由 malloc 等分配的内存块，和堆是十分相似的，不过是用 free 来结束自己的生命。

    **全局/静态存储区**，全局变量和静态变量被分配到同一块内存中

    **常量存储区**，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。

2.  **常见的内存错误及其对策**：

    （1）内存分配未成功，却使用了它。

    （2）内存分配虽然成功，但是尚未初始化就引用它。

    （3）内存分配成功并且已经初始化，但操作越过了内存的边界。

    （4）忘记了释放内存，造成内存泄露。

    （5）释放了内存却继续使用它。

    对策：

    （1）定义指针时，先初始化为 NULL。

    （2）用 malloc 或 new 申请内存之后，应该**立即检查**指针值是否为 NULL。防止使用指针值为 NULL 的内存。

    （3）不要忘记为数组和动态内存**赋初值**。防止将未被初始化的内存作为右值使用。

    （4）避免数字或指针的下标**越界**，特别要当心发生“多 1”或者“少 1”操作

    （5）动态内存的申请与释放必须配对，防止**内存泄漏**

    （6）用 free 或 delete 释放了内存之后，立即将指针**设置为 NULL**，防止“野指针”

    （7）使用智能指针。

3.  **内存泄露及解决办法**：

    **什么是内存泄露？**

    简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new 和 malloc 申请资源使用后，没有用 delete 和 free 释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows 句柄资源使用后没有释放。

    **怎么检测？**

    第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。

    第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。

    第三：使用智能指针。

    第四：一些常见的工具插件，如 ccmalloc、Dmalloc、Leaky、Valgrind 等等。

#### 1.2.3 malloc 和局部变量分配在堆还是栈？

**参考回答**

​ malloc 是在**堆上分配内存**，需要程序员自己回收内存；局部变量是在**栈中分配内存**，超过作用域就自动回收。

#### 1.2.4 程序有哪些 section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？

**参考回答**

![image-20201219142935577](img/c469868fa168d8012dcd4645a4725926.png)

**一个程序有哪些 section：**

如上图，**从低地址到高地址，一个程序由代码段、数据段、** **BSS** **段组成。**

1.  **数据段：**存放程序中已初始化的全局变量和静态变量的一块内存区域。

2.  **代码段：**存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。

3.  **BSS** 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。

4.  可执行程序在运行时又会多出两个区域：堆区和栈区。

    **堆区：**动态申请内存用。堆从低地址向高地址增长。

    **栈区：**存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。

5.  最后还有一个**文件映射区**，位于堆和栈之间。

**程序启动的过程：**

1.  操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。
2.  加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。
3.  加载器针对该程序的每一个动态链接库调用 LoadLibrary
    （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。
    （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。
    （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到 3
    （4）调用该动态链接库的初始化函数
4.  初始化应用程序的全局变量，对于全局对象自动调用构造函数。
5.  进入应用程序入口点函数开始执行。

**怎么判断数据分配在栈上还是堆上：**首先局部变量分配在栈上；而通过 malloc 和 new 申请的空间是在堆上。