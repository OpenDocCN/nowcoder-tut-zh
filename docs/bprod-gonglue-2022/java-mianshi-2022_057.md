# 第七章 第 3 节 Java-计算机网络-3

> 原文：[`www.nowcoder.com/tutorial/10070/7b3a75b7180d48f9811f553c9393a36b`](https://www.nowcoder.com/tutorial/10070/7b3a75b7180d48f9811f553c9393a36b)

#### 1.10 介绍一下 tcp 的三次握手。

**参考回答**

![三次握手](img/b84b4dd15b54aa4b7a88eb655e227ef5.png)

1.  第一次握手：建立连接时，客户端发送 syn 包（syn=x）到服务器，并进入**SYN_SENT**状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
2.  第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=x+1），同时自己也发送一个 SYN 包（syn=y），即 SYN+ACK 包，此时服务器进入**SYN_RECV**状态；
3.  第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=y+1），此包发送完毕，客户端和服务器进入**ESTABLISHED**（TCP 连接成功）状态，完成三次握手。

#### 1.11 介绍一下 tcp 的四次挥手。

**参考回答**

![四次挥手](img/647ed89dd37db1617108ba5aef0579a4.png)

1.  客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。
2.  服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。
3.  客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4.  服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。
5.  客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。
6.  服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。

#### 1.12 为什么需要四次挥手？

**参考回答**

1.  四次挥手示意图

    ![四次挥手](img/647ed89dd37db1617108ba5aef0579a4.png)
2.  四次挥手过程

    （1）客户端向服务器发送 FIN 控制报文段（首部中的 FIN 比特被置位）；

    （2）服务端收到 FIN，回复 ACK。服务器进入关闭等待状态，发送 FIN;

    （3）客户端收到 FIN，给服务器回复 ACK，客户端进入等待状态（进入“等待”，以确保服务器收到 ACK 真正关闭连接）;

    （4）服务端收到 ACK，链接关闭。

3.  **四次挥手原因**

    ​ TCP 协议是一种**面向连接的、可靠的、基于字节流的**运输层通信协议。TCP 是**全双工模式**，这就意味着，当客户端发出 FIN 报文段时，只是表示客户端已经没有数据要发送了，客户端告诉服务器，它的数据已经全部发送完毕了；但是，这个时候客户端还是可以接受来自服务端的数据；当服务端返回 ACK 报文段时，表示它已经知道客户端没有数据发送了，但是服务端还是可以发送数据到客户端的；当服务端也发送了 FIN 报文段时，这个时候就表示服务端也没有数据要发送了，就会告诉客户端，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。

    ​ 简单地说，前 2 次挥手用于关闭一个方向的数据通道，后两次挥手用于关闭另外一个方向的数据通道。

#### 1.13 为什么要有最后一次 ACK？

**参考回答**

1.  三次握手示意图

    ![三次握手](img/b84b4dd15b54aa4b7a88eb655e227ef5.png)
2.  四次挥手过程

    （1）客户端发送一个 SYN0 给服务器（选择初始序列号，不携带任何数据）

    （2）服务器收到 SYN0，回复 SYN1 和 ACK（服务器分配缓存，选择自己初始序列号）

    （3）客户端收到 SYN1、ACK，回复 ACK（可以包含数据）

3.  **为什么要有最后一次 ACK**

    ​ 客户端首先向服务器发送一个连接请求，但是可能这个连接请求走了远路，等了很长时间，服务器都没有收到，那么客户端可能会再次发送，此时服务器端收到并且回复 SYN、ACK；在这个时候最先发送的那个连接请求到达服务器，那么服务器会回复一个 SYN，ACK；但是客户端表示自己已经收到确认了，并不搭理这个回复，那么服务器可能陷入等待，如果这种情况多了，那么会导致服务器瘫痪，所以要发送第三个确认。

**答案解析**

#### 1.14 说一说你对 tcp 抓包的理解。

**参考回答**

1.  TCP 抓包定义

    ​ tcp 抓包是指通过抓取计算机访问 Web 网站过程抓到的数据包，分析验证 TCP 报文段的结构。可以用抓包工具进行抓包分析。

**答案解析**

​ **示例（wireshark 抓包分析流程）：**

​ Wireshark 捕获的是网卡的网络包，当机器上有多块网卡的时候，需要先选择网卡。开始界面中的 Interface List，即网卡列表，选择我们需要的监控的网卡。点击 Capture Options，选择正确的网卡，然后点击"Start"按钮, 开始抓包。

![抓包 1](img/3f4d02417b5d26fb587ecc4181676840.png)

​ 我们打开浏览器输入任意 http 网址，连接再关闭，比如：[`blog.csdn.net。然后，我们回到 Wireshark 界面，点击左上角的停止按键。查看此时 Wireshark 的抓包信息。在看抓包信息之前，先简单介绍下 Wireshark 界面的含义。其中，封包列表的面板中显示**编号、时间戳、源地址、目标地址、协议、长度，以及封包信息**。`](http://blog.csdn.net%E3%80%82%E7%84%B6%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9B%9E%E5%88%B0Wireshark%E7%95%8C%E9%9D%A2%EF%BC%8C%E7%82%B9%E5%87%BB%E5%B7%A6%E4%B8%8A%E8%A7%92%E7%9A%84%E5%81%9C%E6%AD%A2%E6%8C%89%E9%94%AE%E3%80%82%E6%9F%A5%E7%9C%8B%E6%AD%A4%E6%97%B6Wireshark%E7%9A%84%E6%8A%93%E5%8C%85%E4%BF%A1%E6%81%AF%E3%80%82%E5%9C%A8%E7%9C%8B%E6%8A%93%E5%8C%85%E4%BF%A1%E6%81%AF%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%85%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8BWireshark%E7%95%8C%E9%9D%A2%E7%9A%84%E5%90%AB%E4%B9%89%E3%80%82%E5%85%B6%E4%B8%AD%EF%BC%8C%E5%B0%81%E5%8C%85%E5%88%97%E8%A1%A8%E7%9A%84%E9%9D%A2%E6%9D%BF%E4%B8%AD%E6%98%BE%E7%A4%BA**%E7%BC%96%E5%8F%B7%E3%80%81%E6%97%B6%E9%97%B4%E6%88%B3%E3%80%81%E6%BA%90%E5%9C%B0%E5%9D%80%E3%80%81%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E9%95%BF%E5%BA%A6%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%B0%81%E5%8C%85%E4%BF%A1%E6%81%AF**%E3%80%82)

![抓包 2](img/412494c34c672ad5bd6e9031de50c483.png)

​ **封包详细信息是用来查看协议中的每一个字段。**各行信息分别对应 TCP/IP 协议的不同层级。以下图为例，分别表示：传输层、网络层、数据链路层、物理层，一共四层。如果有应用层数据会显示第五层，即一共会出现五层。

![抓包 3](img/7c4990c96b4e495f46edb08ac00377ca.png)

​ 每一层都有一个字段指向上一层，表明上一层是什么协议。这大概是因为发包的时候会在数据上依次加上应用层、传输层、网络层、链路层的头部，但是对方收到数据包后是从最底层（链路层）开始层层剥去头部解包的，所以在每层上有一个字段指向上层，表明上层的协议，对方就知道下一步该怎么解包了。以 TCP/IP 协议为例，下图中分别是：IPv4、TCP。由于建立 TCP 连接用不到应用层协议，所以传输层就没有相应的指明上层(应用层)的字段了。

![抓包 4](img/2ccf604af8081c2f87fe022cb4c8a91c.png)

​ 在了解 Wireshark 界面后，我们来分析 TCP 协议。这里有很多数据包，我们需要先过滤，添加对应的过滤条件。比如，添加了目标的 ip 地址和端口号：tcp and ip.addr==47.95.47.253 and tcp.port==53992，此时获取到的封包列表如下。

![抓包 5](img/7d7dbeb255b140f54ab88f1529f47a32.png)

​ 在此之前，看下 TCP/IP 报文的格式。

![抓包 6](img/43bb3bea0d4ac87160cee1975a7b0166.png)

​ 根据上述报文格式我们可以将 wireshark 捕获到的 TCP 包中的每个字段与之对应起来，更直观地感受一下 TCP 通信过程。先看三次握手，下图中的 3 条数据包就是一次 TCP 建立连接的过程。

![抓包 7](img/5f1a940bf23d6080dc24daffce323178.png)

​ 第一次握手，客户端发送一个 TCP，标志位为 SYN=1，序号 seq 为 Sequence number=0， 53992 -> 80，代表客户端请求建立连接；

![抓包 8](img/4f30541fe0dd30906fe8a3fbf6cd08a7.png)

​ 第二次握手，服务器向客户端返回一个数据包，SYN=1，ACK=1，80 -> 53992，将确认序号(Acknowledgement Number)设置为客户的序号 seq(Sequence number)加 1，即 0+1=1；

![抓包 9](img/c1068ae5fcd92b77e61a652ce8d86ada.png)

​ 第三次握手，客户端收到服务器发来的包后检查确认序号(Acknowledgement Number)是否正确，即第一次发送的序号 seq 加 1（X+1= 0+1=1）。以及标志位 ACK 是否为 1。若正确，客户端会再向服务器端发送一个数据包，SYN=0，ACK=1，确认序号(Acknowledgement Number)=Y+1=0+1=1，并且把服务器发来 ACK 的序号 seq(Sequence number)加 1 发送给对方，发送序号 seq 为 X+1= 0+1=1。客户端收到后确认序号值与 ACK=1，53992 -> 80，至此，一次 TCP 连接就此建立，可以传送数据了。

![抓包 10](img/8c2cf28798c2a8b045c1b5c787279e02.png)

​ 还可以通过直接看标志位查看三次握手的数据包，如下图所示，第一个数据包标志位【SYN】，这是第一次握手；第二个数据包标志位【SYN,ACK】，这是第二次握手；第三个数据包标志位【ACK】，这是第三次握手。

![抓包 11](img/598e53b2d502a46154778a52607cab64.png)

​ 在三次握手的三个数据包之后，第四个包才是 HTTP 的， 这说明 HTTP 的确是使用 TCP 建立连接的。

![抓包 12](img/ac96640e61efdffbe05bd9cec8cba2b9.png)

​ 再往下看其他数据包，会发现存在大量的 TCP segment of a reassembled PDU，字面意思是要重组的协议数据单元（PDU：Protocol Data Unit）的 TCP 段，这是 TCP 层收到上层大块报文后分解成段后发出去。

![抓包 13](img/5342208619ca40805ab4a1f1103c8efd.png)

每个数据包的 Protocol Length 都是 1502 Byte，这是因为以太网帧的封包格式为：Frame = Ethernet Header + IP Header + TCP Header + TCP Segment Data。即：

（1）Ethernet Header = 14 Byte = Dst Physical Address（6 Byte）+ Src Physical Address（6 Byte）+ Type（2 Byte），以太网帧头以下称之为数据帧。

（2）IP Header = 20 Byte（without options field），数据在 IP 层称为 Datagram，分片称为 Fragment。

（3）TCP Header = 20 Byte（without options field），数据在 TCP 层称为 Stream，分段称为 Segment（UDP 中称为 Message）。

（4）TCP Segment Data = 1448 Byte（从下图可见）。

所以，每个数据包的 Protocol Length = 14 Byte + 20 Byte + 20 Byte + 1448 Byte = 1502 Byte。

![抓包 14](img/25343dfea75e99b04e68f69fe3ae48e9.png)

我们再来看四次挥手。TCP 断开连接时，会有四次挥手过程，标志位是 FIN，我们在封包列表中找到对应位置，理论上应该找到 4 个数据包，但我试了好几次，实际只抓到 3 个数据包。查了相关资料，说是因为服务器端在给客户端传回的过程中，将两个连续发送的包进行了合并。因此下面会按照合并后的三次挥手解释。

![抓包 15](img/5536613b36923738cd50d0ff56eb112d.png)

​ **第一次挥手：**客户端给服务器发送 TCP 包，用来关闭客户端到服务器的数据传送。将标志位 FIN 和 ACK 置为 1，序号 seq=X=2242，确认序号 ack=Z=17602，53992 -> 80；

![抓包 16](img/2fd6c6b49c3e248de385decf99f4175c.png)

​ **第二次挥手：**服务器收到 FIN 后，服务器关闭与客户端的连接，发回一个 FIN 和 ACK(标志位 FIN=1,ACK=1)，确认序号 ack 为收到的序号加 1，即 X=X+1=2243。序号 seq 为收到的确认序号=Z=17602，80 -> 53992；

![抓包 17](img/23d8c13e5a6c57c8049911d644f56970.png)

​ **第三次挥手：**客户端收到服务器发送的 FIN 之后，发回 ACK 确认(标志位 ACK=1),确认序号为收到的序号加 1，即 Y+1=17603。序号为收到的确认序号 X=2243，53992 -> 80。

![抓包 18](img/e743e481fc6005f2b223c2af9dc7a773.png)

至此，整个 TCP 通信过程已经介绍完毕。

#### 1.15 介绍一下 tcp 粘包、拆包的机制。

**参考回答**

1.  TCP 粘包和拆包问题

    ​ TCP 是一个“流”协议，所谓流，就是**没有界限的一长串二进制数据**。TCP 作为传输层协议并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的 TCP 粘包和拆包问题。

2.  产生 TCP 粘包和拆包的原因

    ​ 我们知道 TCP 是以流动的方式传输数据的，传输的**最小单位**为一个报文段（Segment）。TCP Header 中有个 Options 标识位。常见的标识位为 MSS（Maximum Segment Size）指的是，连接层每次传输的数据有个最大限制 MTU（Maximum Transmission Unit），一般是 1500bit，超过这个量要分成多个报文段，MSS 则是这个最大限制减去 TCP 的 header，光是要传输的数据的大小，一般为 1460bit。换算成字节，也就是 180 多字节。

    ```cpp
     TCP 为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了以后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制来接受数据。
    ```

    发生 TCP 粘包、拆包主要是以下原因：

    ```cpp
     （1）应用程序写入数据大于套接字缓冲区大小，会发生拆包；
     （2）应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发送粘包；
     （3）进行 MSS（最大报文长度）大小的 TCP 分段，当 TCP 报文长度——TCP header 长度>MSS  的时候会发生拆包；
     （4）接收方法不及时读取套接字缓冲区数据，这将发生粘包。
    ```

3.  如何处理粘包和拆包

    ​ **假设应用层协议是 http**

    ​ 我从浏览器中访问了一个网站，网站服务器给我发了 200k 的数据。建立连接的时候，通告的 MSS 是 50k，所以为了防止 ip 层分片，tcp 每次只会发送 50k 的数据，一共发了 4 个 tcp 数据包。如果我又访问了另一个网站，这个网站给我发了 100k 的数据，这次 tcp 会发出 2 个包，问题是，客户端收到 6 个包，怎么知道前 4 个包是一个页面，后两个是一个页面。既然是 tcp 将这些包分开了，那 tcp 会将这些包重组吗，它送给应用层的是什么？这是我自己想的一个场景，正式一点讲的话，**这个现象叫拆包**。

    ​ 我们再考虑一个问题。

    ​ tcp 中有一个 negal 算法，用途是这样的：通信两端有很多小的数据包要发送，虽然传送的数据很少，但是流程一点没少，也需要 tcp 的各种确认，校验。这样小的数据包如果很多，会造成网络资源很大的浪费，negal 算法做了这样一件事，当来了一个很小的数据包，我不急于发送这个包，而是等来了更多的包，将这些小包组合成大包之后一并发送，不就提高了网络传输的效率的嘛。这个想法收到了很好的效果，但是我们想一下，如果是分属于两个不同页面的包，被合并在了一起，那客户那边如何区分它们呢？**这就是粘包问题。**

    ​ 从粘包问题我们更可以看出为什么 tcp 被称为流协议，因为它就跟水流一样，是没有边界的，没有消息的边界保护机制，所以**tcp 只有流的概念，没有包的概念**。

    ​ 我们还需要有两个概念：

    ​ （1）**长连接**： Client 方与 Server 方先建立通讯连接，连接建立后不断开， 然后再进行报文发送和接收。
    ​ （2）**短连接**：Client 方与 Server 每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于一点对多点 通讯，比如多个 Client 连接一个 Server。

    ​ **实际**，我想象的**关于粘包的场景是不对的**，http 连接是短连接，请求之后，收到回答，立马断开连接，不会出现粘包。 拆包现象是有可能存在的。

    ​ **处理拆包**这里提供两种方法：

    ​ （1）通过包头+包长+包体的协议形式，当服务器端获取到指定的包长时才说明获取完整。
    ​ （2） 指定包的结束标识，这样当我们获取到指定的标识时，说明包获取完整。

    ​ **处理粘包**我们从上面的分析看到，虽然像 http 这样的短连接协议不会出现粘包的现象，但是一旦建立了长连接，粘包还是有可能会发生的。处理粘包的方法如下：

    ​ （1）发送方对于发送方造成的粘包问题，可以通过关闭 Nagle 算法来解决，使用 TCP_NODELAY 选项来关闭算法。

    ​ （2）接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，判断每条数据的长度的方法有两种：

    ​ a. 格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。

    ​ b. 发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前 4 位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。

**答案解析**

​ **扩展资料**

​ **UDP 会不会产生粘包问题呢？**

​ TCP 为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。UDP 则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。

​ 举个例子：有三个数据包，大小分别为 2k、4k、6k，如果采用 UDP 发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用 TCP 协议发送的话，我们只需要接受方的接收缓存有 12k 的大小，就可以一次把这 3 个数据包全部发送完毕。