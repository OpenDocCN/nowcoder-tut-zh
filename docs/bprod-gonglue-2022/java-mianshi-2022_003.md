# 第一章 第 2 节 Java 基础-2

> 原文：[`www.nowcoder.com/tutorial/10070/33e7b7d83277414a9999858b73eaf249`](https://www.nowcoder.com/tutorial/10070/33e7b7d83277414a9999858b73eaf249)

#### 1.6 请介绍全局变量和局部变量的区别

**参考答案**

Java 中的变量分为成员变量和局部变量，它们的区别如下：

成员变量：

1.  成员变量是在类的范围里定义的变量；
2.  成员变量有默认初始值；
3.  未被 static 修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同；
4.  被 static 修饰的成员变量也叫类变量，它存储于方法区中，生命周期与当前类相同。

局部变量：

1.  局部变量是在方法里定义的变量；
2.  局部变量没有默认初始值；
3.  局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。

**注意事项**

Java 中没有真正的全局变量，面试官应该是出于其他语言的习惯说全局变量的，他的本意应该是指成员变量。

#### 1.7 请介绍一下实例变量的默认值

**参考答案**

实例变量若为引用数据类型，其默认值一律为 null。若为基本数据类型，其默认值如下：

*   byte：0

*   short：0

*   int：0

*   long：0L

*   float：0.0F

*   double：0.0

*   char：'\u0000'

*   boolean：false

**注意事项**

上述默认值规则适用于所有的成员变量，所以对于类变量也是适用的。

#### 1.8 为啥要有包装类？

**参考答案**

Java 语言是面向对象的语言，其设计理念是“一切皆对象”。但 8 种基本数据类型却出现了例外，它们不具备对象的特性。正是为了解决这个问题，Java 为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。

**扩展阅读**

Java 之所以提供 8 种基本数据类型，主要是为了照顾程序员的传统习惯。这 8 种基本数据类型的确带来了一定的方便性，但在某些时候也会受到一些制约。比如，所有的引用类型的变量都继承于 Object 类，都可以当做 Object 类型的变量使用，但基本数据类型却不可以。如果某个方法需要 Object 类型的参数，但实际传入的值却是数字的话，就需要做特殊的处理了。有了包装类，这种问题就可以得以简化。

#### 1.9 说一说自动装箱、自动拆箱的应用场景

**参考答案**

自动装箱、自动拆箱是 JDK1.5 提供的功能。

自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型；

自动拆箱：可以把一个包装类型的对象直接赋值给对应的基本类型；

通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程。比如，某个方法的参数类型为包装类型，调用时我们所持有的数据却是基本类型的值，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法即可。

#### 1.10 如何对 Integer 和 Double 类型判断相等？

**参考答案**

Integer、Double 不能直接进行比较，这包括：

*   不能用==进行直接比较，因为它们是不同的数据类型；
*   不能转为字符串进行比较，因为转为字符串后，浮点值带小数点，整数值不带，这样它们永远都不相等；
*   不能使用 compareTo 方法进行比较，虽然它们都有 compareTo 方法，但该方法只能对相同类型进行比较。

整数、浮点类型的包装类，都继承于 Number 类型，而 Number 类型分别定义了将数字转换为 byte、short、int、long、float、double 的方法。所以，可以将 Integer、Double 先转为转换为相同的基本数据类型（如 double），然后使用==进行比较。

**示例代码**

```cpp
Integer i = 100;
Double d = 100.00;
System.out.println(i.doubleValue() == d.doubleValue());
```

#### 1.11 int 和 Integer 有什么区别，二者在做==运算时会得到什么结果？

**参考答案**

int 是基本数据类型，Integer 是 int 的包装类。二者在做==运算时，Integer 会自动拆箱为 int 类型，然后再进行比较。届时，如果两个 int 值相等则返回 true，否则就返回 false。

#### 1.12 说一说你对面向对象的理解

**参考答案**

面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。

**扩展阅读**

结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。

因为结构化程序设计方法主张按功能把软件系统逐步细分，因此这种方法也被称为面向功能的程序设计方法；结构化程序设计的每个功能都负责对数据进行一次处理，每个功能都接受一些数据，处理完后输出一些数据，这种处理方式也被称为面向数据流的处理方式。

结构化程序设计里最小的程序单元是函数，每个函数都负责完成一个功能，用以接收一些输入数据，函数对这些输入数据进行处理，处理结束后输出一些数据。整个软件系统由一个个函数组成，其中作为程序入口的函数被称为主函数，主函数依次调用其他普通函数，普通函数之间依次调用，从而完成整个软件系统的功能。

每个函数都是具有输入、输出的子系统，函数的输入数据包括函数形参、全局变量和常量等，函数的输出数据包括函数返回值以及传出参数等。结构化程序设计方式有如下两个局限性：

*   设计不够直观，与人类习惯思维不一致。采用结构化程序分析、设计时，开发者需要将客观世界模型分解成一个个功能，每个功能用以完成一定的数据处理。
*   适应性差，可扩展性不强。由于结构化设计采用自顶向下的设计方式，所以当用户的需求发生改变，或需要修改现有的实现方式时，都需要自顶向下地修改模块结构，这种方式的维护成本相当高。

#### 1.13 面向对象的三大特征是什么？

**参考答案**

面向对象的程序设计方法具有三个基本特征：封装、继承、多态。其中，封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。

**扩展阅读**

抽象也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。例如，需要考察 Person 对象时，不可能在程序中把 Person 的所有细节都定义出来，通常只能定义 Person 的部分数据、部分行为特征，而这些数据、行为特征是软件系统所关心的部分。

#### 1.14 封装的目的是什么，为什么要有封装？

**参考答案**

封装是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：

*   隐藏类的实现细节；
*   让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；
*   可进行数据检查，从而有利于保证对象信息的完整性；
*   便于修改，提高代码的可维护性。

**扩展阅读**

为了实现良好的封装，需要从两个方面考虑：

*   将对象的成员变量和实现细节隐藏起来，不允许外部直接访问；
*   把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。

封装实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。这两个方面都需要通过使用 Java 提供的访问控制符来实现。

#### 1.15 说一说你对多态的理解

**参考答案**

因为子类其实是一种特殊的父类，因此 Java 允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型，向上转型由系统自动完成。

当把一个子类对象直接赋给父类引用变量时，例如 `BaseClass obj = new SubClass();`，这个 obj 引用变量的编译时类型是 BaseClass，而运行时类型是 SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。

**扩展阅读**

多态可以提高程序的可扩展性，在设计程序时让代码更加简洁而优雅。

例如我要设计一个司机类，他可以开轿车、巴士、卡车等等，示例代码如下：

```cpp
class Driver {
    void drive(Car car) { ... }
    void drive(Bus bus) { ... }
    void drive(Truck truck) { ... }
}
```

在设计上述代码时，我已采用了重载机制，将方法名进行了统一。这样在进行调用时，无论要开什么交通工具，都是通过 `driver.drive(obj)` 这样的方式来调用，对调用者足够的友好。

但对于程序的开发者来说，这显得繁琐，因为实际上这个司机可以驾驶更多的交通工具。当系统需要为这个司机增加车型时，开发者就需要相应的增加 driver 方法，类似的代码会堆积的越来越多，显得臃肿。

采用多态的方式来设计上述程序，就会变得简洁很多。我们可以为所有的交通工具定义一个父类 Vehicle，然后按照如下的方式设计 drive 方法。调用时，我们可以传入 Vehicle 类型的实例，也可以传入任意的 Vechile 子类型的实例，对于调用者来说一样的方便，但对于开发者来说，代码却变得十分的简洁了。

```cpp
class Driver {
    void drive(Vehicle vehicle) { ... }
}
```