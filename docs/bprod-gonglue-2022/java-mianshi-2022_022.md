# 第二章 第 7 节 Java 数据库-7

> 原文：[`www.nowcoder.com/tutorial/10070/26744a0adaf84fca841bc0dc522e6bd0`](https://www.nowcoder.com/tutorial/10070/26744a0adaf84fca841bc0dc522e6bd0)

4.  优化 LIMIT 分页

    当偏移量非常大的时候，例如可能是 limit 10000,20 这样的查询，这是 mysql 需要查询 10020 条然后只返回最后 20 条，前面的 10000 条记录都将被舍弃，这样的代价很高。优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。

#### 5.6 说一说你对 explain 的了解

**参考答案**

MySQL 中提供了 EXPLAIN 语句和 DESCRIBE 语句，用来分析查询语句，EXPLAIN 语句的基本语法如下：

```cpp
EXPLAIN [EXTENDED] SELECT select_options
```

使用 EXTENED 关键字，EXPLAIN 语句将产生附加信息。执行该语句，可以分析 EXPLAIN 后面 SELECT 语句的执行情况，并且能够分析出所查询表的一些特征。下面对查询结果进行解释：

*   id：SELECT 识别符。这是 SELECT 的查询序列号。
*   select_type：表示 SELECT 语句的类型。
*   table：表示查询的表。
*   type：表示表的连接类型。
*   possible_keys：给出了 MySQL 在搜索数据记录时可选用的各个索引。
*   key：是 MySQL 实际选用的索引。
*   key_len：给出索引按字节计算的长度，key_len 数值越小，表示越快。
*   ref：给出了关联关系中另一个数据表里的数据列名。
*   rows：是 MySQL 在执行这个查询时预计会从这个数据表里读出的数据行的个数。
*   Extra：提供了与关联操作有关的信息。

**扩展阅读**

DESCRIBE 语句的使用方法与 EXPLAIN 语句是一样的，分析结果也是一样的，并且可以缩写成 DESC。。DESCRIBE 语句的语法形式如下：

```cpp
DESCRIBE SELECT select_options
```

#### 5.7 explain 关注什么？

**参考答案**

重点要关注如下几列：

| 列名 | 备注 |
| --- | --- |
| type | 本次查询表联接类型，从这里可以看到本次查询大概的效率。 |
| key | 最终选择的索引，如果没有索引的话，本次查询效率通常很差。 |
| key_len | 本次查询用于结果过滤的索引实际长度。 |
| rows | 预计需要扫描的记录数，预计需要扫描的记录数越小越好。 |
| Extra | 额外附加信息，主要确认是否出现 Using filesort、Using temporary 这两种情况。 |

其中，type 包含以下几种结果，从上之下依次是最差到最好：

| 类型 | 备注 |
| --- | --- |
| ALL | 执行 full table scan，这是最差的一种方式。 |
| index | 执行 full index scan，并且可以通过索引完成结果扫描并且直接从索引中取的想要的结果数据，也就是可以避免回表，比 ALL 略好，因为索引文件通常比全部数据要来的小。 |
| range | 利用索引进行范围查询，比 index 略好。 |
| index_subquery | 子查询中可以用到索引。 |
| unique_subquery | 子查询中可以用到唯一索引，效率比 index_subquery 更高些。 |
| index_merge | 可以利用 index merge 特性用到多个索引，提高查询效率。 |
| ref_or_null | 表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值。 |
| fulltext | 全文检索。 |
| ref | 基于索引的等值查询，或者表间等值连接。 |
| eq_ref | 表连接时基于主键或非 NULL 的唯一索引完成扫描，比 ref 略好。 |
| const | 基于主键或唯一索引唯一值查询，最多返回一条结果，比 eq_ref 略好。 |
| system | 查询对象表只有一行数据，这是最好的情况。 |

另外，Extra 列需要注意以下的几种情况：

| 关键字 | 备注 |
| --- | --- |
| Using filesort | 将用外部排序而不是按照索引顺序排列结果，数据较少时从内存排序，否则需要在磁盘完成排序，代价非常高，需要添加合适的索引。 |
| Using temporary | 需要创建一个临时表来存储结果，这通常发生在对没有索引的列进行 GROUP BY 时，或者 ORDER BY 里的列不都在索引里，需要添加合适的索引。 |
| Using index | 表示 MySQL 使用覆盖索引避免全表扫描，不需要再到表中进行二次查找数据，这是比较好的结果之一。注意不要和 type 中的 index 类型混淆。 |
| Using where | 通常是进行了全表/全索引扫描后再用 WHERE 子句完成结果过滤，需要添加合适的索引。 |
| Impossible WHERE | 对 Where 子句判断的结果总是 false 而不能选择任何数据，例如 where 1=0，无需过多关注。 |
| Select tables optimized away | 使用某些聚合函数来访问存在索引的某个字段时，优化器会通过索引直接一次定位到所需要的数据行完成整个查询，例如 MIN()\MAX()，这种也是比较好的结果之一。 |

## 6\. 其他

#### 6.1 介绍一下数据库设计的三大范式

**参考答案**

目前关系数据库有六种范式，一般来说，数据库只需满足第三范式(3NF）就行了。

第一范式（1NF）：

是指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。

即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。

第二范式（2NF）：

在 1NF 的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖）。

第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。

例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复，无法区分出实体时，设计辟如 ID 等不重复的编号以实现区分，被添加的编号或 ID 选作主键。

第三范式（3NF）：

在 2NF 基础上，任何非主属性不依赖于其它非主属性（在 2NF 基础上消除传递依赖）。

第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。

例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。

#### 6.2 说一说你对 MySQL 引擎的了解

**参考答案**

MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。MySQL 8.0 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。其中，最常用的引擎是 InnoDB 和 MyISAM。

InnoDB 存储引擎：

InnoDB 是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎，主要特性如下：

1.  InnoDB 给 MySQL 提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID 兼容）存储引擎。InnoDB 锁定在行级并且也在 SELECT 语句中提供一个类似 Oracle 的非锁定读。这些功能增加了多用户部署和性能。在 SQL 查询中，可以自由地将 InnoDB 类型的表与其他 MySQL 表的类型混合起来，甚至在同一个查询中也可以混合。
2.  InnoDB 是为处理巨大数据量的最大性能设计。它的 CPU 效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。
3.  InnoDB 存储引擎完全与 MySQL 服务器整合，为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB 将它的表和索引存在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与 MyISAM 表不同，比如在 MyISAM 表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为 2GB 的操作系统上。
4.  InnoDB 支持外键完整性约束（FOREIGN KEY）。存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB 会为每一行生成一个 6B 的 ROWID，并以此作为主键。
5.  InnoDB 被用在众多需要高性能的大型数据库站点上。InnoDB 不创建目录，使用 InnoDB 时，MySQL 将在数据目录下创建一个名为 ibdata1 的 10MB 大小的自动扩展数据文件，以及两个名为 ib_logfile0 和 ib_logfile1 的 5MB 大小的日志文件。

MyISAM 存储引擎：

MyISAM 基于 ISAM 存储引擎，并对其进行扩展。它是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。MyISAM 的主要特性如下：

1.  在支持大文件（达 63 位文件长度）的文件系统和操作系统上被支持。
2.  当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块以及若下一个块被删除则扩展到下一块来自动完成。
3.  每个 MyISAM 表最大的索引数是 64，这可以通过重新编译来改变。每个索引最大的列数是 16 个。
4.  最大的键长度是 1000B，这也可以通过编译来改变。对于键长度超过 250B 的情况，一个超过 1024B 的键将被用上。
5.  BLOB 和 TEXT 列可以被索引。
6.  NULL 值被允许在索引的列中，这个值占每个键的 0~1 个字节。
7.  所有数字键值以高字节优先被存储，以允许一个更高的索引压缩。
8.  每个表一个 AUTO_INCREMENT 列的内部处理。MyISAM 为 INSERT 和 UPDATE 操作自动更新这一列，这使得 AUTO_INCREMENT 列更快（至少 10%）。在序列顶的值被删除之后就不能再利用。
9.  可以把数据文件和索引文件放在不同目录。
10.  每个字符列可以有不同的字符集。
11.  有 VARCHAR 的表可以固定或动态记录长度。
12.  VARCHAR 和 CHAR 列可以多达 64KB。