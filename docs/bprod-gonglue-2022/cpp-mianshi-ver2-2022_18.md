# 第一章 第 17 节 C++stl-4

> 原文：[`www.nowcoder.com/tutorial/10069/24bc6660539b43bdaeb118a03d6a4ef6`](https://www.nowcoder.com/tutorial/10069/24bc6660539b43bdaeb118a03d6a4ef6)

#### 1.4.14 简述 STL 中的 map 的实现原理

**参考回答**

​ map 是关联式容器，它们的底层容器都是**红黑树**。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。

1.  map 的特性如下

    （1）map 以 RBTree 作为底层容器；

    （2）所有元素都是键+值存在；

    （3）不允许键重复；

    （4）所有元素是通过键进行自动排序的；

    （5）map 的键是不能修改的，但是其键对应的值是可以修改的。

#### 1.4.15 C++ 的 vector 和 list 中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？

**参考回答**

1.  迭代器和指针之间的区别

    ​ **迭代器不是指针，是类模板，表现的像指针。**他只是模拟了指针的一些功能，重载了指针的一些操作符，-->、++、--等。迭代器封装了指针，是一个”可遍历 STL（ Standard Template Library）容器内全部或部分元素”的对象，**本质**是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

    ​ **迭代器返回的是对象引用而不是对象的值**，所以 cout 只能输出迭代器使用取值后的值而不能直接输出其自身。

2.  vector 和 list 特性

    **vector 特性** 动态数组。元素在内存连续存放。随机存取任何元素都在常数时间完成。在尾端增删元素具有较大的性能（大部分情况下是常数时间）。

    **list 特性** 双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。

3.  vector 增删元素

    对于 vector 而言，删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase 返回下一个有效的迭代器。

4.  list 增删元素

    对于 list 而言，删除某个元素，只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响。

#### 1.4.16 请你来说一下 map 和 set 有什么区别，分别又是怎么实现的？

**参考回答**

1.  set 是一种关联式容器，其特性如下：

    （1）set 以 RBTree 作为底层容器

    （2）所得元素的只有 key 没有 value，value 就是 key

    （3）不允许出现键值重复

    （4）所有的元素都会被自动排序

    （5）不能通过迭代器来改变 set 的值，因为 set 的值就是键，set 的迭代器是 const 的

2.  map 和 set 一样是关联式容器，其特性如下：

    （1）map 以 RBTree 作为底层容器

    （2）所有元素都是键+值存在

    （3）不允许键重复

    （4）所有元素是通过键进行自动排序的

    （5）map 的键是不能修改的，但是其键对应的值是可以修改的

    综上所述，map 和 set**底层实现**都是红黑树；map 和 set 的**区别**在于 map 的值不作为键，键和值是分开的。