# 第二章 第 6 节 c++操作系统-6

> 原文：[`www.nowcoder.com/tutorial/10069/204c6e5bfae74b1ba6cc4dd25fcbf65a`](https://www.nowcoder.com/tutorial/10069/204c6e5bfae74b1ba6cc4dd25fcbf65a)

### 2.51 进程和线程相比，为什么慢？

**参考回答**

1.  进程系统开销显著大于线程开销；线程需要的系统资源更少。
2.  进程切换开销比线程大。多进程切换时需要刷新 TLB 并获取新的地址空间，然后切换硬件上下文和内核栈；多线程切换时只需要切换硬件上下文和内核栈。
3.  进程通信比线程通信开销大。进程通信需要借助管道、队列、共享内存，需要额外申请空间，通信繁琐；而线程共享进程的内存，如代码段、数据段、扩展段，通信快捷简单，同步开销更小。

### 2.52 简述 Linux 零拷贝的原理？

**参考回答**

1.  **什么是零拷贝**：

    所谓「零拷贝」描述的是计算机操作系统当中，CPU 不执行将数据从一个内存区域，拷贝到另外一个内存区域的任务。通过网络传输文件时，这样通常可以节省 CPU 周期和内存带宽。

2.  **零拷贝的好处**：

    （1）节省了 CPU 周期，空出的 CPU 可以完成更多其他的任务

    （2）减少了内存区域之间数据拷贝，节省内存带宽

    （3）减少用户态和内核态之间数据拷贝，提升数据传输效率

    （4）应用零拷贝技术，减少用户态和内核态之间的上下文切换

3.  **零拷贝原理**：

    在传统 IO 中，用户态空间与内核态空间之间的复制是完全不必要的，因为用户态空间仅仅起到了一种数据转存媒介的作用，除此之外没有做任何事情。

    **（1）Linux 提供了 sendfile() 用来减少我们的数据拷贝和上下文切换次数。**

    过程如图：
    ![图片说明](img/f85e450d9e9e89ee54cbd9fbebe742f7.png "图片标题")

    a. 发起 sendfile() 系统调用，操作系统由用户态空间切换到内核态空间（第一次上下文切换）

    b. 通过 DMA 引擎将数据从磁盘拷贝到内核态空间的输入的 socket 缓冲区中（第一次拷贝）

    c. 将数据从内核空间拷贝到与之关联的 socket 缓冲区（第二次拷贝）

    d. 将 socket 缓冲区的数据拷贝到协议引擎中（第三次拷贝）

    e. sendfile() 系统调用结束，操作系统由用户态空间切换到内核态空间（第二次上下文切换）

    根据以上过程，一共有 2 次的上下文切换，3 次的 I/O 拷贝。我们看到从用户空间到内核空间并没有出现数据拷贝，**从操作系统角度来看，这个就是零拷贝**。内核空间出现了复制的原因: 通常的硬件在通过 DMA 访问时期望的是连续的内存空间。

    （2）**mmap 数据零拷贝原理**

    **如果需要对数据做操作，Linux 提供了 mmap 零拷贝来实现。**

### 2.53 简述 epoll 和 select 的区别，epoll 为什么高效？

**参考回答**

1.  **区别**：

    （1）每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；而 epoll 保证了每个 fd 在整个过程中只会拷贝一次。

    （2）每次调用 select 都需要在内核遍历传递进来的所有 fd；而 epoll 只需要轮询一次 fd 集合，同时查看就绪链表中有没有就绪的 fd 就可以了。

    （3）select 支持的文件描述符数量太小了，默认是 1024；而 epoll 没有这个限制，它所支持的 fd 上限是最大可以打开文件的数目，这个数字一般远大于 2048。

2.  **epoll 为什么高效**：

    （1）select，poll 实现需要自己不断轮询所有 fd 集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而 epoll 只要判断一下就绪链表是否为空就行了，这节省了大量的 CPU 时间。

    （2）select，poll 每次调用都要把 fd 集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而 epoll 只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。

### 2.54 说说多路 IO 复用技术有哪些，区别是什么？

**参考回答**

1.  **select，poll，epoll**都是 IO 多路复用的机制，I/O 多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。

2.  **区别**：

    （1）poll 与 select 不同，通过一个 pollfd 数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd 中的 events 字段和 revents 分别用于标示关注的事件和发生的事件，故 pollfd 数组只需要被初始化一次。

    （2）select，poll 实现需要自己不断轮询所有 fd 集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而 epoll 只要判断一下就绪链表是否为空就行了，这节省了大量的 CPU 时间。

    （3）select，poll 每次调用都要把 fd 集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而 epoll 只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。

### 2.55 简述 socket 中 select，epoll 的使用场景和区别，epoll 水平触发与边缘触发的区别？

**参考回答**

1.  **select，epoll 的使用场景**：都是 IO 多路复用的机制，应用于高并发的网络编程的场景。I/O 多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。

2.  **select，epoll 的区别**：

    （1）每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；而 epoll 保证了每个 fd 在整个过程中只会拷贝一次。

    （2）每次调用 select 都需要在内核遍历传递进来的所有 fd；而 epoll 只需要轮询一次 fd 集合，同时查看就绪链表中有没有就绪的 fd 就可以了。

    （3）select 支持的文件描述符数量太小了，默认是 1024；而 epoll 没有这个限制，它所支持的 fd 上限是最大可以打开文件的数目，这个数字一般远大于 2048。

3.  **epoll 水平触发与边缘触发的区别**

    LT 模式（水平触发）下，只要这个 fd 还有数据可读，每次 epoll_wait 都会返回它的事件，提醒用户程序去操作；

    而在 ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论 fd 中是否还有数据可读。

### 2.56 说说 Reactor、Proactor 模式。

**参考回答**

在高性能的 I/O 设计中，有两个比较著名的模式 Reactor 和 Proactor 模式，其中**Reactor 模式用于同步 I/O**，而**Proactor 运用于异步 I/O**操作。

1.  **Reactor 模式**：Reactor 模式应用于同步 I/O 的场景。Reactor 中读操作的具体步骤如下：

    读取操作：

    （1）应用程序注册读就需事件和相关联的事件处理器

    （2）事件分离器等待事件的发生

    （3）当发生读就需事件的时候，事件分离器调用第一步注册的事件处理器

    （4）事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理

2.  **Proactor 模式**：Proactor 模式应用于异步 I/O 的场景。Proactor 中读操作的具体步骤如下：

    （1）应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于 Reactor 的关键。

    （2）事件分离器等待读取操作完成事件

    （3）在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于 Reactor 的一点，Proactor 中，应用程序需要传递缓存区。

    （4）事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。

3.  **区别**：从上面可以看出，Reactor 中需要**应用程序自己读取或者写入数据**，而 Proactor 模式中，应用程序不需要用户再自己接收数据，直接使用就可以了，操作系统会将数据从**内核拷贝到用户区**。

**答案解析**

IO 模型的类型。
（1）阻塞 IO：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。

（2）非阻塞 IO：非阻塞等待，每隔一段时间就去检查 IO 事件是否就绪。没有就绪就可以做其他事情。

（3）信号驱动 IO：Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当 IO 事件就绪，进程收到 SIGIO 信号，然后处理 IO 事件。

（4）IO 多路复用：Linux 用 select/poll 函数实现 IO 复用模型，这两个函数也会使进程阻塞，但是和阻塞 IO 所不同的是这两个函数可以同时阻塞多个 IO 操作。而且可以同时对多个读操作、写操作的 IO 函数进行检查。知道有数据可读或可写时，才真正调用 IO 操作函数。

（5）异步 IO：Linux 中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。

前四种模型--阻塞 IO、非阻塞 IO、多路复用 IO 和信号驱动 IO 都属于**同步模式**，因为其中真正的 IO 操作(函数)都将会阻塞进程，只有**异步 IO 模型**真正实现了 IO 操作的异步性。

### 2.57 简述同步与异步的区别，阻塞与非阻塞的区别？

**参考回答**

1.  **同步与异步的区别**：

    **同步**：是所有的操作都做完，才返回给用户结果。即**写完数据库**之后，**再响应用户**，用户体验不好。

    **异步**：不用等所有操作都做完，就响应用户请求。即**先响应用户请求**，然后**慢慢去写数据库**，用户体验较好。

2.  **阻塞与非阻塞的区别**：

    **阻塞**：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。

    **非阻塞**：非阻塞等待，每隔一段时间就去检查 IO 事件是否就绪。没有就绪就可以做其他事情。

### 2.58 BIO、NIO 有什么区别？

**参考回答**

**BIO（Blocking I/O）**：**阻塞 IO**。调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。

**NIO（New I/O）**：**同时支持阻塞与非阻塞模式**，NIO 的做法是叫一个线程不断的轮询每个 IO 的状态，看看是否有 IO 的状态发生了改变，从而进行下一步的操作。

### 2.59 请介绍一下 5 种 IO 模型

**参考回答**

1.  阻塞 IO：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。
2.  非阻塞 IO：非阻塞等待，每隔一段时间就去检查 IO 事件是否就绪。没有就绪就可以做其他事情。
3.  信号驱动 IO：Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当 IO 事件就绪，进程收到 SIGIO 信号，然后处理 IO 事件。
4.  IO 多路复用：Linux 用 select/poll 函数实现 IO 复用模型，这两个函数也会使进程阻塞，但是和阻塞 IO 所不同的是这两个函数可以同时阻塞多个 IO 操作。而且可以同时对多个读操作、写操作的 IO 函数进行检查。知道有数据可读或可写时，才真正调用 IO 操作函数。
5.  异步 IO：Linux 中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。

**答案解析**

前四种模型--阻塞 IO、非阻塞 IO、多路复用 IO 和信号驱动 IO 都属于**同步模式**，因为其中真正的 IO 操作(函数)都将会阻塞进程，只有**异步 IO 模型**真正实现了 IO 操作的异步性。

**异步和同步的区别就在于**，异步是内核将数据拷贝到用户区，不需要用户再自己接收数据，直接使用就可以了，而同步是内核通知用户数据到了，然后用户自己调用相应函数去接收数据。

### 2.60 请说一下 socket 网络编程中客户端和服务端用到哪些函数？

**参考回答**

1.  **服务器端函数**：

    （1）socket 创建一个套接字

    （2）bind 绑定 ip 和 port

    （3）listen 使套接字变为可以被动链接

    （4）accept 等待客户端的链接

    （5）write/read 接收发送数据

    （6）close 关闭连接

2.  **客户端函数**：

    （1）创建一个 socket，用函数 socket()

    （2）bind 绑定 ip 和 port

    （3）连接服务器，用函数 connect()

    （4）收发数据，用函数 send()和 recv()，或 read()和 write()

    （5）close 关闭连接、

![image-20201221105446608](img/f05b4ff6726f9d034ebca9adc3470517.png)

### 2.61 简述网络七层参考模型，每一层的作用？

**参考回答**

| OSI 七层模型 | 功能 | 对应的网络协议 | TCP/IP 四层概念模型 |
| --- | --- | --- | :-: |
| 应用层 | 文件传输，文件管理，电子邮件的信息处理 | HTTP、TFTP, FTP, NFS, WAIS、SMTP | 应用层 |
| 表示层 | 确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密。 | Telnet, Rlogin, SNMP, Gopher | 应用层 |
| 会话层 | 负责在网络中的两节点建立，维持和终止通信。 | SMTP, DNS | 应用层 |
| 传输层 | 定义一些传输数据的协议和端口。 | TCP, UDP | 传输层 |
| 网络层 | 控制子网的运行，如逻辑编址，分组传输，路由选择 | IP, ICMP, ARP, RARP, AKP, UUCP | 网络层 |
| 数据链路层 | 主要是对物理层传输的比特流包装，检测保证数据传输的可靠性，将物理层接收的数据进行 MAC（媒体访问控制）地址的封装和解封装 | FDDI, Ethernet, Arpanet, PDN, SLIP, PPP，STP。HDLC,SDLC,帧中继 | 数据链路层 |
| 物理层 | 定义物理设备的标准，主要对物理连接方式，电气特性，机械特性等制定统一标准。 | IEEE 802.1A, IEEE 802.2 到 IEEE 802. | 数据链路层 |