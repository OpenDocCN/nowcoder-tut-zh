# 第一章 第 5 节 语言基础-5

> 原文：[`www.nowcoder.com/tutorial/10069/07544e20b1de404caf88fdef78624daa`](https://www.nowcoder.com/tutorial/10069/07544e20b1de404caf88fdef78624daa)

#### 1.1.19 说说 C++中函数指针和指针函数的区别。

**参考回答**

1.  **定义不同**
    指针函数本质是一个函数，其返回值为指针。
    函数指针本质是一个指针，其指向一个函数。

2.  **写法不同**

    ```cpp
    指针函数：int *fun(int x,int y);
    函数指针：int (*fun)(int x,int y);
    ```

3.  **用法不同**

    用法参考答案解析

**答案解析**

```cpp
//指针函数示例
typedef struct _Data{
    int a;
    int b;
}Data;
//指针函数
Data* f(int a,int b){
    Data * data = new Data;
    //...
    return data;
}
int main(){
    //调用指针函数
    Data * myData = f(4,5);
    //Data * myData = static_cast<Data*>(f(4,5));
   //...
}

//函数指针示例
int add(int x,int y){
    return x+y;
}
//函数指针
int (*fun)(int x,int y);
//赋值
fun = add;
//调用
cout << "(*fun)(1,2) = " << (*fun)(1,2) ;
//输出结果
//(*fun)(1,2) =  3
```

#### 1.1.20 说说 const int *a, int const *a, const int a, int *const a, const int *const a 分别是什么，有什么特点。

**参考回答**

```cpp
1\. const int a;     //指的是 a 是一个常量，不允许修改。
2\. const int *a;    //a 指针所指向的内存里的值不变，即（*a）不变
3\. int const *a;    //同 const int *a;
4\. int *const a;    //a 指针所指向的内存地址不变，即 a 不变
5\. const int *const a;   //都不变，即（*a）不变，a 也不变
```

#### 1.1.21 说说使用指针需要注意什么？

**参考回答**

1.  定义指针时，先初始化为 NULL。
2.  用 malloc 或 new 申请内存之后，应该**立即检查**指针值是否为 NULL。防止使用指针值为 NULL 的内存。
3.  不要忘记为数组和动态内存**赋初值**。防止将未被初始化的内存作为右值使用。
4.  避免数字或指针的下标**越界**，特别要当心发生“多 1”或者“少 1”操作
5.  动态内存的申请与释放必须配对，防止**内存泄漏**
6.  用 free 或 delete 释放了内存之后，立即将指针**设置为 NULL**，防止“野指针”

**答案解析**

（1）初始化置 NULL

（2）申请内存后判空

（3）指针释放后置 NULL

```cpp
int *p = NULL; //初始化置 NULL
p = (int *)malloc(sizeof(int)*n); //申请 n 个 int 内存空间  
assert(p != NULL); //判空，防错设计
p = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址
free(p);  
p = NULL; //释放后置空

int *p1 = NULL; //初始化置 NULL
p1 = (int *)calloc(n, sizeof(int)); //申请 n 个 int 内存空间同时初始化为 0 
assert(p1 != NULL); //判空，防错设计
free(p1);  
p1 = NULL; //释放后置空

int *p2 = NULL; //初始化置 NULL
p2 = new int[n]; //申请 n 个 int 内存空间  
assert(p2 != NULL); //判空，防错设计
delete []p2;  
p2 = nullptr; //释放后置空  
```

#### 1.1.22 说说内联函数和函数的区别，内联函数的作用。

**参考回答**

1.  内联函数比普通函数多了关键字**inline**
2.  内联函数避免了函数调用的**开销**；普通函数有调用的开销
3.  普通函数在被调用的时候，需要**寻址（函数入口地址）**；内联函数不需要寻址。
4.  内联函数有一定的限制，内联函数体要求**代码简单**，不能包含复杂的结构控制语句；普通函数没有这个要求。

**内联函数的作用**：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。

**答案解析**

在使用内联函数时，应注意如下几点：　

1.  在内联函数内不允许用循环语句和开关语句。　
    如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有 1～5 行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。　
2.  内联函数的定义必须出现在内联函数第一次被调用之前。　

#### 1.1.23 简述 C++有几种传值方式，之间的区别是什么？

**参考回答**

传参方式有这三种：**值传递、引用传递、指针传递**

1.  值传递：形参即使在函数体内值发生变化，也不会影响实参的值；

2.  引用传递：形参在函数体内值发生变化，会影响实参的值；

3.  指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；

**答案解析**

值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。

代码示例

```cpp
//代码示例
#include <iostream>
using namespace std;

void testfunc(int a, int *b, int &c){//形参 a 值发生了改变，但是没有影响实参 i 的值；但形参*b、c 的值发生了改变，影响到了实参*j、k 的值
    a += 1;
    (*b) += 1;
    c += 1;
    printf("a= %d, b= %d, c= %d\n",a,*b,c);//a= 2, b= 2, c= 2
}
int main(){
       int i = 1;
    int a = 1;
    int *j = &a;
    int k = 1;
    testfunc(i, j, k);
    printf("i= %d, j= %d, k= %d\n",i,*j,k);//i= 1, j= 2, k= 2
    return 0;
}
```

#### 1.1.24 简述 const（星号）和（星号）const 的区别

**参考回答**

```cpp
//const* 是指针常量，*const 是常量指针

int const *a;    //a 指针所指向的内存里的值不变，即（*a）不变
int *const a;    //a 指针所指向的内存地址不变，即 a 不变
```

**答案解析**

无。