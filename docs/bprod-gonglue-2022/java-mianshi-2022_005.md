# 第一章 第 4 节 Java 基础-4

> 原文：[`www.nowcoder.com/tutorial/10070/3d11192f6d9e440c98f721dafd4a5192`](https://www.nowcoder.com/tutorial/10070/3d11192f6d9e440c98f721dafd4a5192)

#### 1.38 请介绍 Java 的异常接口

**参考答案**

Throwable 是异常的顶层父类，代表所有的非正常情况。它有两个直接子类，分别是 Error、Exception。

Error 是错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断。通常应用程序无法处理这些错误，因此应用程序不应该试图使用 catch 块来捕获 Error 对象。在定义方法时，也无须在其 throws 子句中声明该方法可能抛出 Error 及其任何子类。

Exception 是异常，它被分为两大类，分别是 Checked 异常和 Runtime 异常。所有的 RuntimeException 类及其子类的实例被称为 Runtime 异常；不是 RuntimeException 类及其子类的异常实例则被称为 Checked 异常。Java 认为 Checked 异常都是可以被处理（修复）的异常，所以 Java 程序必须显式处理 Checked 异常。如果程序没有处理 Checked 异常，该程序在编译时就会发生错误，无法通过编译。Runtime 异常则更加灵活，Runtime 异常无须显式声明抛出，如果程序需要捕获 Runtime 异常，也可以使用 try...catch 块来实现。

#### 1.39 finally 是无条件执行的吗？

**参考答案**

不管 try 块中的代码是否出现异常，也不管哪一个 catch 块被执行，甚至在 try 块或 catch 块中执行了 return 语句，finally 块总会被执行。

**注意事项**

如果在 try 块或 catch 块中使用 `System.exit(1);` 来退出虚拟机，则 finally 块将失去执行的机会。但是我们在实际的开发中，重来都不会这样做，所以尽管存在这种导致 finally 块无法执行的可能，也只是一种可能而已。

#### 1.40 在 finally 中 return 会发生什么？

**参考答案**

在通常情况下，不要在 finally 块中使用 return、throw 等导致方法终止的语句，一旦在 finally 块中使用了 return、throw 语句，将会导致 try 块、catch 块中的 return、throw 语句失效。

**详细解析**

当 Java 程序执行 try 块、catch 块时遇到了 return 或 throw 语句，这两个语句都会导致该方法立即结束，但是系统执行这两个语句并不会结束该方法，而是去寻找该异常处理流程中是否包含 finally 块，如果没有 finally 块，程序立即执行 return 或 throw 语句，方法终止；如果有 finally 块，系统立即开始执行 finally 块。只有当 finally 块执行完成后，系统才会再次跳回来执行 try 块、catch 块里的 return 或 throw 语句；如果 finally 块里也使用了 return 或 throw 等导致方法终止的语句，finally 块已经终止了方法，系统将不会跳回去执行 try 块、catch 块里的任何代码。

#### 1.41 说一说你对 static 关键字的理解

**参考答案**

在 Java 类里只能包含成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）5 种成员，而 static 可以修饰成员变量、方法、初始化块、内部类（包括接口、枚举），以 static 修饰的成员就是类成员。类成员属于整个类，而不属于单个对象。

对 static 关键字而言，有一条非常重要的规则：类成员（包括成员变量、方法、初始化块、内部类和内部枚举）不能访问实例成员（包括成员变量、方法、初始化块、内部类和内部枚举）。因为类成员是属于类的，类成员的作用域比实例成员的作用域更大，完全可能出现类成员已经初始化完成，但实例成员还不曾初始化的情况，如果允许类成员访问实例成员将会引起大量错误。

#### 1.42 static 修饰的类能不能被继承？

**参考答案**

static 修饰的类可以被继承。

**扩展阅读**

如果使用 static 来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此使用 static 修饰的内部类被称为类内部类，有的地方也称为静态内部类。

static 关键字的作用是把类的成员变成类相关，而不是实例相关，即 static 修饰的成员属于整个类，而不属于单个对象。外部类的上一级程序单元是包，所以不可使用 static 修饰；而内部类的上一级程序单元是外部类，使用 static 修饰可以将内部类变成外部类相关，而不是外部类实例相关。因此 static 关键字不可修饰外部类，但可修饰内部类。

静态内部类需满足如下规则：

1.  静态内部类可以包含静态成员，也可以包含非静态成员；

2.  静态内部类不能访问外部类的实例成员，只能访问它的静态成员；

3.  外部类的所有方法、初始化块都能访问其内部定义的静态内部类；

4.  在外部类的外部，也可以实例化静态内部类，语法如下：

    ```cpp
    外部类.内部类 变量名 = new 外部类.内部类构造方法();
    ```

#### 1.43 static 和 final 有什么区别？

**参考答案**

static 关键字可以修饰成员变量、成员方法、初始化块、内部类，被 static 修饰的成员是类的成员，它属于类、不属于单个对象。以下是 static 修饰这 4 种成员时表现出的特征：

*   类变量：被 static 修饰的成员变量叫类变量（静态变量）。类变量属于类，它随类的信息存储在方法区，并不随对象存储在堆中，类变量可以通过类名来访问，也可以通过对象名来访问，但建议通过类名访问它。
*   类方法：被 static 修饰的成员方法叫类方法（静态方法）。类方法属于类，可以通过类名访问，也可以通过对象名访问，建议通过类名访问它。
*   静态块：被 static 修饰的初始化块叫静态初始化块。静态块属于类，它在类加载的时候被隐式调用一次，之后便不会被调用了。
*   静态内部类：被 static 修饰的内部类叫静态内部类。静态内部类可以包含静态成员，也可以包含非静态成员。静态内部类不能访问外部类的实例成员，只能访问外部类的静态成员。外部类的所有方法、初始化块都能访问其内部定义的静态内部类。

final 关键字可以修饰类、方法、变量，以下是 final 修饰这 3 种目标时表现出的特征：

*   final 类：final 关键字修饰的类不可以被继承。
*   final 方法：final 关键字修饰的方法不可以被重写。
*   final 变量：final 关键字修饰的变量，一旦获得了初始值，就不可以被修改。

**扩展阅读**

变量分为成员变量、局部变量。

final 修饰成员变量：

*   类变量：可以在声明变量时指定初始值，也可以在静态初始化块中指定初始值；
*   实例变量：可以在声明变量时指定初始值，也可以在初始化块或构造方法中指定初始值；

final 修饰局部变量：

*   可以在声明变量时指定初始值，也可以在后面的代码中指定初始值。

*注意：被 final 修饰的任何形式的变量，一旦获得了初始值，就不可以被修改！*

#### 1.44 说一说你对泛型的理解

**参考答案**

Java 集合有个缺点—把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，当再次取出该对象时，该对象的编译类型就变成了 Object 类型（其运行时类型没变）。

Java 集合之所以被设计成这样，是因为集合的设计者不知道我们会用集合来保存什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性。但这样做带来如下两个问题：

*   集合对元素类型没有任何限制，这样可能引发一些问题。例如，想创建一个只能保存 Dog 对象的集合，但程序也可以轻易地将 Cat 对象“丢”进去，所以可能引发异常。
*   由于把对象“丢进”集合时，集合丢失了对象的状态信息，只知道它盛装的是 Object，因此取出集合元素后通常还需要进行强制类型转换。这种强制类型转换既增加了编程的复杂度，也可能引发 ClassCastException 异常。

从 Java 5 开始，Java 引入了“参数化类型”的概念，允许程序在创建集合时指定集合元素的类型，Java 的参数化类型被称为泛型（Generic）。例如 `List<String>`，表明该 List 只能保存字符串类型的对象。

有了泛型以后，程序再也不能“不小心”地把其他对象“丢进”集合中。而且程序更加简洁，集合自动记住所有集合元素的数据类型，从而无须对集合元素进行强制类型转换。

#### 1.45 介绍一下泛型擦除

**参考答案**

在严格的泛型代码里，带泛型声明的类总应该带着类型参数。但为了与老的 Java 代码保持一致，也允许在使用带泛型声明的类时不指定实际的类型。如果没有为这个泛型类指定实际的类型，此时被称作 raw type（原始类型），默认是声明该泛型形参时指定的第一个上限类型。

当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉。比如一个 `List<String>` 类型被转换为 List，则该 List 对集合元素的类型检查变成了泛型参数的上限（即 Object）。

上述规则即为泛型擦除，可以通过下面代码进一步理解泛型擦除：

```cpp
List<String> list1 = ...;
List list2 = list1; // list2 将元素当做 Object 处理
```

**扩展阅读**

从逻辑上来看，`List<String>` 是 List 的子类，如果直接把一个 List 对象赋给一个`List<String>`对象应该引起编译错误，但实际上不会。对泛型而言，可以直接把一个 List 对象赋给一个 `List<String>` 对象，编译器仅仅提示“未经检查的转换”。

上述规则叫做泛型转换，可以通过下面代码进一步理解泛型转换：

```cpp
List list1 = ...;
List<String> list2 = list1; // 编译时警告“未经检查的转换”
```

#### 1.46 List<? super T>和 List<? extends T>有什么区别？

**参考答案**

*   ? 是类型通配符，`List<?>` 可以表示各种泛型 List 的父类，意思是元素类型未知的 List；
*   `List<? super T>` 用于设定类型通配符的下限，此处 ? 代表一个未知的类型，但它必须是 T 的父类型；
*   `List<? extends T>` 用于设定类型通配符的上限，此处 ? 代表一个未知的类型，但它必须是 T 的子类型。

**扩展阅读**

在 Java 的早期设计中，允许把 Integer[]数组赋值给 Number[]变量，此时如果试图把一个 Double 对象保存到该 Number[]数组中，编译可以通过，但在运行时抛出 ArrayStoreException 异常。这显然是一种不安全的设计，因此 Java 在泛型设计时进行了改进，它不再允许把 `List<Integer>` 对象赋值给 `List<Number>` 变量。

数组和泛型有所不同，假设 Foo 是 Bar 的一个子类型（子类或者子接口），那么 Foo[]依然是 Bar[]的子类型，但`G<Foo>` 不是 `G<Bar>` 的子类型。Foo[]自动向上转型为 Bar[]的方式被称为型变，也就是说，Java 的数组支持型变，但 Java 集合并不支持型变。Java 泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时 ClassCastException 异常。

#### 1.47 说一说你对 Java 反射机制的理解

**参考答案**

Java 程序中的对象在运行时可以表现为两种类型，即编译时类型和运行时类型。例如 `Person p = new Student();` ，这行代码将会生成一个 p 变量，该变量的编译时类型为 Person，运行时类型为 Student。

有时，程序在运行时接收到外部传入的一个对象，该对象的编译时类型是 Object，但程序又需要调用该对象的运行时类型的方法。这就要求程序需要在运行时发现对象和类的真实信息，而解决这个问题有以下两种做法：

*   第一种做法是假设在编译时和运行时都完全知道类型的具体信息，在这种情况下，可以先使用 instanceof 运算符进行判断，再利用强制类型转换将其转换成其运行时类型的变量即可。
*   第二种做法是编译时根本无法预知该对象和类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射。

具体来说，通过反射机制，我们可以实现如下的操作：

*   程序运行时，可以通过反射获得任意一个类的 Class 对象，并通过这个对象查看这个类的信息；
*   程序运行时，可以通过反射创建任意一个类的实例，并访问该实例的成员；
*   程序运行时，可以通过反射机制生成一个类的动态代理类或动态代理对象。