# 网易 2021 校招笔试-Java 开发工程师（正式第二批）

## 1

Comparable 和 Comparator 区别是什么？

你的答案

本题知识点

Java 工程师 网易 2021

讨论

[木子汐](https://www.nowcoder.com/profile/378279329)

Comparable 可作为一个类的内部排序实现，Java 中一些普通类型如 String、Integer 等都实现了该接口，我们直接使用即可。Comparator 是外部排序接口，使用策略模式，一个类的排序规则在基于“开闭原则”时，可通过实现 Compartor 制定多个比较排序策略，供该类采用。可用于 Collections.sort()、Arrays.sort()以及一些内部有序的类（SortedSet、SortedMap 等）。

发表于 2021-03-05 12:08:28

* * *

[牛客 122753322 号](https://www.nowcoder.com/profile/122753322)

1.Comparator 位于包 java.util 下，而 Comparable 位于包 java.lang 下 2.Comparable 接口将比较代码嵌入自身类中，而 Comparator 在一个独立的类中实现比较。3.Comparator 接口的比較方法 compare(A,B)有兩個參數，Comparable 的比較方法 compareTo(A)只有 1 個參數

发表于 2021-01-27 14:34:58

* * *

[牛客 572395163 号](https://www.nowcoder.com/profile/572395163)

Bznna

发表于 2022-02-20 12:40:26

* * *

## 2

http/2 相比 http/1.1 有什么新特性？

你的答案

本题知识点

Java 工程师 网易 2021

讨论

[牛客 122753322 号](https://www.nowcoder.com/profile/122753322)

*   **多路复用：** 即多个请求都通过一个 TCP 连接并发地完成
*   **服务端推送：** 服务端能够主动把资源推送给客户端
*   **新的二进制格式：** HTTP/2 采用二进制格式传输数据，相比于 HTTP/1.1 的文本格式，二进制格式具有更好的解析性和拓展性
*   **header 压缩：** HTTP/2 压缩消息头，减少了传输数据的大小

发表于 2021-01-27 14:39:28

* * *

[0123_6](https://www.nowcoder.com/profile/2550165)

1.  二进制分帧
    http1.x 是文本格式传输，http2 二进制格式传输，并且被切分为多个帧发送，帧可以根据头部流标识重新组装。
2.  单一长连接
    同一个域名使用一个 TCP 连接,能减少握手带来的延时.
3.  多路复用
    HTTP/2 允许在相同连接中多个请求和回答交错.
4.  头部压缩
    用 HPACK 压缩头部,使用首部表来进行首部字段存储,只有当首部表中的数据变更或为发送过时,才会发送 HTTP 头部字段.首部表分为静态表和动态表,静态表包含常用字段,动态表包含自定义字段等非常用字段,当新增或改变字段时,会增加或修改动态表中的数据.
5.  服务器推送
    客户端请求资源 X,服务器判断客户端还需要别的资源,可以主动推送这些资源,客户端需要显示允许服务器启用推送功能.

发表于 2020-12-31 21:54:44

* * *

[DQING](https://www.nowcoder.com/profile/380666670)

1、数据上的区别
HTTP / 1.1 使用文本数据，这通常在网络上效率较低。而 HTTP / 2 是二进制数据。 2、标头的区别
标头是与请求一起发送的信息，它描述了数据，其来源，类型，长度，可以缓存的时间等。
HTTP / 1.1 的标头没有压缩，而 HTTP / 2 的标头是压缩的。 3、响应请求的顺序
在 HTTP / 1.1 中，服务器必须以接收请求的相同顺序发送响应。而，HTTP / 2 是异步的，它使用流水线，因此可以更快地处理，更快的响应。

4、HTTP / 2 是多路复用的
在 HTTP / 1.1 中，任何时候都只能在 TCP 连接上处理一个请求。浏览器通常在四到八个连接之间打开，但是大型或慢速资产可能导致其他文件的下载延迟。而，HTTP / 2 允许同时在同一（单个）连接上发送多个请求和响应消息。

发表于 2021-03-19 19:53:53

* * *

## 3

A 公司和 B 公司有 n 个合作的子项目，每个子项目由 A 公司和 B 公司各一名员工参与。一名员工可以参与多个子项目。一个员工如果担任了该项目的项目经理，它需要对所参与的该项目负责。一个员工也可以负责多个项目。A 公司和 B 公司需要保证所有子项目都能有人负责，问最少需要指定几名项目经理？

本题知识点

Java 工程师 网易 2021 游戏研发工程师 算法工程师

讨论

[人类的本质是人类的本质是人类的本质是](https://www.nowcoder.com/profile/1583436)

这道题看起来应该是 **二分图最小点覆盖**由 Konig 定理可知，最小点覆盖数=最大匹配边数转换为**二分图的最大匹配问题**(虽然这是一道板子题，但还是有点离谱

发表于 2021-01-16 20:03:13

* * *

[LancelotLT](https://www.nowcoder.com/profile/173277400)

思路是：基于二分图最小点覆盖进行求解，由 koing 定理二分图中的最小点覆盖数=最大匹配数。想吐槽的是：这个试题输出的 用例数据都不分行，完全没办法用于本地调试，简直是 XXXXXX。Python 代码如下：

```cpp
if __name__ == '__main__':
    def dfs(x, graph_dict, visited, left):
        b_members = graph_dict[x]
        for b_m in b_members:  # 同一次 增广路寻找中，若 v 曾经被达到过，则跳过。
            if visited[b_m] == 0:  # 若 x 能到达的 右部结点 b_m 为非匹配点，则找到了一条长度为 1 的增广路，记：left[b_m] = x
                visited[b_m] = 1
                if b_m not in left.keys():
                    left[b_m] = x
                    return True
                else:
                    # 若 b_m 为匹配点，则递归的从 left[b_m]出发寻找增广路，回溯时记：left[b_m] = x
                    dfs(left[b_m], graph_dict, visited, left)
                    left[b_m] = x
                    return True
        return False

    # a_company = list(map(int, input().split(' ')))
    # b_company = list(map(int, input().split(' ')))
    # n = int(input())
    # projects = []
    # for _ in range(n):
    #     temp = list(map(int, input().split(' ')))
    #     projects.append(temp)
    a_company = [0, 1, 2]
    b_company = [3, 4, 5]
    projects = [[0, 4], [0, 3], [1, 3], [1, 4], [2, 5], [2, 4]]
    graph_dict = {}
    for p in projects:
        if p[0] not in graph_dict.keys():
            graph_dict[p[0]] = []
        graph_dict[p[0]].append(p[1])
    # 根据建立的二分图，寻找 最大匹配数 = 最小点覆盖数
    visited = {}  # 记录右部节点是否被匹配过
    for b_m in b_company:
        visited[b_m] = 0
    left = {}  # 匹配右部 i 点的左部节点
    ans = 0
    for a_m in a_company:  # 从 a 公司的任一节点出发，依次寻找增广路，并查找返回结果
        if dfs(a_m, graph_dict, visited, left):
            ans += 1
    print(ans)

```

发表于 2021-04-03 21:08:56

* * *

[Soccer,soccer,soccer!](https://www.nowcoder.com/profile/396822396)

import java.util.*;

public class Main
{

public static void main(String[] args)
{
Scanner sc = new Scanner(System.in);
String left = sc.nextLine();
String right = sc.nextLine();
int n = sc.nextInt();
String[] l = left.split(" ");
String[] r = right.split(" ");
int[] a = new int[l.length];
int[] b = new int[r.length];
HashMap<Integer, Integer> num = new HashMap<Integer, Integer>();
int count = 0;
int length = a.length + b.length;
int[][] map = new int[length][length];
int[] match = new int[length];
Boolean[] used = new Boolean[length];
for (int i = 0; i < length; i++)
{
Arrays.fill(used, false);
Arrays.fill(map[i], -1);
Arrays.fill(match, -1);
}

for (int i = 0; i < a.length; i++)
{
a[i] = Integer.valueOf(l[i]);
num.put(a[i], i);
}
for (int i = 0; i < b.length; i++)
{
b[i] = Integer.valueOf(r[i]);
num.put(b[i], i + a.length);
}
for (int i = 0; i < n; i++)
{
int xx = sc.nextInt();
int yy = sc.nextInt();
map[num.get(xx)][num.get(yy)] = 1;
map[num.get(yy)][num.get(xx)] = 1;
}
search(num, a, b, map, match, used, length);
for (int i = 0; i < length; i++)
{
if(match[i] != -1)
{
count++;
}
}
System.out.println(count/2);
}
public static Boolean findPath(HashMap<Integer, Integer> num, int[][] map, int x, Boolean[] used, int[] match, int length)
{
for (int i = 0; i < length; i++)
{
if(map[x][i] == 1)
{
if(used[i] == false)
{
used[i] = true;
if(match[i] == -1 || findPath(num, map, match[i], used, match, length))
{
match[x] = i;
match[i] = x;
return true;
}
}
}

}
return false;
}
public static void setUsed(Boolean[] used)
{
for (int i = 0; i < used.length; i++)
{
used[i] = false;
}
}
public static void search(HashMap<Integer, Integer> num, int[] a, int[] b, int[][] map, int[] match, Boolean[] used, int length)
{
for (int i = 0; i < a.length; i++)
{
if(match[num.get(a[i])] == -1)
{
setUsed(used);
findPath(num, map, num.get(a[i]), used, match, length);
}
}
for (int i = 0; i < b.length; i++)
{
if(match[num.get(b[i])] == -1)
{
setUsed(used);
findPath(num, map, num.get(b[i]), used, match, length);
}
}
}

}
代码参考[匈牙利算法的 Java 语言实现 _bluespacezero 的博客-CSDN 博客](https://blog.csdn.net/Q_AN1314/article/details/79488562?spm=1001.2014.3001.5506)

编辑于 2021-04-29 00:39:25

* * *

## 4

疫情逐步缓和后，电影院终于开业了，但是由于当前仍处于疫情期间，应尽量保持人群不聚集的原则。
所以当小易来电影院选定一排后，尽量需要选择一个远离人群的位置。
已知由 0 和 1 组成的数组表示当前排的座位情况,其中 1 表示已被选座，0 表示空座
请问小易所选座位和最近人的距离座位数最大是多少？
有如下假设：至少有一个人已选座，至少有一个空座位，且座位数限制为![](img/a583703dfe8a2d32ada949276ed91783.svg)

本题知识点

Java 工程师 网易 2021 游戏研发工程师 算法工程师 前端工程师 运维工程师 安卓工程师 iOS 工程师

讨论

[ccbbs](https://www.nowcoder.com/profile/688123147)

js 解法：分割 1，首尾单独判断

```cpp
let _str=readline();
_str = _str.replace(/ /g, '');
let _arr = _str.split('1');
_arr = _arr.map((v, i) => {
    if (i === 0 || i === _arr.length - 1) {
        return v.length;
    }
    return Math.ceil(v.length / 2);
})
console.log(Math.max.apply(null, _arr));
```

发表于 2021-02-22 14:15:27

* * *

[零葬](https://www.nowcoder.com/profile/75718849)

假设数组有 n 个元素，则有两种情况：第一种是买边上的座位，如果边上的座位都是空的，买最左边或者最右边的座位，那最大的距离就是索引 0 和 n-1 分别与离自己最近的 1 的距离的最大值。第二种是买中间的座位，即从第一个 1 到最后一个 1 之间的某个座位，这时候需要寻找两个隔得最远的 1，这时候这两个 1 距离的一半就是中间位置的最大距离。综上两种情况，选择更大的那个距离，就是我们要求的最大距离

```cpp
seats = list(map(int, input().strip().split()))
n = len(seats)
# 先找到左边第一个 1 出现的索引
edge = seats.index(1)
l_bound = edge
r_bound = n - 1
# 再找右边第一个 1 出现的索引，两者选大的作为边缘最大的距离
for i in range(n - 1, -1, -1):
    if seats[i] == 1:
        edge = max(edge, n - 1 - i)
        right = i
        break
# 对于从 left~right 的子数组，寻找其中两个相邻 1 最大的距离即可
distance = 0
ones_idx = [l_bound]
for i in range(l_bound + 1, r_bound + 1):
    if seats[i] == 1:
        distance = max(distance, i - ones_idx[-1])
        ones_idx.append(i)
print(max(edge, distance // 2))
```

发表于 2021-01-19 10:18:23

* * *

[Pekin](https://www.nowcoder.com/profile/610410428)

```cpp
java，时间 O(n)的解法，双指针实现

```
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        String[] s1 = scan.nextLine().split(" ");
        scan.close();
        int[] nums = new int[s1.length];
        for (int i = 0; i < nums.length; i++)
            nums[i] = Integer.parseInt(s1[i]);

        int res = 0;
        int left, right;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 1) continue;
            left = i-1;
            right = i+1;
            int tmpRes = 1;
            while (left >= 0 || right < nums.length) {
                if ((left >= 0 && nums[left] == 1) || (right < nums.length && nums[right] == 1)) {
                    res = Math.max(res, tmpRes);
                    break;
                }
                if (left >= 0) left--;
                if (right < nums.length) right++;
                tmpRes++;
            }
            if (left < 0 && right >= nums.length) 
                res = Math.max(res, tmpRes);
        }
        System.out.println(res);
    }
}
```cpp

```

 发表于 2021-09-16 16:17:07

* * *

## 5

已知摩尔斯电码和字符映射关系如下：

*   A -> 0

*   B -> 1

*   C -> 10

*   D -> 11

*   E -> 100

*   F -> 101

*   G -> 110

*   H -> 111

当前我们获取到了一串 01 数字字符串，需要进行摩尔斯电码解码，请问共有多少种解码方法？

本题知识点

C++工程师 网易 2021 Java 工程师 大数据开发工程师 游戏研发工程师 前端工程师 运维工程师 安卓工程师 iOS 工程师

讨论

[零葬](https://www.nowcoder.com/profile/75718849)

动态规划求解，注意当遇到字符'1'的时候，有三种翻译的方式

```cpp
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] str = br.readLine().toCharArray();
        int n = str.length;
        int[] dp = new int[n + 1];
        dp[n] = 1;         // 最后一个字符肯定只能是一种翻译
        // 从后往前遍历字符
        for(int i = n - 1; i >= 0; i--){
            dp[i] = dp[i + 1];     // 单字符码的情况
            if(str[i] == '1'){      // 对于"1"，还有双字符码和三字符码的情况
                if(i + 2 <= n) dp[i] += dp[i + 2];
                if(i + 3 <= n) dp[i] += dp[i + 3];
            }
        }
        System.out.println(dp[0]);
    }
}
```

发表于 2021-01-20 23:00:33

* * *

[飞哥 011](https://www.nowcoder.com/profile/816171558)

这个题贼***,他样例 11110110100111011001111100101010110011110111001000 的时候会成为负数-871755317,所以你如果怕超 int,你用 long 型得到正数反而错了,只会 50 个过 41,41/50

发表于 2021-11-09 09:16:28

* * *

[kobeaaa](https://www.nowcoder.com/profile/35908270)

```cpp
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        int length = str.length();
        int[] dp = new int[length+2];
        for(int i=0;i<length+2;i++) dp[i]=0;
        for(int i=0;i<length;i++){
            if (i==0){
                dp[i] = 1;
                if("1".equals(str.substring(i,i+1))){
                    dp[i+1] += 1;
                    dp[i+2] += 1;
                }
            }else{
                dp[i] += dp[i-1];
                if("1".equals(str.substring(i,i+1))){
                    dp[i+1] += dp[i-1];
                    dp[i+2] += dp[i-1];
                }
            }

        }
        System.out.println(dp[length-1]);
    }
}
```

发表于 2021-08-20 14:03:34

* * *

## 6

网易严选建有 N 个自营仓分布在全国各地，标记为仓库 1 到 N。给定一个配货时间组（v,u,w)，v 为出发仓库，u 为目标仓库，w 为从出发仓库到目标仓库的耗时时间。可能存在仓库间过远，无法支持调拨转货。指定一个出发仓库 K，我们需要将供应商发送到 K 仓库的货配送到各个仓库。问配送到所有可到达仓库所要最短时间？如果无法全部调拨到，则返回-1\.进阶：时间复杂度![](img/baeb1b03c2212f1e3ff7da28e9bc419b.svg)，空间复杂度![](img/baeb1b03c2212f1e3ff7da28e9bc419b.svg)

本题知识点

C++工程师 网易 2021 Java 工程师 游戏研发工程师 大数据开发工程师 算法工程师

讨论

[C_lover](https://www.nowcoder.com/profile/887526444)

懒得写 dijskra 了。。就 Floyd 应付一下

```cpp
int dijskra(vector<vector<int>>& graph, int N, int source)
{
    for (int k = 1; k <= N; ++k) {
        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= N; ++j) {
                if (graph[i][k] != INT_MAX && graph[k][j] != INT_MAX)
                    graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);
            }
        }
    }
    int ans = INT_MIN;
    for (int i = 1; i <= N; ++i) {
        ans = max(ans, graph[source][i]);
    }
    if (ans == INT_MAX)return -1;
    return ans;
}
int main()
{
    int N, K, M, v, u, w;
    cin >> N >> K >> M;
    vector<vector<int>> graph(N + 1, vector<int>(N + 1, INT_MAX));
    for (int i = 0; i < M; ++i) {
        cin >> v >> u >> w;
        graph[v][u] = w;
    }
    for (int i = 0; i < N; ++i) {
        graph[i][i] = 0;
    }
    cout << dijskra(graph, N, K);
    return 0;
}
```

发表于 2021-01-03 18:36:57

* * *

[meriour](https://www.nowcoder.com/profile/977281236)

写一个 python 版本的最短路径

```cpp
def solution(start, graph, N):
    passed = [start]
    nopass = [x for x in range(1, N + 1) if x != start]
    dis = graph[start]

    while len(nopass):
        idx = nopass[0]
                # 选出距离起点最近的点
        for i in nopass:
            if dis[i] < dis[idx]:
                idx = i
        nopass.remove(idx)
        passed.append(idx)
                # 更新距离
        for i in nopass:
            if dis[i] > dis[idx] + graph[idx][i]:
                dis[i] = dis[idx] + graph[idx][i]
    return max(dis[1:]) if max(dis[1:]) != float("inf") else -1

N, K, M = input().strip().split(' ')
N, K, M = int(N), int(K), int(M)
graph = [[float("inf")] * (N + 1) for _ in range(N + 1)]
for i in range(N + 1):
    graph[i][i] = 0
for _ in range(M):
    s, t, d = input().strip().split(' ')
    s, t, d = int(s), int(t), int(d)
    graph[s][t] = min(d, graph[s][t])
print(solution(K, graph, N))

```

发表于 2021-01-05 21:50:27

* * *

[Meteor💫](https://www.nowcoder.com/profile/501331669)

套一下 dijkstra 模板就好了

```cpp
import java.util.*;
public class Main {

    static int max = Integer.MAX_VALUE / 2;

    static int N;
    static int k;
    static List> adj;
    static int[] dist;
    static boolean[] st;
    static PriorityQueue heap = new PriorityQueue();

    static class Node implements Comparable {
        int idx;
        int cost;

        public Node(int idx, int cost) {
            this.idx = idx;
            this.cost = cost;
        }

        @Override
        public int compareTo(Node o) {
            return this.cost - o.cost;
        }
    }

    static void dijkstra() {
        Arrays.fill(dist, max);
        dist[k] = 0;

        heap.offer(k);
        while (!heap.isEmpty()) {
            int idx = heap.poll();
            st[idx] = true;

            // 更新邻接的节点
            for (Node v : adj.get(idx)) {
                if (dist[v.idx] > dist[idx] + v.cost) {
                    dist[v.idx] = dist[idx] + v.cost;
                    heap.offer(v.idx);
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt();
        k = sc.nextInt();
        int m = sc.nextInt();
        adj = new ArrayList();
        for (int i = 0; i <= N; i++) {
            adj.add(new ArrayList());
        }
        dist = new int[N + 1];
        st = new boolean[N + 1];

        while (m-- > 0) {
            adj.get(sc.nextInt()).add(new Node(sc.nextInt(), sc.nextInt()));
        }

        dijkstra();

        // 判断是否都可达
        int time = 0;
        for (int i = 1; i <= N; i++) {
            if (dist[i] >= max) {
                time = -1;
                break;
            } else {
                time = Math.max(time, dist[i]);
            }
        }

        System.out.println(time);
    }
}
```

发表于 2022-02-10 17:48:21

* * *