# 第五章 第 2 节 前端基础-js1

> 原文：[`www.nowcoder.com/tutorial/10072/b0521f9e04cb4e0db0086e8b4bff7e59`](https://www.nowcoder.com/tutorial/10072/b0521f9e04cb4e0db0086e8b4bff7e59)

#### 2.1 let const var 相关

**参考答案：**

var ——ES5 变量声明方式

1.  在变量未赋值时，变量 undefined（为使用声明变量时也为 undefined）
2.  作用域——var 的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用

let——ES6 变量声明方式

1.  在变量为声明前直接使用会报错
2.  作用域——let 为块作用域——通常 let 比 var 范围要小
3.  let 禁止重复声明变量，否则会报错；var 可以重复声明

const——ES6 变量声明方式

​ 1\. const 为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改该常量的值

​ 2\. const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动

#### 2.2 js 数据类型，区别

**参考答案：**

基本数据类型：

​ Number，String，Boolean，null，undefined，symbol，bigint（后两个为 ES6 新增）

引用数据类型：

​ object，function（**proto** Function.prototype）

​ object：普通对象，数组对象，正则对象，日期对象，Math 数学函数对象。

两种数据存储方式：

​ 基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基 本类型值和执行代码的空间。

​ 引用数据类型是存储在堆内存中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆 中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。

两种数据类型的区别：

1.  堆比栈空间大，栈比堆运行速度快。

2.  堆内存是无序存储，可以根据引用直接获取。

3.  基础数据类型比较稳定，而且相对来说占用的内存小。

4.  引用数据类型大小是动态的，而且是无限的。

#### 2.3 Object.assign 的理解

**参考答案：**

作用：Object.assign 可以实现对象的合并。

语法：`Object.assign(target, ...sources)`

**解析**：

1.  Object.assign 会将 source 里面的可枚举属性复制到 target，如果和 target 的已有属性重名，则会覆盖。
2.  后续的 source 会覆盖前面的 source 的同名属性。
3.  Object.assign 复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。

#### 2.4 constructor 的理解

**参考答案：**

创建的每个函数都有一个 prototype（原型）对象，这个属性是一个指针，指向一个对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性是一个指向 prototype 属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（继承自构造函数的 prototype），指向构造函数的原型对象。注意当将构造函数的 prototype 设置为等于一个以对象字面量形式创建的新对象时，constructor 属性不再指向该构造函数。

#### 2.5 map 和 forEach 的区别

**参考答案：**

相同点：

1.  都是循环遍历数组中的每一项

2.  每次执行匿名函数都支持三个参数，参数分别为 item（当前每一项），index（索引值），arr（原数组）

3.  匿名函数中的 this 都是指向 window

4.  只能遍历数组

不同点：

1.  map()会分配内存空间存储新数组并返回，forEach()不会返回数据。

2.  forEach()允许 callback 更改原始数组的元素。map()返回新的数组。

#### 2.6 for of 可以遍历哪些对象

**参考答案：**

for..of..: 它是 es6 新增的一个遍历方法，但**只限于迭代器(iterator)**, 所以普通的对象用 for..of 遍历
是会报错的。

可迭代的对象：包括 Array, Map, Set, String, TypedArray, arguments 对象等等

#### 2.7 js 静态类型检查

**参考答案：**

**js 是动态类型语言**

​ 静态类型语言 & 动态类型语言

​ 静态类型语言：类型检查发生在编译阶段，因此除非修复错误，否则会一直编译失败

​ 动态类型语言：只有在程序运行了一次的时候错误才会被发现，也就是在运行时，因此即使代码中包含了会 在运行时阻止脚本正常运行的错误类型，这段代码也可以通过编译

**js 静态类型检查的方法**

​ **Flow**是 Facebook 开发和发布的一个开源的静态类型检查库，它允许你逐渐地向 JavaScript 代码中添加类型。

​ **TypeScript**是一个会编译为 JavaScript 的超集（尽管它看起来几乎像一种新的静态类型语言）

**使用静态类型的优势**

*   可以尽早发现 bug 和错误
*   减少了复杂的错误处理
*   将数据和行为分离
*   减少单元测试的数量
*   提供了领域建模（domain modeling）工具
*   帮助我们消除了一整类 bug
*   重构时更有信心

**使用静态类型的劣势**

*   代码冗长
*   需要花时间去掌握类型

#### 2.8 indexof

**参考答案：**

语法：str.indexOf(searchValue [, fromIndex])

参数：searchValue：要被查找的字符串值。

​ 如果没有提供确切地提供字符串，[searchValue 会被强制设置为 `"undefined"`]， 然后在当前字符串中查 找这个值。

​ 举个例子：`'undefined'.indexOf()` 将会返回 0，因为 `undefined` 在位置 0 处被找到，但是 `'undefine'.indexOf()` 将会返回 -1 ，因为字符串 `'undefined'` 未被找到

fromIndex：可选

​ 数字表示开始查找的位置。可以是任意整数，默认值为 `0`。

​ 如果 `fromIndex` 的值小于 `0`，或者大于 `str.length` ，那么查找分别从 `0` 和`str.length` 开始。（译者 注： `fromIndex` 的值小于 `0`，等同于为空情况； `fromIndex` 的值大于或等于 `str.length` ，那么结果 会直接返回 `-1` 。）

​ 举个例子，`'hello world'.indexOf('o', -5)` 返回 `4` ，因为它是从位置`0`处开始查找，然后 `o` 在位置 `4`处被找到。另一方面，`'hello world'.indexOf('o', 11)` （或 `fromIndex` 填入任何大于`11`的值） 将会返回 `-1` ，因为开始查找的位置`11`处，已经是这个字符串的结尾了。

返回值：

​ 查找的字符串 `searchValue` 的**第一次**出现的索引，如果没有找到，则返回 `-1`。

​ 若被查找的字符串 `searchValue` 是一个空字符串，则返回 fromIndex。如果 `fromIndex` 值为空，或者 `fromIndex` 值小于被查找的字符串的长度，返回值和以下的 `fromIndex` 值一样。

​ 如果 `fromIndex` 值大于等于字符串的长度，将会直接返回字符串的长度（`str.length`）

特点：

​ 1\. 严格区分大小写

​ 2\. 在使用 indexOf 检索数组时，用‘===’去匹配，意味着会检查数据类型

#### 2.9 iframe 有什么优点、缺点

**参考答案：**

优点：

1.  iframe 能够原封不动的把嵌入的网页展现出来。
2.  如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
3.  网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。
4.  如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。

缺点：

1.  iframe 会阻塞主页面的 onload 事件；
2.  iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。会产生很多页面，不容易管理。
3.  iframe 框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。
4.  代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理 iframe 中的内容，所以使用 iframe 会不利于搜索引擎优化（SEO）。
5.  很多的移动设备无法完全显示框架，设备兼容性差。
6.  iframe 框架页面会增加服务器的 http 请求，对于大型网站是不可取的。

#### 2.10 webComponents

**参考答案：**

​ **Web Components** 总的来说是提供一整套完善的封装机制来把 Web 组件化这个东西标准化，每个框架实现 的组件都统一标准地进行输入输出，这样可以更好推动组件的复用

​ 包含四个部分

​ 1\. Custom Elements

​ 2\. HTML Imports

​ 3\. HTML Templates

​ 4\. Shadow DOM

​ **Custom Elements**

​ 提供一种方式让开发者可以自定义 HTML 元素，包括特定的组成，样式和行为。支持 Web Components 标准的浏览器会提供一系列 API 给开发者用于创建自定义的元素，或者扩展现有元素。

​ **HTML Imports**

​ 一种在 HTMLs 中引用以及复用其他的 HTML 文档的方式。这个 Import 很漂亮，可以简单理解为我们常见 的模板中的 `include` 之类的作用

​ **HTML Templates**

​ 模板

​ **Shadow DOM**

​ 提供一种更好地组织页面元素的方式，来为日趋复杂的页面应用提供强大支持，避免代码间的相互影响