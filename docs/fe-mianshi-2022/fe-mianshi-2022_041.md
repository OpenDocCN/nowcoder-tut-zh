# 第五章 第 22 节 前端基础-css2

> 原文：[`www.nowcoder.com/tutorial/10072/d565f61436fa4c92946ebff5b07d0896`](https://www.nowcoder.com/tutorial/10072/d565f61436fa4c92946ebff5b07d0896)

#### 10.6 样式优先级

**参考答案**：

样式类型

样式类型分为三类

1.  行间

```cpp
<h1 style="font-size:12px;color:#000;">我的行间 CSS 样式。</h1>
```

2.  内联

```cpp
<style type="text/css">
   h1{font-size:12px;
      color:#000;
      }
</style>
```

3.  外部

```cpp
<link rel="stylesheet" href="css/style.css">
```

选择器类型

*   1、ID　　#id
*   2、class　　.class
*   3、标签　　p
*   4、通用　　*
*   5、属性　　[type="text"]
*   6、伪类　　:hover
*   7、伪元素　　::first-line
*   8、子选择器、相邻选择器

权重计算规则

第一等：代表内联样式，如: style=””，权值为 1000。
第二等：代表 ID 选择器，如：#content，权值为 0100。
第三等：代表类，伪类和属性选择器，如.content，权值为 0010。
第四等：代表类型选择器和伪元素选择器，如 div p，权值为 0001。
通配符、子选择器、相邻选择器等的。如*、>、+,权值为 0000。
继承的样式没有权值。

比较规则

遵循如下法则：

*   选择器都有一个权值，权值越大越优先；
*   当权值相等时，后出现的样式表设置要优于先出现的样式表设置；
*   创作者的规则高于浏览者：即网页编写者设置的 CSS 样式的优先权高于浏览器所设置的样式；
*   继承的 CSS 样式不如后来指定的 CSS 样式；
*   在同一组属性设置中标有!important 规则的优先级最大
*   通配符、子选择器、相邻选择器等的。虽然权值为 0000，但是也比继承的样式优先。

！important

1.  !important 的作用是提升优先级，换句话说。加了这句的样式的优先级是最高的（比内联样式的优先级还高)。

```cpp
<style> 
p{
    color:red !important;
} 
</style>
<p style="color:blue;">我显示红色</p>
```

2.  ie7+和别的浏览器对 important 的这种作用的支持度都很好。只有 ie6 有些 bug

```cpp
p{
      color:red !important;
      color:blue;    
 }//会显示 blue
```

但是这并不说明 ie6 不支持 important，只是支持上有些 bug。看下面

```cpp
p{
     color:red !important;  
}
p{
    color:blue;  
} //这样就会显示的是 red。说明 ie6 还是支持 important 的。</pre>
```

#### 10.7 盒子塌陷是什么？

**参考答案：**

**盒子塌陷**

本应该在父盒子内部的元素跑到了外部。

**关于盒子塌陷的几种解决方法**

（1）最简单，直接，粗暴的方法就是盒子大小写死，给每个盒子设**定固定的 width 和 height**，直到合适为止，这样的好处是简单方便，兼容性好，适合只改动少量内容不涉及盒子排布的版面。缺点是非自适应，浏览器的窗口大小直接影响用户体验。

（2）给外部的父盒子也添加浮动，让其也脱离标准文档流，这种方法方便，但是对页面的布局不是很友好，不易维护。

（3）给父盒子添加 overflow 属性。

​ overflow:auto; 有可能出现滚动条，影响美观。

​ overflow:hidden; 可能会带来内容不可见的问题。

（4）父盒子里最下方引入清除浮动块。最简单的有：

```cpp
    <br style="clear:both;"/>
```

有很多人是这么解决的，但是我们并不推荐，因为其引入了不必要的冗余元素 。

​ (5)用 after 伪元素清除浮动

给外部盒子的 after 伪元素设置 clear 属性，再隐藏它

这其实是对空盒子方案的改进，一种纯 CSS 的解决方案，不用引入冗余元素。

```cpp
.clearfix {*zoom: 1;}

.clearfix:before,.clearfix:after {

display: table;

line-height: 0;

content: "";

}

.clearfix:after {clear: both;}
```

这也是 bootstrap 框架采用的清除浮动的方法。

这是一种纯 CSS 的解决浮动造成盒子塌陷方法，没有引入任何冗余元素，推荐使用此方法来解决 CSS 盒子塌陷。

备注：第五种方法虽好，但是低版本 IE 不兼容，具体选择哪种解决方法，可根据实际情况决定。

(6) 给父盒子添加 border

(7) 给父盒子设置 padding-top

#### 10.8 为什么会出现盒子塌陷？

**参考答案**：

当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文档流），尤其是当父元素的高度为 auto 时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度就会直接塌陷为零， 我们称这是**CSS 高度塌陷**。

#### 10.9 css 伪类与伪元素区别

**参考答案**：

1.  伪类(pseudo-classes)

*   其核⼼就是⽤来选择 DOM 树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。
*   ⽐如:hover :active :visited :link :visited :first-child :focus :lang 等
*   由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式。
*   由此可以看出，它的功能和 class 有些类似，但它是基于⽂档之外的抽象，所以叫 伪类。

2.  伪元素(Pseudo-elements)

*   DOM 树没有定义的虚拟元素
*   核⼼就是需要创建通常不存在于⽂档中的元素，
*   ⽐如::before ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容。
*   伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器

3.  伪类与伪元素的区别

*   表示⽅法
    *   CSS2 中伪类、伪元素都是以单冒号:表示,
    *   CSS2.1 后规定伪类⽤单冒号表示,伪元素⽤双冒号::表示，
    *   浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first�line, :first-letter 等)的单冒号写法。
    *   CSS2 之后所有新增的伪元素(如::selection)，应该采⽤双冒号的写法。
    *   CSS3 中，伪类与伪元素在语法上也有所区别，伪元素修改为以::开头。浏览器对以:开头的伪元素也继续⽀持，但建议规范书写为::开头
*   定义不同
    *   伪类即假的类，可以添加类来达到效果
    *   伪元素即假元素，需要通过添加元素才能达到效果
*   总结:
    *   伪类和伪元素都是⽤来表示⽂档树以外的"元素"。
    *   伪类和伪元素分别⽤单冒号:和双冒号::来表示。
    *   伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)，
    *   是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类
    *   伪类和伪元素都不出现在源⽂件和 DOM 树中。也就是说在 html 源⽂件中是看不到伪类和伪元素的。
    *   伪类其实就是基于普通 DOM 元素⽽产⽣的不同状态，他是 DOM 元素的某⼀特征。
    *   伪元素能够创建在 DOM 树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。

#### 10.10 行内元素的 margin 和 padding

**参考答案：**

*   水平方向：水平方向上，都有效；
*   垂直方向：垂直方向上，都无效；（`padding-top` 和 `padding-bottom` 会显示出效果，但是高度不会撑开，不会对周围元素有影响）

#### 10.11 min-width/max-width 和 min-height/max-height 属性间的覆盖规则？

**参考答案**：

1.  max-width 会覆盖 width，即使 width 是行内样式或者设置了 !important。
2.  min-width 会覆盖 max-width，此规则发生在 min-width 和 max-width 冲突的时候；

#### 10.12 浏览器是怎样解析 CSS 选择器的？

**参考答案**：

CSS 选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点(叶子节点)，而从左向右的匹配规则的性能都浪费在了失败的查找上面。而在 CSS 解析完毕后,需要将解析的结果与 DOM Tree 的内容-起进行分析建立-棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时(WebKit 中的「Attachment」过程)， 浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果(Style Rules)来确定生成怎样的 Render Tree。