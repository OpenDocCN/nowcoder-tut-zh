# 第六章 第 11 节 前端进阶-网络传输 4

> 原文：[`www.nowcoder.com/tutorial/10072/a9d48068fbb24f2aa50378c48e6f8aa7`](https://www.nowcoder.com/tutorial/10072/a9d48068fbb24f2aa50378c48e6f8aa7)

#### 5.15 https 加密解密流程

**参考答案**：

https 加密解密流程分成以下 8 个步骤：

1.  **客户端发起`HTTPS`请求** 这个没什么好说的，就是用户在浏览器里输入一个`HTTPS`网址，然后连接到服务端的 443 端口。

2.  **服务端的配置** 采用`HTTPS`协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。如果对公钥不太理解，可以想象成一把钥匙和一个锁头，只是世界上只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

3.  **传送证书** 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。

4.  **客户端解析证书** 这部分工作是由客户端的 SSL/TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题。如果证书没有问题，那么就生成一个**随机值**。然后用证书（也就是公钥）对这个随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

5.  **传送加密信息** 这部分传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

6.  **服务端解密信息** 服务端用私钥解密后，得到了客户端传过来的随机值，然后把内容通过该随机值进行对称加密，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

7.  **传输加密后的信息** 这部分信息就是服务端用私钥加密后的信息，可以在客户端用随机值解密还原。

8.  **客户端解密信息** 客户端用之前生产的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。

#### 5.16 TCP vs UDP

**参考答案**：

**TCP(传输控制协议)和 UDP（用户数据报协议）**

*   TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，是专门为了在不可靠的网络中提供一个可靠的端对端字节流而设计的，面向字节流。
*   UDP（用户数据报协议）是 iso 参考模型中一种无连接的传输层协议，提供简单不可靠的非连接传输层服务，面向报文

**区别：**

1.  TCP 是面向连接的，可靠性高；UDP 是基于非连接的，可靠性低
2.  由于 TCP 是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差，同时过程复杂，也使其易于攻击；UDP 没有建立连接的过程，因而实时性较强，也稍安全
3.  在传输相同大小的数据时，TCP 首部开销 20 字节；UDP 首部开销 8 字节，TCP 报头比 UDP 复杂，故实际包含的用户数据较少。TCP 在 IP 协议的基础上添加了序号机制、确认机制、超时重传机制等，保证了传输的可靠性，不会出现丢包或乱序，而 UDP 有丢包，故 TCP 开销大，UDP 开销较小
4.  每条 TCP 连接只能时点到点的；UDP 支持一对一、一对多、多对一、多对多的交互通信

**应用场景选择**

*   对实时性要求高和高速传输的场合下使用 UDP;在可靠性要求低，追求效率的情况下使用 UDP;
*   需要传输大量数据且对可靠性要求高的情况下使用 TCP

#### 5.17 FTP DNS 基于什么协议

**参考答案**：

DNS (Domain Name Service 域名服务) 协议基于 UDP 协议

FTP (File Transfer Protocol 文件传输协议) 基于 TCP 协议

DNS 和 FTP 都是应用层协议

#### 5.18 URL 路径包含什么, URI 是什么

**参考答案**：

**URL 路径包含什么**

一个完整的 url 分为 4 部分：

1.  协议 例 Http（超文本传输协议） 、Https、
2.  域名 例[www.baidu.com](https://link.jianshu.com?t=http://www.baidu.com)为网站名字。 [baidu.com](https://link.jianshu.com?t=http://baidu.com)为一级域名，www 是服务
3.  端口 不填写的话默认走的是 80 端口号
4.  路径 [`www.baidu.com/`](https://link.jianshu.com?t=http://www.baidu.com/)路径 1/路径 1.2。/表示根目录
5.  查询参数 [`www.baidu.com/`](https://link.jianshu.com?t=http://www.baidu.com/)路径 1/路径 1.2?name="man"(可有可无)

**URI 是什么**

**URI**是一个用于标识互联网资源名称的字符串。 该种标识允许用户对网络中（一般指[万维网](https://link.jianshu.com?t=https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91)）的资源通过特定的协议进行交互操作。URI 的最常见的形式是统一资源定位符（URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（URN），其目的是通过提供一种途径。用于在特定的命名空间资源的标识，以补充网址。

**扩展**：

URL 和 URN 是 URI 的子集，URI 属于 URL 更高层次的抽象，一种字符串文本标准。

#### 5.19 代码题：url GET 参数写代码获取

**参考答案**：

方法一：采用正则表达式获取地址栏参数 (代码简洁，重点正则）

```cpp
function getQueryString(name) {
    let reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");// 正则语句
    let r = window.location.search.substr(1).match(reg);// 获取 url 的参数部分，用正则匹配
    if (r != null) {
        return decodeURIComponent(r[2]); // 解码得到的参数
    };
    return null;
 }
```

方法二：split 拆分法 (代码较复杂，较易理解)

```cpp
function GetRequest() {
   const url = location.search; //获取 url 中"?"符后的字串
   let theRequest = new Object();
   if (url.indexOf("?") != -1) { // 判断是否是正确的参数部分
      let str = url.substr(1); // 截取参数部分
      strs = str.split("&");  // 以‘&’为分割符获取参数数组
      for(let i = 0; i < strs.length; i ++) {
         theRequest[strs[i].split("=")[0]]=unescape(strs[i].split("=")[1]);
      }
   }
   return theRequest;
}
```

方法三：split 拆分法(易于理解，代码中规)

```cpp
function getQueryVariable(variable){
       let query = window.location.search.substring(1); // 获取 url 的参数部分
       let vars = query.split("&"); // 以‘&’为分割符获取参数数组
       for (let i=0;i<vars.length;i++) { // 遍历数组获取参数
               let pair = vars[i].split("=");
               if(pair[0] == variable){return pair[1];}
       }
       return(false);
}
```

#### 5.20 301 和 302 的含义

**参考答案**：

301 和 302 都是重定向的状态码，重定向（Redirect）是指通过各种方法将客户端的网络请求重新定义或指定一个新方向转到其他位置（重定向包括网页重定向、域名重定向）。

301 redirect: 301 代表永久性转移(Permanently Moved)

302 redirect: 302 代表暂时性转移(Temporarily Moved )

**相同点：**都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的 URL 地址，这个地址可以从响应的 Location 首部中获取（用户看到的效果就是他输入的地址 A 瞬间变成了另一个地址 B）

**不同点：**

1.  301 表示旧地址 A 的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；

    302 表示旧地址 A 的资源还在（仍然可以访问），这个重定向只是临时地从旧地址 A 跳转到地址 B，搜索引擎会抓取新的内容而保存旧的网址。

2.  302 会出现“网址劫持”现象，从 A 网址 302 重定向到 B 网址，由于部分搜索引擎无法总是抓取到目标网址，或者 B 网址对用户展示不够友好，因此浏览器会仍旧显示 A 网址，但是所用的网页内容却是 B 网址上的内容。

**应用场景**

301：域名需要切换、协议从 http 变成 https；

302：未登录时访问已登录页时跳转到登录页面、404 后跳转首页