# 第三章 第 2 节 常见面试题解析

> 原文：[`www.nowcoder.com/tutorial/10077/60201f7c473a4369aaff31780005db5b`](https://www.nowcoder.com/tutorial/10077/60201f7c473a4369aaff31780005db5b)

## 2.2 面试常见问题及解析

### 2.2.1 请详细叙述类加载的过程

问题剖析：当面试官提出这个问题时，主要想考察你对类加载主要流程的理解。回答这个问题不能仅背诵类加载主要几个流程，要结合自己的思考驾驭叙述。例如，JVM 这么设计的目的是什么？每一步做的事情是否具有关联性？如果中间少了哪些步骤会有什么影响？此外，类加载必然会涉及到 JVM 内存区域中的相关内容，可以将前一章中的内容加以联系，摆脱背诵。

回答模板：首先回答类加载存在的意义，如果没有类加载会怎样？和其他语言的类加载也可以进行对比；其次交代类加载发生的时机，即哪些场景会触发类加载；随后对类加载的各个步骤进行详细叙述，并结合内存模型、Class 文件结构以及线程安全等角度展开分析；最后进行收尾，交代类加载过程从理论层进行描述，引出下面对类加载器实现理解这一问题。

### 2.2.2 请谈谈你对类加载器的理解

问题剖析：当面试官提出这个问题时，主要希望你能对类加载的具体实现有所了解。回答这个问题不要直接抛出双亲委派模型作为答案，要从多角度分析。例如，类加载器应该如何设计？JVM 如何实现类加载器？类加载器有几种？类加载有缺陷么？可以实现自定义类加载器么？

回答模板：首先对类加载器进行叙述，交代其存在的意义，介绍其余类加载过程的关系；其次对类加载的分类进行叙述，期间可以加入一些自己实践自定义类加载器的经历；随后引出双亲委派模型，把加载的委派关系和实际加载顺序进行叙述；随后进一步阐述双亲委派模型，描述如果不使用双亲委派模型会有怎样的副作用；随后对双亲委派模型的缺陷进行阐述，并引出 Java 模块化系统下的类加载器；最后进行总结性收尾。

### 2.2.3 请谈谈你对对象初始化和类初始化区别的理解

问题剖析：当面试官提出这个问题时，主要考察你对上述两个过程的理解是否透彻，因为很多人往往将这两个过程混为一谈。这两个过程发生的时机不同，可以对比二者各自的初始化过程进行分析。

回答模板：首先从二者发生的时机进行对比分析(什么时候初始化类？什么时候初始化对象？)；其次结合内存模型展开分析，对类和对象初始化的目标及其位置进行区分，结合上文中的一些代码和特殊情况(final static)进行叙述；随后对<clinit>()和<init>()展开分析，并从块、静态块、构造函数等角度进行区分；随后从线程安全性的角度对二者进行描述；最后做总结性收尾。</init></clinit>

补充：与对象初始化相关的内容，存在一个很经典问题。请谈谈你对 new 一个对象全过程的理解。这部分内容将在对象实例化章节进行详细叙述，并请大家在学习 Java 的时候不断反问自己这个问题。

### 2.2.4 类加载的初始化过程是线程安全么？

问题剖析：当面试官提出这个问题时，主要考察你对类初始化的细节是否掌握。回答这个问题往往需要理论结合实践，只有通过代码验证后回答时才会更有底气。

回答模板：首先给出结论；其次从理论角度给出分析；随后结合例子进行叙述；最后做总结性收尾。

代码实践：JVM 必须保证类的<clinit>()在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，有且仅有一个线程可执行<clinit>()，其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()。如果在类的<clinit>()中有耗时操作，那就可能造成阻塞，例如如下代码：</clinit></clinit></clinit></clinit>

```cpp
public class Data {
    static class DeadLoopClass {
        static {
             if (true) {
                 System.out.println(Thread.currentThread() + "init DeadLoopClass");
                 while (true) {

                 }
             }
        }
    }
    public static void main(String[] args) {
        Runnable script = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread() + "start");
                DeadLoopClass dlc = new DeadLoopClass();
                System.out.println(Thread.currentThread() + " run over");
            }
        };
        Thread thread1 = new Thread(script);
        Thread thread2 = new Thread(script);
        thread1.start(); 
        thread2.start();
    }
}
```

执行后可发现只有一个线程可以打印出**init DeadLoopClass**，而另一个线程则无法打印。