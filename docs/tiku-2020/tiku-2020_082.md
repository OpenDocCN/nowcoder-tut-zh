# 哔哩哔哩 2020 校园招聘游戏开发笔试卷（一）

## 1

在类的定义中可以有两个同名函数，这种现象称为函数（）

正确答案: D   你的答案: 空 (错误)

```cpp
封装
```

```cpp
继承
```

```cpp
覆盖
```

```cpp
重载
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

## 2

在类的定义中构造函数的作用是（）

正确答案: D   你的答案: 空 (错误)

```cpp
保护成员变量
```

```cpp
读取类的成员变量
```

```cpp
描述类的特征
```

```cpp
初始化成员变量
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[牛客 901124429 号](https://www.nowcoder.com/profile/901124429)

D

发表于 2021-05-13 21:28:44

* * *

## 3

下面关键字中，哪一个不是用于异常处理语句（）

正确答案: B   你的答案: 空 (错误)

```cpp
try
```

```cpp
break
```

```cpp
catch
```

```cpp
finally
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[牛客 108050723 号](https://www.nowcoder.com/profile/108050723)

B

发表于 2021-06-12 22:53:50

* * *

## 4

c#中，关于抽象方法的说法正确的是()

正确答案: C   你的答案: 空 (错误)

```cpp
可以有方法体
```

```cpp
可以出现在非抽象类中
```

```cpp
是没有方法体的方法
```

```cpp
抽象类中的方法都是抽象方法
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[红烧茄子丶](https://www.nowcoder.com/profile/720928929)

抽象类不是可以有普通方法吗？难道我学的是假的 c#？

发表于 2020-03-09 02:33:47

* * *

[新晋程序员](https://www.nowcoder.com/profile/514650075)

这里说的不是抽象方法吗

发表于 2021-01-26 14:15:41

* * *

[CrabEVRCE](https://www.nowcoder.com/profile/285746045)

怎么回事，抽象方法 就是没有方法体啊，我都试了，编译器都报错了

发表于 2020-08-22 11:41:23

* * *

## 5

若有定义：byte[] x={11,22,33,-66}，则对 x 数组元素错误的引用是（）（其中 0≤k≤3）

正确答案: C   你的答案: 空 (错误)

```cpp
x[5-3]
```

```cpp
x[k]
```

```cpp
x[k+5]
```

```cpp
x[0]
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

## 6

以下有关构造方法的说法，正确的是：（）

正确答案: A   你的答案: 空 (错误)

```cpp
一个类的构造方法可以有多个
```

```cpp
构造方法在类定义时被调用
```

```cpp
构造方法只能由对象中的其它方法调用。
```

```cpp
构造方法可以和类同名，也可以和类名不同
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

## 7

关于对象成员占用内存的说法正确的是（）

正确答案: B   你的答案: 空 (错误)

```cpp
同一个类的对象共用同一段内存
```

```cpp
同一个类的对象使用不同的内存段，但静态成员共享相同的内存空间
```

```cpp
对象的方法不占用内存
```

```cpp
其他选项都不对
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[Wayne_Tao](https://www.nowcoder.com/profile/511150377)

在类中，静态成员变量不占用类的内存空间，也就是一个类假设有一个 int 和一个 static int，这个类的对象的大小是 4。这样就可以理解了，静态成员是独立于这些对象的存在，自己一直占用一部分空间。不知道理解的对不对

发表于 2021-01-08 20:06:45

* * *

## 8

异常包含下列哪些内容（）

正确答案: A   你的答案: 空 (错误)

```cpp
程序执行过程中遇到的事先没有预料到的情况
```

```cpp
程序中的语法错误
```

```cpp
程序的编译错误
```

```cpp
其他选项都是
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[牛客 902711271 号](https://www.nowcoder.com/profile/902711271)

我还以为程序的语法错误和编译错误也算异常呢，结果不是。异常就是指程序执行过程中遇到的事先没有预料到的情况

发表于 2021-03-19 21:31:17

* * *

## 9

void 的含义是（）

正确答案: A   你的答案: 空 (错误)

```cpp
方法没有返回值
```

```cpp
方法体为空
```

```cpp
没有意义
```

```cpp
定义方法时必须使用
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

## 10

关于选择结构下列说法正确的是（）

正确答案: A   你的答案: 空 (错误)

```cpp
if 语句可以没有 else 语句对应
```

```cpp
switch 结构中每个 case 语句中必须用 break 语句
```

```cpp
switch 结构中必须有 default 语句
```

```cpp
其他选项都不对
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[星暮迟迟夜未央](https://www.nowcoder.com/profile/330161069)

这道题不严谨，有些语言就是必须有 default 语句

发表于 2021-03-10 15:57:50

* * *

## 11

关于继承的说法正确的是（）

正确答案: B   你的答案: 空 (错误)

```cpp
子类将继承父类所有的属性和方法。
```

```cpp
子类将继承父类的非私有属性和方法。
```

```cpp
子类只继承父类 public 方法和属性
```

```cpp
子类只继承父类的方法，而不继承属性
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[好吧，昵称真难改](https://www.nowcoder.com/profile/3381363)

这个我不是很理解啊大佬们，不是所有的东西都会继承吗？知识不能显式的访问罢了？？

发表于 2019-11-27 17:02:46

* * *

## 12

下列哪一种是编译型语言（）

正确答案: C   你的答案: 空 (错误)

```cpp
PHP
```

```cpp
Java
```

```cpp
Go
```

```cpp
Python
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[不进育碧不改名](https://www.nowcoder.com/profile/531181190)

1、编译型语言

需通过编译器（compiler）将源代码编译成机器码，之后才能执行的语言。一般需经过编译（compile）、链接（linker）这两个步骤。编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。

优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。

缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。

代表语言：C、C++、Pascal、Object-C 以及最近很火的苹果新语言 swift

2、解释型语言

解释性语言的程序不需要编译，相比编译型语言省了道工序，解释性语言在运行程序的时候才逐行翻译。

优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。

缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。

代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby

3、混合型语言

既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。比如 C#,C#在编译的时候不是直接编译成机器码而是中间码，.NET 平台提供了中间语言运行库运行中间码，中间语言运行库类似于 Java 虚拟机。.net 在编译成 IL 代码后，保存在 dll 中，首次运行时由 JIT 在编译成机器码缓存在内存中，下次直接执行。

Java 先生成字节码再在 Java 虚拟机中解释执行。

严格来说混合型语言属于解释型语言。C#更接近编译型语言。

发表于 2020-07-30 10:01:53

* * *

## 13

下列说法正确的是（）

正确答案: C   你的答案: 空 (错误)

```cpp
不需要定义类，就能创建对象
```

```cpp
对象中必须有属性和方法
```

```cpp
属性可以是简单变量，也可以是一个对象
```

```cpp
属性必须是简单变量
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

## 14

每个 Unicode 码占用（）个比特位

正确答案: B   你的答案: 空 (错误)

```cpp
8
```

```cpp
16
```

```cpp
32
```

```cpp
64
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[kice](https://www.nowcoder.com/profile/598267062)

我只能认为这个特指 Windows/微软文档下的 “Unicode”, 也就是 UCS-2（单字节的 UTF-16）。Unicode 是一套文字编码规范(encoding standard)，而不是编码格式(encoding format)。编码格式解码之后的值就是 Unicode。目前来说，Unicode 只定义到了 0x10FFFF，然后讨论 Unicode 的内存占用是没有特殊意义。这个问题就是在问：表示实数(Unicode)需要多少个数字(比特位)来表示？应该问：十进制（单字节的 UTF-16）需要多少个数字(比特位)来表示？ref: [`en.wikipedia.org/wiki/Unicode`](https://en.wikipedia.org/wiki/Unicode)[`en.wikipedia.org/wiki/UTF-16`](https://en.wikipedia.org/wiki/UTF-16) [`en.wikipedia.org/wiki/Universal_Coded_Character_Set`](https://en.wikipedia.org/wiki/Universal_Coded_Character_Set) [`docs.microsoft.com/en-us/windows/win32/intl/unicode`](https://docs.microsoft.com/en-us/windows/win32/intl/unicode)

发表于 2020-08-20 05:55:14

* * *

## 15

C++调用函数时，如果实参是简单变量，它与形参之间的数据传递方式是

正确答案: B   你的答案: 空 (错误)

```cpp
地址传递
```

```cpp
单向值传递
```

```cpp
由实参传给形参，再由形参传回实参
```

```cpp
传递方式由用户指定
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[牛客 129140386 号](https://www.nowcoder.com/profile/129140386)

如果形参为引用的话不就相当于地址传递吗，感觉莫能两可的题好多

发表于 2020-08-13 19:25:59

* * *

[牛客 303151548 号](https://www.nowcoder.com/profile/303151548)

转发：个人认为：这里的简单变量应该是指内置类型，内置类型数据在传入函数时，使用值传递方式的效率要高于引用传递和指针传递，因此编译器会采用效率最高的方式来实现参数传递，所以选 B（当然也允许用户更改），事实上包括 STL 中的迭代器和函数对象也都是默认采用值传递的方式来实现的。至于其他类型如自定义类，如果采用值传递则会涉及拷贝构造函数和析构函数的调用问题，通常会影响性能，所以一般采用引用和指针传递的形式，通常交由用户决定。
一点题外话：有人说设计自定义类型的最高境界是让他无限接近内置类型，不无道理。
————————————————
版权声明：本文为 CSDN 博主「cubedong」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：[`blog.csdn.net/sinat_42550851/article/details/99826737`](https://blog.csdn.net/sinat_42550851/article/details/99826737)

发表于 2021-05-24 17:25:42

* * *

## 16

设在存储器中、用于存放调用程序的现场及参数的存储区是（）

正确答案: A   你的答案: 空 (错误)

```cpp
堆栈
```

```cpp
缓冲区
```

```cpp
数据区
```

```cpp
程序区
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

## 17

在用射线法进行点与多边形之间的包含性检测时,下述操作不正确的是()

正确答案: D   你的答案: 空 (错误)

```cpp
当射线与多边形交于某顶点时且该点的两个邻边在射线的一侧时,计数 0 次
```

```cpp
当射线与多边形交于某顶点时且该点的两个邻边在射线的一侧时,计数 2 次
```

```cpp
当射线与多边形交于某顶点时且该点的两个邻边在射线的两侧时,计数 1 次
```

```cpp
当射线与多边形的某边重合时,计数 1 次
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[末夜の十字♪](https://www.nowcoder.com/profile/861637875)

射线法用来检测点是否在一个多边形内，就是点向任意一个方向做射线，假如有奇数个交点，说明点在多边形内，但如果射线和多边形的顶点或边相交，就需要上面的选项了

发表于 2020-03-28 06:29:45

* * *

## 18

双线性法向插值法（Phong Shading）的优点是（）

正确答案: B   你的答案: 空 (错误)

```cpp
法向计算精确
```

```cpp
高光域准确
```

```cpp
对光源和视点没有限制
```

```cpp
速度较快
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[洗了青菜忘了烧](https://www.nowcoder.com/profile/545478649)

Phong Shading 不是冯氏光照模型吗 和双线性法向插值法有关系吗

发表于 2020-03-05 14:48:43

* * *

[頑張猿](https://www.nowcoder.com/profile/691337419)

分享一些个人理解 Phong Shading 指的是逐像素着色频率，应该与 Blinn-Phong 光照模型区分开。着色频率按精度由低到高可以分为逐三角形着色(Flat Shading)、逐顶点着色(Gouraud Shading)、逐像素着色(Phong Shading)。逐三角形着色使用当前三角形法线进行着色，逐顶点着色可以以相邻三角形的面积作为权重，对各个相邻三角形法线加权求平均作为顶点法线，计算顶点颜色值，最后在三角形内每个位置对三个顶点的颜色值插值。（顶点用来插值计算三角形内各个位置的颜色值）逐像素着色在计算完每个顶点的法线后，在三角形内插值计算每个位置的法线方向(可以使用重心坐标)，然后每个像素使用自己的法线计算着色。（顶点用来插值计算三角形内各个位置的法线方向）题目的意思可能是假设对一个四边形进行着色，并且使用双线性插值也就是 Phong Shading 的话，有哪些优点。个人认为法线计算确实更加精准了，高光域更准确也是因为法线计算更准确了，所以感觉应该选 AB......

发表于 2021-10-11 16:44:22

* * *

[祭奠夕阳](https://www.nowcoder.com/profile/3925558)

有一说一，Phong 高光域准确为啥还用 Blinn Phong 啊。Phong 模型计算量在一众 PBR 光照模型里面算速度快的吧。为啥是 B 呢，有大佬解释解释？

发表于 2020-07-20 21:10:20

* * *

## 19

在物体的定义中对边的限制不存在（）

正确答案: C   你的答案: 空 (错误)

```cpp
边的长度可度量且是有限的
```

```cpp
一条边有且只有两个相邻的面
```

```cpp
一条边有且只有两个端点
```

```cpp
如果一条边是曲线,那么在两个端点之间不允许曲线自相交
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[星暮迟迟夜未央](https://www.nowcoder.com/profile/330161069)

忘了圆形没有端点了。。。但是 B 我觉得也有问题，例如平面图形，边只有一个面与之相邻

发表于 2021-03-10 15:59:51

* * *

## 20

使用 SQL 命令将学生表 STUDENT 中的学生年龄 AGE 字段的值增加 1 岁，应该使用的命令是（）

正确答案: C   你的答案: 空 (错误)

```cpp
UPDATE SET AGE WITH AGE＋1
```

```cpp
REPLACE AGE WITH AGE＋1
```

```cpp
UPDATE STUDENT SET AGE＝AGE＋1
```

```cpp
UPDATE STUDENT AGE WITH AGE＋1
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[zhenchaochaochao](https://www.nowcoder.com/profile/779483920)

 The syntax of update:UPDATE  table_nameSET  column1= value1, column2=value2,WHERE condition;

发表于 2019-11-25 06:03:16

* * *

## 21

能实现绝对的与平台无关性的 Web 数据库访问技术是（）

正确答案: D   你的答案: 空 (错误)

```cpp
ADO
```

```cpp
ActiveX
```

```cpp
WebbaseAPI
```

```cpp
JDBC
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

## 22

下列四组 SQL 命令，全部属于数据定义语句的命令是（）

正确答案: A   你的答案: 空 (错误)

```cpp
CREATE，DROP，ALTER
```

```cpp
CREATE，DROP，UPDATE
```

```cpp
CREATE，DROP，GRANT
```

```cpp
CREATE，DROP，SELECT
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[普罗米玉魂](https://www.nowcoder.com/profile/620994190)

ALTER 是添加列，意思应该是要重新定义一个数据列，所以说是数据定义应该没错吧？grant 是授权指令，和数据定义有什么关系呢。

编辑于 2020-11-05 19:34:01

* * *

[牛客 902711271 号](https://www.nowcoder.com/profile/902711271)

这题我觉得答案有问题，题中所提到的数据定义语句，就应该是 CREATE，DROP，GRANT 啊

发表于 2021-03-19 21:34:52

* * *

[_ 向 offer 冲锋-](https://www.nowcoder.com/profile/227731021)

我就觉得我做的没有错啊

发表于 2020-02-23 09:58:32

* * *

## 23

TCP 三次握手方法用于（）

正确答案: A   你的答案: 空 (错误)

```cpp
传输层连接的建立
```

```cpp
数据链路层的流量控制
```

```cpp
传输层的重复检测
```

```cpp
传输层的流量控制
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

## 24

与 10.110.12.29 mask 255.255.255.224 同网段的主机 IP 地址是（）

正确答案: B   你的答案: 空 (错误)

```cpp
10.110.12.0
```

```cpp
10.110.12.30
```

```cpp
10.110.12.31
```

```cpp
10.110.12.32
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[长胖 10 斤换一个 offer](https://www.nowcoder.com/profile/3359549)

IP 和子网掩码做与运算，就可以得到该网段的第一个 ip29 的二进制为 0001 1101 和 244 做与运算 1110 0000 得到 0000 0000，所以这个网段的第一个 ip 是 10.110.12.1  （要+1）该 ip 地址的网络部分不变，主机地址全部置为 1 得到 111 1 1111  因为网络地址占了 3 位，所以这里得到的结果为 31   31-1 = 30

发表于 2020-03-22 23:23:59

* * *

[ANNGH](https://www.nowcoder.com/profile/547878357)

224=128+64+32，因此子网掩码为 1110 0000；所以主机号范围在 0 0000-1 1111，也就是 0-31 之间，但主机号不能全为 0 或全为 1，因此主机号范围实际是 1-30 之间.又，10.110.12.29 网络号为 10.110.12，子网号为 0；  所以同网络的 ip 地址在 10.110.12.0-10.110.12.30 之间

发表于 2020-09-05 10:35:08

* * *

[洲 201906171715829](https://www.nowcoder.com/profile/33430921)

子网 ip 不能全为 0 或全为 1，31 不符合，应该是这样吧

发表于 2020-05-06 13:22:55

* * *

## 25

下列说法正确的是（）

正确答案: C   你的答案: 空 (错误)

```cpp
不需要定义类，就能创建
```

```cpp
对象中必须有属性和方法
```

```cpp
属性可以是简单变量，也可以是一个对象
```

```cpp
属性必须是简单变量
```

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[牛客 52635984 号](https://www.nowcoder.com/profile/52635984)

C

发表于 2019-12-07 11:33:17

* * *

## 26

请为某集换式卡牌游戏（类似于万智牌或炉石传说）设计一个公平的抽卡算法，让每一张卡牌都能独立等概率的出现在每一个位置。（用语言描述或伪代码都可以）

你的答案

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[不吃鱼！](https://www.nowcoder.com/profile/707324090)

可使用 Knuth 洗牌算法

发表于 2020-04-13 11:42:53

* * *

## 27

全宇宙魔法少女大聚会（数量较多），如果魔法少女 A 和魔法少女 B 存在羁绊，魔法少女 B 和魔法少女 C 存在羁绊，那么魔法少女 A 和魔法少女 C 也存在羁绊；所有有羁绊关系的魔法少女形成一个结界，请计算有多少个结界并计算各个结界中的人数。（用语言描述或伪代码都可以）

你的答案

本题知识点

游戏研发工程师 哔哩哔哩 2020

讨论

[好吧，昵称真难改](https://www.nowcoder.com/profile/3381363)

并查集问题，使用带权并查集合并即可

发表于 2019-11-27 17:05:43

* * *

[牛客 602359375 号](https://www.nowcoder.com/profile/602359375)

public List<int> GetJieJie(bool[][] magic) // magic 交错数组是一个 n*n 的数组, 描述魔法少女之间的关系, 第一个索引 x 表示第 x 个魔法少女,第二个索引 y 表示这一个魔法少女和第 y 个魔法少女的关系, true 为存在羁绊, false 为不存在羁绊, 如 magic[0][2] = true 表示第零个魔法少女和第二个魔法少女存在羁绊//结果 List 长度为结界数,List 中每个元素表示各各结界的人数{    List<int> ans = new List<int>();
    for(int i = 0;i<magic.Length;i++){        if(magic[i][i] = false)  //magic[i][i] 表示第 i 个魔法少女和她自己的羁绊, 其在初始时一定为 true, 用它来做标记确定这一魔法少女是否被检查过羁绊              continue;         List<int> JieJie =  new List<int>();        JieJie.Add(i);        //BFS
        for(int j = 0; j< JieJIe.Count;j++){
            magic[JieJie[j]][JieJie[j]] = false;
            for(int k = 0; k<magic.Length;k++){                if(magic[JieJie[j]][k] = true){                    if(!JieJie.Contains(k))
                        JieJie.Add(k);                }
            }
        }
        ans.Add(JieJie.Count);    }
    return ans;
}时间复杂度 O(n²) 空间复杂度 O(n)

发表于 2021-09-12 13:34:36

* * *

[Wayne_Tao](https://www.nowcoder.com/profile/511150377)

总体思路：利用拓扑的思路进行拆除，利用递归的方法进行实现。魔法少女用图表示；（关系网小就用稀疏矩阵，具体考虑的数量较多，尽量节约存储吧）
结界结果用 vector 类型保存，count，每次 pushback 的初始值为 0。
随机抽取一名魔法少女作为当前节点，count[0]自加一；从图中删除节点，并把当前节点的 n 个节点中的 n-1 个节点连接到第一个节点上，且把第一个节点作为当前节点，开始重复 count[0]自加一的操作；以此类推，直到没有下一个节点为止；再随机抽取一名作为当前节点，count[1]自加一，直到没有下一个节点；直到图中没有节点；最终结界数量是 count.size()，各个结界的人数分别是 count 对应位置的值；【但是感觉复杂度好高。。。】

发表于 2021-01-08 19:57:37

* * *