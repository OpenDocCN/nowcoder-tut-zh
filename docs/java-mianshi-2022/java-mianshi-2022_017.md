# 第二章 第 2 节 Java 数据库-2

> 原文：[`www.nowcoder.com/tutorial/10070/cd98a0d4c5ba4c64b27363b7b464d306`](https://www.nowcoder.com/tutorial/10070/cd98a0d4c5ba4c64b27363b7b464d306)

#### 1.7 谈谈你对 SQL 注入的理解

**参考答案**

SQL 注入的原理是将 SQL 代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，在一些对 SERVER 端发起的请求参数中植入一些 SQL 代码，SERVER 端在执行 SQL 操作时，会拼接对应参数，同时也将一些 SQL 注入攻击的“SQL”拼接起来，导致会执行一些预期之外的操作。

举个例子：

比如我们的登录功能，其登录界面包括用户名和密码输入框以及提交按钮，登录时需要输入用户名和密码，然后提交。此时调用接口/user/login/ 加上参数 username、password，首先连接数据库，然后后台对请求参数中携带的用户名、密码进行参数校验，即 SQL 的查询过程。假设正确的用户名和密码为 ls 和 123456，输入正确的用户名和密码、提交，相当于调用了以下的 SQL 语句。

```cpp
SELECT * FROM user WHERE username = 'ls' AND password = '123456'
```

SQL 中会将#及--以后的字符串当做注释处理，如果我们使用 `' or 1=1 #` 作为用户名参数，那么服务端构建的 SQL 语句就如下：

```cpp
select * from user where username='' or 1=1 #' and password='123456'
```

而#会忽略后面的语句，而 1=1 属于常等型条件，因此这个 SQL 将查询出所有的登录用户。其实上面的 SQL 注入只是在参数层面做了些手脚，如果是引入了一些功能性的 SQL 那就更危险了，比如上面的登录功能，如果用户名使用这个 `' or 1=1;delete * from users; #`，那么在";"之后相当于是另外一条新的 SQL，这个 SQL 是删除全表，是非常危险的操作，因此 SQL 注入这种还是需要特别注意的。

如何解决 SQL 注入

1.  严格的参数校验

    参数校验就没得说了，在一些不该有特殊字符的参数中提前进行特殊字符校验即可。

2.  SQL 预编译

    在知道了 SQL 注入的原理之后，我们同样也了解到 MySQL 有预编译的功能，指的是在服务器启动时，MySQL Client 把 SQL 语句的模板（变量采用占位符进行占位）发送给 MySQL 服务器，MySQL 服务器对 SQL 语句的模板进行编译，编译之后根据语句的优化分析对相应的索引进行优化，在最终绑定参数时把相应的参数传送给 MySQL 服务器，直接进行执行，节省了 SQL 查询时间，以及 MySQL 服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止 SQL 注入。

    具体是怎样防止 SQL 注入的呢？实际上当将绑定的参数传到 MySQL 服务器，MySQL 服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。我们常用的 JDBC 就有预编译功能，不仅提升性能，而且防止 SQL 注入。

#### 1.8 将一张表的部分数据更新到另一张表，该如何操作呢？

**参考答案**

可以采用关联更新的方式，将一张表的部分数据，更新到另一张表内。参考如下代码：

```cpp
update b set b.col=a.col from a,b where a.id=b.id;
update b set col=a.col from b inner join a on a.id=b.id;
update b set b.col=a.col from b left Join a on b.id = a.id;
```

#### 1.9 WHERE 和 HAVING 有什么区别？

**参考答案**

WHERE 是一个约束声明，使用 WHERE 约束来自数据库的数据，WHERE 是在结果返回之前起作用的，WHERE 中不能使用聚合函数。

HAVING 是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在 HAVING 中可以使用聚合函数。另一方面，HAVING 子句中不能使用除了分组字段和聚合函数之外的其他字段。

从性能的角度来说，HAVING 子句中如果使用了分组字段作为过滤条件，应该替换成 WHERE 子句。因为 WHERE 可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。

## 2\. 索引

#### 2.1 说一说你对 MySQL 索引的理解

**参考答案**

索引是一个单独的、存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针。使用索引可以快速找出在某个或多个列中有一特定值的行，所有 MySQL 列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。

索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。MySQL 中索引的存储类型有两种，即 BTREE 和 HASH，具体和表的存储引擎相关。MyISAM 和 InnoDB 存储引擎只支持 BTREE 索引；MEMORY/HEAP 存储引擎可以支持 HASH 和 BTREE 索引。

索引的优点主要有以下几条：

1.  通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。
2.  可以大大加快数据的查询速度，这也是创建索引的主要原因。
3.  在实现数据的参考完整性方面，可以加速表和表之间的连接。
4.  在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间。

增加索引也有许多不利的方面，主要表现在如下几个方面：

1.  创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。
2.  索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。
3.  当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。

#### 2.2 索引有哪几种？

**参考答案**

MySQL 的索引可以分为以下几类：

1.  普通索引和唯一索引

    普通索引是 MySQL 中的基本索引类型，允许在定义索引的列中插入重复值和空值。

    唯一索引要求索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

    主键索引是一种特殊的唯一索引，不允许有空值。

2.  单列索引和组合索引

    单列索引即一个索引只包含单个列，一个表可以有多个单列索引。

    组合索引是指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循最左前缀集合。

3.  全文索引

    全文索引类型为 FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在 CHAR、VARCHAR 或者 TEXT 类型的列上创建。MySQL 中只有 MyISAM 存储引擎支持全文索引。

4.  空间索引

    空间索引是对空间数据类型的字段建立的索引，MySQL 中的空间数据类型有 4 种，分别是 GEOMETRY、POINT、LINESTRING 和 POLYGON。MySQL 使用 SPATIAL 关键字进行扩展，使得能够用创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为 NOT NULL，空间索引只能在存储引擎为 MyISAM 的表中创建。

#### 2.3 如何创建及保存 MySQL 的索引？

**参考答案**

MySQL 支持多种方法在单个或多个列上创建索引：

在创建表的时候创建索引：

使用 CREATE TABLE 创建表时，除了可以定义列的数据类型，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。创建表时创建索引的基本语法如下：

```cpp
CREATE TABLE table_name [col_name data_type]
[UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name [length]) [ASC|DESC]
```

其中，UNIQUE、FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；INDEX 与 KEY 为同义词，两者作用相同，用来指定创建索引。

例如，可以按照如下方式，在 id 字段上使用 UNIQUE 关键字创建唯一索引：

```cpp
CREATE TABLE t1 (
    id INT NOT NULL,
    name CHAR(30) NOT NULL,
    UNIQUE INDEX UniqIdx(id)
);
```

在已存在的表上创建索引

在已经存在的表中创建索引，可以使用 ALTER TABLE 语句或者 CREATEINDEX 语句。

ALTER TABLE 创建索引的基本语法如下：

```cpp
ALTER TABLE table_name ADD 
[UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name[length],...) [ASC|DESC]
```

例如，可以按照如下方式，在 bookId 字段上建立名称为 UniqidIdx 的唯一索引：

```cpp
ALTER TABLE book ADD UNIQUE INDEX UniqidIdx (bookId);
```

CREATE INDEX 创建索引的基本语法如下：

```cpp
CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name 
ON table_name (col_name [length],...) [ASC|DESC]
```

例如，可以按照如下方式，在 bookId 字段上建立名称为 UniqidIdx 的唯一索引：

```cpp
CREATE UNIQUE INDEX UniqidIdx ON book (bookId);
```

#### 2.4 MySQL 怎么判断要不要加索引？

**参考答案**

建议按照如下的原则来创建索引：

1.  当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。
2.  在频繁进行排序或分组（即进行 group by 或 order by 操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。

#### 2.5 只要创建了索引，就一定会走索引吗？

**参考答案**

不一定。

比如，在使用组合索引的时候，如果没有遵从“最左前缀”的原则进行搜索，则索引是不起作用的。

举例，假设在 id、name、age 字段上已经成功建立了一个名为 MultiIdx 的组合索引。索引行中按 id、name、age 的顺序存放，索引可以搜索 id、（id,name）、（id, name, age）字段组合。如果列不构成索引最左面的前缀，那么 MySQL 不能使用局部索引，如（age）或者（name,age）组合则不能使用该索引查询。