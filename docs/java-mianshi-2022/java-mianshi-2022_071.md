# 第九章 第 1 节 Java-场景应用-1

> 原文：[`www.nowcoder.com/tutorial/10070/c2908db0e1ae46c99f66ae26bce3932d`](https://www.nowcoder.com/tutorial/10070/c2908db0e1ae46c99f66ae26bce3932d)

## 1\. 场景应用

#### 1.1 微信红包相关问题

**参考答案**

概况：2014 年微信红包使用数据库硬抗整个流量，2015 年使用 cache 抗流量。

微信的金额什么时候算？

微信红包的金额是拆的时候实时算出来，不是预先分配的，采用的是纯内存计算，不需要预算空间存储。采取实时计算金额的考虑，是因为实时效率很高，而预算需要占存储，预算空间效率低。

为什么明明抢到红包，点开后发现没有？

2014 年的红包一点开就知道金额，分两次操作，先抢到金额，然后再转账。2015 年的红包的拆和抢是分离的，需要点两次，因此会出现抢到红包了，但点开后告知红包已经被领完的状况。进入到第一个页面不代表抢到，只表示当时红包还有。

红包里的金额怎么算？为什么出现各个红包金额相差很大？

随机，额度在 0.01 和剩余平均值*2 之间。

例如：发 100 块钱，总共 10 个红包，那么平均值是 10 块钱一个，那么发出来的红包的额度在 0.01 元～20 元之间波动。当前面 3 个红包总共被领了 40 块钱时，剩下 60 块钱，总共 7 个红包，那么这 7 个红包的额度在：0.01～（60/7*2）=17.14 之间。

注意：这里的算法是每被抢一个后，剩下的会再次执行上面的这样的算法。这样算下去，会超过最开始的全部金额，因此到了最后面如果不够这么算，那么会采取如下算法：保证剩余用户能拿到最低 1 分钱即可。如果前面的人手气不好，那么后面的余额越多，红包额度也就越多，因此实际概率一样的。

红包的设计

微信从财付通拉取金额数据过来，生成个数/红包类型/金额放到 redis 集群里，app 端将红包 ID 的请求放入请求队列中，如果发现超过红包的个数，直接返回。根据红包的逻辑处理成功得到令牌请求，则由财付通进行一致性调用，通过像比特币一样，两边保存交易记录，交易后交给第三方服务审计，如果交易过程中出现不一致就强制回归。

红包如何计算被抢完？

cache 会抵抗无效请求，将无效的请求过滤掉，实际进入到后台的量不大。cache 记录红包个数，原子操作进行个数递减，到 0 表示被抢光。财付通按照 20 万笔每秒入账准备，但实际还不到 8 万每秒。

通如何保持 8w 每秒的写入？

多主 sharding，水平扩展机器。

据容量多少？

一个红包只占一条记录，有效期只有几天，因此不需要太多空间。

查询红包分配，压力大不？

抢到红包的人数和红包都在一条 cache 记录上，没有太大的查询压力。

一个红包一个队列？

没有队列，一个红包一条数据，数据上有一个计数器字段。

有没有从数据上证明每个红包的概率是不是均等？

不是绝对均等，就是一个简单的拍脑袋算法。

拍脑袋算法，会不会出现两个最佳？

会出现金额一样的，但是手气最佳只有一个，先抢到的那个最佳。

每领一个红包就更新数据么？

每抢到一个红包，就 cas 更新剩余金额和红包个数。

红包如何入库入账？

数据库会累加已经领取的个数与金额，插入一条领取记录，入账则是后台异步操作。

入帐出错怎么办？比如红包个数没了，但余额还有？

最后会有一个 take all 操作，另外还有一个对账来保障。

#### 1.2 秒杀系统相关问题

**参考答案**

秒杀应该考虑哪些问题？

1.  超卖问题

    分析秒杀的业务场景,最重要的有一点就是超卖问题，假如备货只有 100 个，但是最终超卖了 200，一般来讲秒杀系统的价格都比较低，如果超卖将严重影响公司的财产利益，因此首当其冲的就是解决商品的超卖问题。

2.  高并发

    秒杀具有时间短、并发量大的特点，秒杀持续时间只有几分钟，而一般公司都为了制造轰动效应，会以极低的价格来吸引用户，因此参与抢购的用户会非常的多。短时间内会有大量请求涌进来，后端如何防止并发过高造成缓存击穿或者失效，击垮数据库都是需要考虑的问题。

3.  接口防刷

    现在的秒杀大多都会出来针对秒杀对应的软件，这类软件会模拟不断向后台服务器发起请求，一秒几百次都是很常见的，如何防止这类软件的重复无效请求，防止不断发起的请求也是需要我们针对性考虑的。

4.  秒杀 URL

    对于普通用户来讲，看到的只是一个比较简单的秒杀页面，在未达到规定时间，秒杀按钮是灰色的，一旦到达规定时间，灰色按钮变成可点击状态。这部分是针对小白用户的，如果是稍微有点电脑功底的用户，会通过 F12 看浏览器的 network 看到秒杀的 url，通过特定软件去请求也可以实现秒杀。或者提前知道秒杀 url 的人，一请求就直接实现秒杀了。这个问题我们需要考虑解决。

5.  数据库设计

    秒杀有把我们服务器击垮的风险，如果让它与我们的其他业务使用在同一个数据库中，耦合在一起，就很有可能牵连和影响其他的业务。如何防止这类问题发生，就算秒杀发生了宕机、服务器卡死问题，也应该让他尽量不影响线上正常进行的业务。

秒杀系统的设计方案

1.  秒杀系统的数据库设计

    针对秒杀的数据库问题，应该单独设计一个秒杀数据库，防止因为秒杀活动的高并发访问拖垮整个网站。这里只需要两张表，一张是秒杀订单表，一张是秒杀货品表：

    ![](img/f4911c729eac63d001c0c328bd528717.png)

    ![](img/59172dc37417c7aa030432ccfa8769c5.png)

    其实应该还有几张表，商品表：可以关联 goods_id 查到具体的商品信息，商品图像、名称、平时价格、秒杀价格等，还有用户表：根据用户 user_id 可以查询到用户昵称、用户手机号，收货地址等其他额外信息，这个具体就不给出实例了。

2.  秒杀 URL 的设计

    为了避免有程序访问经验的人通过下单页面 url 直接访问后台接口来秒杀货品，我们需要将秒杀的 url 实现动态化，即使是开发整个系统的人都无法在秒杀开始前知道秒杀的 url。具体的做法就是通过 md5 加密一串随机字符作为秒杀的 url，然后前端访问后台获取具体的 url，后台校验通过之后才可以继续秒杀。

3.  秒杀页面静态化

    将商品的描述、参数、成交记录、图像、评价等全部写入到一个静态页面，用户请求不需要通过访问后端服务器，不需要经过数据库，直接在前台客户端生成，这样可以最大可能的减少服务器的压力。具体的方法可以使用 freemarker 模板技术，建立网页模板，填充数据，然后渲染网页。

4.  单体 redis 升级为集群 redis

    秒杀是一个读多写少的场景，使用 redis 做缓存再合适不过。不过考虑到缓存击穿问题，我们应该构建 redis 集群，或采用哨兵模式，可以提升 redis 的性能和可用性。

5.  使用 nginx

    nginx 是一个高性能 web 服务器，它的并发能力可以达到几万，而 tomcat 只有几百。通过 nginx 映射客户端请求，再分发到后台 tomcat 服务器集群中可以大大提升并发能力。

6.  精简 SQL

    典型的一个场景是在进行扣减库存的时候，传统的做法是先查询库存，再去 update。这样的话需要两个 sql，而实际上一个 sql 我们就可以完成的。可以用这样的做法：`update miaosha_goods set stock=stock-1 where goos_id={#goods_id} and version=#{version} and sock>0;` 。这样的话，就可以保证库存不会超卖并且一次更新库存,还有注意一点这里使用了版本号的乐观锁，相比较悲观锁，它的性能较好。

7.  redis 预减库存

    很多请求进来，都需要后台查询库存,这是一个频繁读的场景。可以使用 redis 来预减库存，在秒杀开始前可以在 redis 设值，比如 `redis.set(goodsId,100)`，这里预放的库存为 100 可以设值为常量)，每次下单成功之后，`Integer stock = (Integer)redis.get(goosId);` 然后判断 sock 的值，如果小于常量值就减去 1。不过注意当取消的时候,需要增加库存，增加库存的时候也得注意不能大于之间设定的总库存数(查询库存和扣减库存需要原子操作，此时可以借助 lua 脚本)下次下单再获取库存的时候,直接从 redis 里面查就可以了。

8.  接口限流

    秒杀最终的本质是数据库的更新，但是有很多大量无效的请求，我们最终要做的就是如何把这些无效的请求过滤掉，防止渗透到数据库。限流的话，需要入手的方面很多：

    *   前端限流：首先第一步就是通过前端限流，用户在秒杀按钮点击以后发起请求，那么在接下来的 5 秒是无法点击（通过设置按钮为 disable）。这一小举措开发起来成本很小，但是很有效。
    *   同一个用户 x 秒内重复请求直接拒绝：具体多少秒需要根据实际业务和秒杀的人数而定，一般限定为 10 秒。具体的做法就是通过 redis 的键过期策略，首先对每个请求都从`String value = redis.get(userId);`。如果获取到这个 value 为空或者为 null，表示它是有效的请求，然后放行这个请求。如果不为空表示它是重复性请求，直接丢掉这个请求。如果有效,采用`redis.setexpire(userId,value,10).value` 可以是任意值，一般放业务属性比较好,这个是设置以 userId 为 key，10 秒的过期时间（10 秒后,key 对应的值自动为 null）。
    *   令牌桶算法限流：接口限流的策略有很多，我们这里采用令牌桶算法。令牌桶算法的基本思路是每个请求尝试获取一个令牌，后端只处理持有令牌的请求，生产令牌的速度和效率我们都可以自己限定。
9.  异步下单

    为了提升下单的效率，并且防止下单服务的失败。需要将下单这一操作进行异步处理。最常采用的办法是使用队列，队列最显著的三个优点：异步、削峰、解耦。这里可以采用 rabbitmq，在后台经过了限流、库存校验之后，流入到这一步骤的就是有效请求。然后发送到队列里，队列接受消息，异步下单。下完单，入库没有问题可以用短信通知用户秒杀成功。假如失败的话，可以采用补偿机制，重试。

10.  服务降级

    假如在秒杀过程中出现了某个服务器宕机，或者服务不可用，应该做好后备工作。之前的博客里有介绍通过 Hystrix 进行服务熔断和降级，可以开发一个备用服务，假如服务器真的宕机了，直接给用户一个友好的提示返回，而不是直接卡死，服务器错误等生硬的反馈。